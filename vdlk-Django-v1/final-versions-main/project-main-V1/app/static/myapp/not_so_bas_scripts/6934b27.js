/*! For license information please see LICENSES */
(window.webpackJsonp = window.webpackJsonp || []).push([[23], {
    459: function(t, e, n) {
        "use strict";
        function o() {}
        n.d(e, "a", (function() {
            return we
        }
        )),
        n.d(e, "b", (function() {
            return U
        }
        )),
        n.d(e, "c", (function() {
            return f
        }
        )),
        n.d(e, "d", (function() {
            return _
        }
        )),
        n.d(e, "e", (function() {
            return Ne
        }
        )),
        n.d(e, "f", (function() {
            return ct
        }
        )),
        n.d(e, "g", (function() {
            return tt
        }
        )),
        n.d(e, "h", (function() {
            return me
        }
        )),
        n.d(e, "i", (function() {
            return N
        }
        )),
        n.d(e, "j", (function() {
            return lt
        }
        )),
        n.d(e, "k", (function() {
            return ye
        }
        )),
        n.d(e, "l", (function() {
            return Fe
        }
        )),
        n.d(e, "m", (function() {
            return Me
        }
        )),
        n.d(e, "n", (function() {
            return Pe
        }
        )),
        n.d(e, "o", (function() {
            return je
        }
        )),
        n.d(e, "p", (function() {
            return We
        }
        )),
        n.d(e, "q", (function() {
            return I
        }
        )),
        n.d(e, "r", (function() {
            return v
        }
        )),
        n.d(e, "s", (function() {
            return wt
        }
        )),
        n.d(e, "t", (function() {
            return Mt
        }
        )),
        n.d(e, "u", (function() {
            return z
        }
        )),
        n.d(e, "v", (function() {
            return ue
        }
        )),
        n.d(e, "w", (function() {
            return k
        }
        )),
        n.d(e, "x", (function() {
            return A
        }
        )),
        n.d(e, "y", (function() {
            return xi
        }
        )),
        n.d(e, "z", (function() {
            return bt
        }
        )),
        n.d(e, "A", (function() {
            return ft
        }
        )),
        n.d(e, "B", (function() {
            return yt
        }
        )),
        n.d(e, "C", (function() {
            return Ve
        }
        )),
        n.d(e, "D", (function() {
            return it
        }
        )),
        n.d(e, "E", (function() {
            return _i
        }
        )),
        n.d(e, "F", (function() {
            return ui
        }
        )),
        n.d(e, "G", (function() {
            return wi
        }
        )),
        n.d(e, "H", (function() {
            return vt
        }
        )),
        n.d(e, "I", (function() {
            return Oi
        }
        )),
        n.d(e, "J", (function() {
            return di
        }
        )),
        n.d(e, "K", (function() {
            return fe
        }
        )),
        n.d(e, "L", (function() {
            return L
        }
        )),
        n.d(e, "M", (function() {
            return Ye
        }
        )),
        n.d(e, "N", (function() {
            return Ai
        }
        )),
        n.d(e, "O", (function() {
            return Ti
        }
        )),
        n.d(e, "P", (function() {
            return jt
        }
        )),
        n.d(e, "Q", (function() {
            return Li
        }
        )),
        n.d(e, "R", (function() {
            return Oe
        }
        )),
        n.d(e, "S", (function() {
            return o
        }
        )),
        n.d(e, "T", (function() {
            return nt
        }
        )),
        n.d(e, "U", (function() {
            return G
        }
        )),
        n.d(e, "V", (function() {
            return $
        }
        )),
        n.d(e, "W", (function() {
            return J
        }
        )),
        n.d(e, "X", (function() {
            return K
        }
        )),
        n.d(e, "Y", (function() {
            return et
        }
        )),
        n.d(e, "Z", (function() {
            return xe
        }
        )),
        n.d(e, "ab", (function() {
            return gt
        }
        )),
        n.d(e, "bb", (function() {
            return ut
        }
        )),
        n.d(e, "cb", (function() {
            return He
        }
        )),
        n.d(e, "db", (function() {
            return Xe
        }
        )),
        n.d(e, "eb", (function() {
            return S
        }
        )),
        n.d(e, "fb", (function() {
            return r
        }
        )),
        n.d(e, "gb", (function() {
            return Ot
        }
        )),
        n.d(e, "hb", (function() {
            return vi
        }
        )),
        n.d(e, "ib", (function() {
            return _e
        }
        )),
        n.d(e, "jb", (function() {
            return E
        }
        )),
        n.d(e, "kb", (function() {
            return O
        }
        )),
        n.d(e, "lb", (function() {
            return R
        }
        )),
        n.d(e, "mb", (function() {
            return ht
        }
        )),
        n.d(e, "nb", (function() {
            return Re
        }
        )),
        n.d(e, "ob", (function() {
            return hi
        }
        )),
        n.d(e, "pb", (function() {
            return Fi
        }
        )),
        n.d(e, "qb", (function() {
            return zi
        }
        )),
        n.d(e, "rb", (function() {
            return ji
        }
        )),
        n.d(e, "sb", (function() {
            return ki
        }
        )),
        n.d(e, "tb", (function() {
            return Mi
        }
        )),
        n.d(e, "ub", (function() {
            return ke
        }
        )),
        n.d(e, "vb", (function() {
            return Se
        }
        )),
        n.d(e, "wb", (function() {
            return ve
        }
        )),
        n.d(e, "xb", (function() {
            return De
        }
        )),
        n.d(e, "yb", (function() {
            return Ie
        }
        )),
        n.d(e, "zb", (function() {
            return ze
        }
        )),
        n.d(e, "Ab", (function() {
            return Ii
        }
        )),
        n.d(e, "Bb", (function() {
            return ot
        }
        )),
        n.d(e, "Cb", (function() {
            return l
        }
        )),
        n.d(e, "Db", (function() {
            return V
        }
        )),
        n.d(e, "Eb", (function() {
            return B
        }
        )),
        n.d(e, "Fb", (function() {
            return H
        }
        )),
        n.d(e, "Gb", (function() {
            return he
        }
        )),
        n.d(e, "Hb", (function() {
            return pe
        }
        )),
        n.d(e, "Ib", (function() {
            return At
        }
        )),
        n.d(e, "Jb", (function() {
            return D
        }
        )),
        n.d(e, "Kb", (function() {
            return d
        }
        )),
        n.d(e, "Lb", (function() {
            return Be
        }
        )),
        n.d(e, "Mb", (function() {
            return h
        }
        )),
        n.d(e, "Nb", (function() {
            return T
        }
        )),
        n.d(e, "Ob", (function() {
            return c
        }
        )),
        n.d(e, "Pb", (function() {
            return mt
        }
        )),
        n.d(e, "Qb", (function() {
            return x
        }
        )),
        n.d(e, "Rb", (function() {
            return y
        }
        )),
        n.d(e, "Sb", (function() {
            return Pi
        }
        )),
        n.d(e, "Tb", (function() {
            return at
        }
        )),
        n.d(e, "Ub", (function() {
            return kt
        }
        )),
        n.d(e, "Vb", (function() {
            return _t
        }
        )),
        n.d(e, "Wb", (function() {
            return X
        }
        )),
        n.d(e, "Xb", (function() {
            return Q
        }
        )),
        n.d(e, "Yb", (function() {
            return xt
        }
        )),
        n.d(e, "Zb", (function() {
            return m
        }
        )),
        n.d(e, "ac", (function() {
            return St
        }
        )),
        n.d(e, "bc", (function() {
            return Z
        }
        )),
        n.d(e, "cc", (function() {
            return ii
        }
        )),
        n.d(e, "dc", (function() {
            return Y
        }
        ));
        const r = function() {
            let t = 0;
            return function() {
                return t++
            }
        }();
        function c(t) {
            return null == t
        }
        function l(t) {
            if (Array.isArray && Array.isArray(t))
                return !0;
            const e = Object.prototype.toString.call(t);
            return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6)
        }
        function h(t) {
            return null !== t && "[object Object]" === Object.prototype.toString.call(t)
        }
        const d = t=>("number" == typeof t || t instanceof Number) && isFinite(+t);
        function f(t, e) {
            return d(t) ? t : e
        }
        function m(t, e) {
            return void 0 === t ? e : t
        }
        const x = (t,e)=>"string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : t / e
          , y = (t,e)=>"string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;
        function _(t, e, n) {
            if (t && "function" == typeof t.call)
                return t.apply(n, e)
        }
        function v(t, e, n, o) {
            let i, r, c;
            if (l(t))
                if (r = t.length,
                o)
                    for (i = r - 1; i >= 0; i--)
                        e.call(n, t[i], i);
                else
                    for (i = 0; i < r; i++)
                        e.call(n, t[i], i);
            else if (h(t))
                for (c = Object.keys(t),
                r = c.length,
                i = 0; i < r; i++)
                    e.call(n, t[c[i]], c[i])
        }
        function O(t, e) {
            let i, n, o, r;
            if (!t || !e || t.length !== e.length)
                return !1;
            for (i = 0,
            n = t.length; i < n; ++i)
                if (o = t[i],
                r = e[i],
                o.datasetIndex !== r.datasetIndex || o.index !== r.index)
                    return !1;
            return !0
        }
        function w(source) {
            if (l(source))
                return source.map(w);
            if (h(source)) {
                const t = Object.create(null)
                  , e = Object.keys(source)
                  , n = e.length;
                let o = 0;
                for (; o < n; ++o)
                    t[e[o]] = w(source[e[o]]);
                return t
            }
            return source
        }
        function M(t) {
            return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
        }
        function j(t, e, source, n) {
            if (!M(t))
                return;
            const o = e[t]
              , r = source[t];
            h(o) && h(r) ? k(o, r, n) : e[t] = w(r)
        }
        function k(t, source, e) {
            const n = l(source) ? source : [source]
              , o = n.length;
            if (!h(t))
                return t;
            const r = (e = e || {}).merger || j;
            for (let i = 0; i < o; ++i) {
                if (!h(source = n[i]))
                    continue;
                const o = Object.keys(source);
                for (let n = 0, c = o.length; n < c; ++n)
                    r(o[n], t, source, e)
            }
            return t
        }
        function S(t, source) {
            return k(t, source, {
                merger: P
            })
        }
        function P(t, e, source) {
            if (!M(t))
                return;
            const n = e[t]
              , o = source[t];
            h(n) && h(o) ? S(n, o) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = w(o))
        }
        const C = {
            "": t=>t,
            x: t=>t.x,
            y: t=>t.y
        };
        function D(t, e) {
            const n = C[e] || (C[e] = function(t) {
                const e = function(t) {
                    const e = t.split(".")
                      , n = [];
                    let o = "";
                    for (const t of e)
                        o += t,
                        o.endsWith("\\") ? o = o.slice(0, -1) + "." : (n.push(o),
                        o = "");
                    return n
                }(t);
                return t=>{
                    for (const n of e) {
                        if ("" === n)
                            break;
                        t = t && t[n]
                    }
                    return t
                }
            }(e));
            return n(t)
        }
        function A(t) {
            return t.charAt(0).toUpperCase() + t.slice(1)
        }
        const T = t=>void 0 !== t
          , L = t=>"function" == typeof t
          , E = (a,b)=>{
            if (a.size !== b.size)
                return !1;
            for (const t of a)
                if (!b.has(t))
                    return !1;
            return !0
        }
        ;
        function R(t) {
            return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type
        }
        const I = Math.PI
          , z = 2 * I
          , F = z + I
          , W = Number.POSITIVE_INFINITY
          , V = I / 180
          , N = I / 2
          , B = I / 4
          , H = 2 * I / 3
          , Y = Math.log10
          , X = Math.sign;
        function $(t) {
            const e = Math.round(t);
            t = K(t, e, t / 1e3) ? e : t;
            const n = Math.pow(10, Math.floor(Y(t)))
              , o = t / n;
            return (o <= 1 ? 1 : o <= 2 ? 2 : o <= 5 ? 5 : 10) * n
        }
        function U(t) {
            const e = []
              , n = Math.sqrt(t);
            let i;
            for (i = 1; i < n; i++)
                t % i == 0 && (e.push(i),
                e.push(t / i));
            return n === (0 | n) && e.push(n),
            e.sort(((a,b)=>a - b)).pop(),
            e
        }
        function Z(t) {
            return !isNaN(parseFloat(t)) && isFinite(t)
        }
        function K(t, e, n) {
            return Math.abs(t - e) < n
        }
        function J(t, e) {
            const n = Math.round(t);
            return n - e <= t && n + e >= t
        }
        function G(t, e, n) {
            let i, o, r;
            for (i = 0,
            o = t.length; i < o; i++)
                r = t[i][n],
                isNaN(r) || (e.min = Math.min(e.min, r),
                e.max = Math.max(e.max, r))
        }
        function Q(t) {
            return t * (I / 180)
        }
        function tt(t) {
            return t * (180 / I)
        }
        function et(t) {
            if (!d(t))
                return;
            let e = 1
              , p = 0;
            for (; Math.round(t * e) / e !== t; )
                e *= 10,
                p++;
            return p
        }
        function it(t, e) {
            const n = e.x - t.x
              , o = e.y - t.y
              , r = Math.sqrt(n * n + o * o);
            let c = Math.atan2(o, n);
            return c < -.5 * I && (c += z),
            {
                angle: c,
                distance: r
            }
        }
        function nt(t, e) {
            return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
        }
        function st(a, b) {
            return (a - b + F) % z - I
        }
        function ot(a) {
            return (a % z + z) % z
        }
        function at(t, e, n, o) {
            const a = ot(t)
              , s = ot(e)
              , r = ot(n)
              , c = ot(s - a)
              , l = ot(r - a)
              , h = ot(a - s)
              , d = ot(a - r);
            return a === s || a === r || o && s === r || c > l && h < d
        }
        function ct(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }
        function lt(t) {
            return ct(t, -32768, 32767)
        }
        function ht(t, e, n, o=1e-6) {
            return t >= Math.min(e, n) - o && t <= Math.max(e, n) + o
        }
        function ut(table, t, e) {
            e = e || (e=>table[e] < t);
            let n, o = table.length - 1, r = 0;
            for (; o - r > 1; )
                n = r + o >> 1,
                e(n) ? r = n : o = n;
            return {
                lo: r,
                hi: o
            }
        }
        const ft = (table,t,e,n)=>ut(table, e, n ? n=>table[n][t] <= e : n=>table[n][t] < e)
          , bt = (table,t,e)=>ut(table, e, (n=>table[n][t] >= e));
        function gt(t, e, n) {
            let o = 0
              , r = t.length;
            for (; o < r && t[o] < e; )
                o++;
            for (; r > o && t[r - 1] > n; )
                r--;
            return o > 0 || r < t.length ? t.slice(o, r) : t
        }
        const pt = ["push", "pop", "shift", "splice", "unshift"];
        function mt(t, e) {
            t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", {
                configurable: !0,
                enumerable: !1,
                value: {
                    listeners: [e]
                }
            }),
            pt.forEach((e=>{
                const n = "_onData" + A(e)
                  , base = t[e];
                Object.defineProperty(t, e, {
                    configurable: !0,
                    enumerable: !1,
                    value(...e) {
                        const o = base.apply(this, e);
                        return t._chartjs.listeners.forEach((object=>{
                            "function" == typeof object[n] && object[n](...e)
                        }
                        )),
                        o
                    }
                })
            }
            )))
        }
        function xt(t, e) {
            const n = t._chartjs;
            if (!n)
                return;
            const o = n.listeners
              , r = o.indexOf(e);
            -1 !== r && o.splice(r, 1),
            o.length > 0 || (pt.forEach((e=>{
                delete t[e]
            }
            )),
            delete t._chartjs)
        }
        function yt(t) {
            const e = new Set;
            let i, n;
            for (i = 0,
            n = t.length; i < n; ++i)
                e.add(t[i]);
            return e.size === n ? t : Array.from(e)
        }
        const _t = "undefined" == typeof window ? function(t) {
            return t()
        }
        : window.requestAnimationFrame;
        function vt(t, e, n) {
            const o = n || (t=>Array.prototype.slice.call(t));
            let r = !1
              , c = [];
            return function(...n) {
                c = o(n),
                r || (r = !0,
                _t.call(window, (()=>{
                    r = !1,
                    t.apply(e, c)
                }
                )))
            }
        }
        function Ot(t, e) {
            let n;
            return function(...o) {
                return e ? (clearTimeout(n),
                n = setTimeout(t, e, o)) : t.apply(this, o),
                e
            }
        }
        const wt = t=>"start" === t ? "left" : "end" === t ? "right" : "center"
          , Mt = (t,e,n)=>"start" === t ? e : "end" === t ? n : (e + n) / 2
          , jt = (t,e,n,o)=>t === (o ? "left" : "right") ? n : "center" === t ? (e + n) / 2 : e;
        function kt(meta, t, e) {
            const n = t.length;
            let o = 0
              , r = n;
            if (meta._sorted) {
                const {iScale: c, _parsed: l} = meta
                  , h = c.axis
                  , {min: d, max: f, minDefined: m, maxDefined: x} = c.getUserBounds();
                m && (o = ct(Math.min(ft(l, c.axis, d).lo, e ? n : ft(t, h, c.getPixelForValue(d)).lo), 0, n - 1)),
                r = x ? ct(Math.max(ft(l, c.axis, f, !0).hi + 1, e ? 0 : ft(t, h, c.getPixelForValue(f), !0).hi + 1), o, n) - o : n - o
            }
            return {
                start: o,
                count: r
            }
        }
        function St(meta) {
            const {xScale: t, yScale: e, _scaleRanges: n} = meta
              , o = {
                xmin: t.min,
                xmax: t.max,
                ymin: e.min,
                ymax: e.max
            };
            if (!n)
                return meta._scaleRanges = o,
                !0;
            const r = n.xmin !== t.min || n.xmax !== t.max || n.ymin !== e.min || n.ymax !== e.max;
            return Object.assign(n, o),
            r
        }
        const Pt = t=>0 === t || 1 === t
          , Ct = (t,s,p)=>-Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * z / p)
          , Dt = (t,s,p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * z / p) + 1
          , At = {
            linear: t=>t,
            easeInQuad: t=>t * t,
            easeOutQuad: t=>-t * (t - 2),
            easeInOutQuad: t=>(t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
            easeInCubic: t=>t * t * t,
            easeOutCubic: t=>(t -= 1) * t * t + 1,
            easeInOutCubic: t=>(t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
            easeInQuart: t=>t * t * t * t,
            easeOutQuart: t=>-((t -= 1) * t * t * t - 1),
            easeInOutQuart: t=>(t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
            easeInQuint: t=>t * t * t * t * t,
            easeOutQuint: t=>(t -= 1) * t * t * t * t + 1,
            easeInOutQuint: t=>(t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
            easeInSine: t=>1 - Math.cos(t * N),
            easeOutSine: t=>Math.sin(t * N),
            easeInOutSine: t=>-.5 * (Math.cos(I * t) - 1),
            easeInExpo: t=>0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
            easeOutExpo: t=>1 === t ? 1 : 1 - Math.pow(2, -10 * t),
            easeInOutExpo: t=>Pt(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
            easeInCirc: t=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
            easeOutCirc: t=>Math.sqrt(1 - (t -= 1) * t),
            easeInOutCirc: t=>(t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
            easeInElastic: t=>Pt(t) ? t : Ct(t, .075, .3),
            easeOutElastic: t=>Pt(t) ? t : Dt(t, .075, .3),
            easeInOutElastic(t) {
                const s = .1125;
                return Pt(t) ? t : t < .5 ? .5 * Ct(2 * t, s, .45) : .5 + .5 * Dt(2 * t - 1, s, .45)
            },
            easeInBack(t) {
                const s = 1.70158;
                return t * t * ((s + 1) * t - s)
            },
            easeOutBack(t) {
                const s = 1.70158;
                return (t -= 1) * t * ((s + 1) * t + s) + 1
            },
            easeInOutBack(t) {
                let s = 1.70158;
                return (t /= .5) < 1 ? t * t * ((1 + (s *= 1.525)) * t - s) * .5 : .5 * ((t -= 2) * t * ((1 + (s *= 1.525)) * t + s) + 2)
            },
            easeInBounce: t=>1 - At.easeOutBounce(1 - t),
            easeOutBounce(t) {
                const e = 7.5625
                  , n = 2.75;
                return t < 1 / n ? e * t * t : t < 2 / n ? e * (t -= 1.5 / n) * t + .75 : t < 2.5 / n ? e * (t -= 2.25 / n) * t + .9375 : e * (t -= 2.625 / n) * t + .984375
            },
            easeInOutBounce: t=>t < .5 ? .5 * At.easeInBounce(2 * t) : .5 * At.easeOutBounce(2 * t - 1) + .5
        };
        function Tt(t) {
            return t + .5 | 0
        }
        const Lt = (t,e,n)=>Math.max(Math.min(t, n), e);
        function Et(t) {
            return Lt(Tt(2.55 * t), 0, 255)
        }
        function Rt(t) {
            return Lt(Tt(255 * t), 0, 255)
        }
        function It(t) {
            return Lt(Tt(t / 2.55) / 100, 0, 1)
        }
        function zt(t) {
            return Lt(Tt(100 * t), 0, 100)
        }
        const Ft = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            A: 10,
            B: 11,
            C: 12,
            D: 13,
            E: 14,
            F: 15,
            a: 10,
            b: 11,
            c: 12,
            d: 13,
            e: 14,
            f: 15
        }
          , Wt = [..."0123456789ABCDEF"]
          , h1 = b=>Wt[15 & b]
          , h2 = b=>Wt[(240 & b) >> 4] + Wt[15 & b]
          , Vt = b=>(240 & b) >> 4 == (15 & b);
        function Nt(t) {
            var e = (t=>Vt(t.r) && Vt(t.g) && Vt(t.b) && Vt(t.a))(t) ? h1 : h2;
            return t ? "#" + e(t.r) + e(t.g) + e(t.b) + ((a,t)=>a < 255 ? t(a) : "")(t.a, e) : void 0
        }
        const Bt = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function Ht(t, s, e) {
            const a = s * Math.min(e, 1 - e)
              , n = (n,o=(n + t / 30) % 12)=>e - a * Math.max(Math.min(o - 3, 9 - o, 1), -1);
            return [n(0), n(8), n(4)]
        }
        function Yt(t, s, e) {
            const n = (n,o=(n + t / 60) % 6)=>e - e * s * Math.max(Math.min(o, 4 - o, 1), 0);
            return [n(5), n(3), n(1)]
        }
        function Xt(t, e, b) {
            const n = Ht(t, 1, .5);
            let i;
            for (e + b > 1 && (i = 1 / (e + b),
            e *= i,
            b *= i),
            i = 0; i < 3; i++)
                n[i] *= 1 - e - b,
                n[i] += e;
            return n
        }
        function $t(t) {
            const e = t.r / 255
              , g = t.g / 255
              , b = t.b / 255
              , n = Math.max(e, g, b)
              , o = Math.min(e, g, b)
              , r = (n + o) / 2;
            let c, s, l;
            return n !== o && (l = n - o,
            s = r > .5 ? l / (2 - n - o) : l / (n + o),
            c = function(t, g, b, e, n) {
                return t === n ? (g - b) / e + (g < b ? 6 : 0) : g === n ? (b - t) / e + 2 : (t - g) / e + 4
            }(e, g, b, l, n),
            c = 60 * c + .5),
            [0 | c, s || 0, r]
        }
        function Ut(t, a, b, e) {
            return (Array.isArray(a) ? t(a[0], a[1], a[2]) : t(a, b, e)).map(Rt)
        }
        function Zt(t, s, e) {
            return Ut(Ht, t, s, e)
        }
        function qt(t) {
            return (t % 360 + 360) % 360
        }
        function Kt(t) {
            const e = Bt.exec(t);
            let n, a = 255;
            if (!e)
                return;
            e[5] !== n && (a = e[6] ? Et(+e[5]) : Rt(+e[5]));
            const o = qt(+e[2])
              , r = +e[3] / 100
              , c = +e[4] / 100;
            return n = "hwb" === e[1] ? function(t, e, b) {
                return Ut(Xt, t, e, b)
            }(o, r, c) : "hsv" === e[1] ? function(t, s, e) {
                return Ut(Yt, t, s, e)
            }(o, r, c) : Zt(o, r, c),
            {
                r: n[0],
                g: n[1],
                b: n[2],
                a: a
            }
        }
        const map = {
            x: "dark",
            Z: "light",
            Y: "re",
            X: "blu",
            W: "gr",
            V: "medium",
            U: "slate",
            A: "ee",
            T: "ol",
            S: "or",
            B: "ra",
            C: "lateg",
            D: "ights",
            R: "in",
            Q: "turquois",
            E: "hi",
            P: "ro",
            O: "al",
            N: "le",
            M: "de",
            L: "yello",
            F: "en",
            K: "ch",
            G: "arks",
            H: "ea",
            I: "ightg",
            J: "wh"
        }
          , Jt = {
            OiceXe: "f0f8ff",
            antiquewEte: "faebd7",
            aqua: "ffff",
            aquamarRe: "7fffd4",
            azuY: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "0",
            blanKedOmond: "ffebcd",
            Xe: "ff",
            XeviTet: "8a2be2",
            bPwn: "a52a2a",
            burlywood: "deb887",
            caMtXe: "5f9ea0",
            KartYuse: "7fff00",
            KocTate: "d2691e",
            cSO: "ff7f50",
            cSnflowerXe: "6495ed",
            cSnsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "ffff",
            xXe: "8b",
            xcyan: "8b8b",
            xgTMnPd: "b8860b",
            xWay: "a9a9a9",
            xgYF: "6400",
            xgYy: "a9a9a9",
            xkhaki: "bdb76b",
            xmagFta: "8b008b",
            xTivegYF: "556b2f",
            xSange: "ff8c00",
            xScEd: "9932cc",
            xYd: "8b0000",
            xsOmon: "e9967a",
            xsHgYF: "8fbc8f",
            xUXe: "483d8b",
            xUWay: "2f4f4f",
            xUgYy: "2f4f4f",
            xQe: "ced1",
            xviTet: "9400d3",
            dAppRk: "ff1493",
            dApskyXe: "bfff",
            dimWay: "696969",
            dimgYy: "696969",
            dodgerXe: "1e90ff",
            fiYbrick: "b22222",
            flSOwEte: "fffaf0",
            foYstWAn: "228b22",
            fuKsia: "ff00ff",
            gaRsbSo: "dcdcdc",
            ghostwEte: "f8f8ff",
            gTd: "ffd700",
            gTMnPd: "daa520",
            Way: "808080",
            gYF: "8000",
            gYFLw: "adff2f",
            gYy: "808080",
            honeyMw: "f0fff0",
            hotpRk: "ff69b4",
            RdianYd: "cd5c5c",
            Rdigo: "4b0082",
            ivSy: "fffff0",
            khaki: "f0e68c",
            lavFMr: "e6e6fa",
            lavFMrXsh: "fff0f5",
            lawngYF: "7cfc00",
            NmoncEffon: "fffacd",
            ZXe: "add8e6",
            ZcSO: "f08080",
            Zcyan: "e0ffff",
            ZgTMnPdLw: "fafad2",
            ZWay: "d3d3d3",
            ZgYF: "90ee90",
            ZgYy: "d3d3d3",
            ZpRk: "ffb6c1",
            ZsOmon: "ffa07a",
            ZsHgYF: "20b2aa",
            ZskyXe: "87cefa",
            ZUWay: "778899",
            ZUgYy: "778899",
            ZstAlXe: "b0c4de",
            ZLw: "ffffe0",
            lime: "ff00",
            limegYF: "32cd32",
            lRF: "faf0e6",
            magFta: "ff00ff",
            maPon: "800000",
            VaquamarRe: "66cdaa",
            VXe: "cd",
            VScEd: "ba55d3",
            VpurpN: "9370db",
            VsHgYF: "3cb371",
            VUXe: "7b68ee",
            VsprRggYF: "fa9a",
            VQe: "48d1cc",
            VviTetYd: "c71585",
            midnightXe: "191970",
            mRtcYam: "f5fffa",
            mistyPse: "ffe4e1",
            moccasR: "ffe4b5",
            navajowEte: "ffdead",
            navy: "80",
            Tdlace: "fdf5e6",
            Tive: "808000",
            TivedBb: "6b8e23",
            Sange: "ffa500",
            SangeYd: "ff4500",
            ScEd: "da70d6",
            pOegTMnPd: "eee8aa",
            pOegYF: "98fb98",
            pOeQe: "afeeee",
            pOeviTetYd: "db7093",
            papayawEp: "ffefd5",
            pHKpuff: "ffdab9",
            peru: "cd853f",
            pRk: "ffc0cb",
            plum: "dda0dd",
            powMrXe: "b0e0e6",
            purpN: "800080",
            YbeccapurpN: "663399",
            Yd: "ff0000",
            Psybrown: "bc8f8f",
            PyOXe: "4169e1",
            saddNbPwn: "8b4513",
            sOmon: "fa8072",
            sandybPwn: "f4a460",
            sHgYF: "2e8b57",
            sHshell: "fff5ee",
            siFna: "a0522d",
            silver: "c0c0c0",
            skyXe: "87ceeb",
            UXe: "6a5acd",
            UWay: "708090",
            UgYy: "708090",
            snow: "fffafa",
            sprRggYF: "ff7f",
            stAlXe: "4682b4",
            tan: "d2b48c",
            teO: "8080",
            tEstN: "d8bfd8",
            tomato: "ff6347",
            Qe: "40e0d0",
            viTet: "ee82ee",
            JHt: "f5deb3",
            wEte: "ffffff",
            wEtesmoke: "f5f5f5",
            Lw: "ffff00",
            LwgYF: "9acd32"
        };
        let Gt;
        function Qt(t) {
            Gt || (Gt = function() {
                const t = {}
                  , e = Object.keys(Jt)
                  , n = Object.keys(map);
                let i, o, r, c, l;
                for (i = 0; i < e.length; i++) {
                    for (c = l = e[i],
                    o = 0; o < n.length; o++)
                        r = n[o],
                        l = l.replace(r, map[r]);
                    r = parseInt(Jt[c], 16),
                    t[l] = [r >> 16 & 255, r >> 8 & 255, 255 & r]
                }
                return t
            }(),
            Gt.transparent = [0, 0, 0, 0]);
            const a = Gt[t.toLowerCase()];
            return a && {
                r: a[0],
                g: a[1],
                b: a[2],
                a: 4 === a.length ? a[3] : 255
            }
        }
        const te = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        const ee = t=>t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055
          , ie = t=>t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
        function ne(t, i, e) {
            if (t) {
                let n = $t(t);
                n[i] = Math.max(0, Math.min(n[i] + n[i] * e, 0 === i ? 360 : 1)),
                n = Zt(n),
                t.r = n[0],
                t.g = n[1],
                t.b = n[2]
            }
        }
        function se(t, e) {
            return t ? Object.assign(e || {}, t) : t
        }
        function oe(input) {
            var t = {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            };
            return Array.isArray(input) ? input.length >= 3 && (t = {
                r: input[0],
                g: input[1],
                b: input[2],
                a: 255
            },
            input.length > 3 && (t.a = Rt(input[3]))) : (t = se(input, {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            })).a = Rt(t.a),
            t
        }
        function re(t) {
            return "r" === t.charAt(0) ? function(t) {
                const e = te.exec(t);
                let n, g, b, a = 255;
                if (e) {
                    if (e[7] !== n) {
                        const t = +e[7];
                        a = e[8] ? Et(t) : Lt(255 * t, 0, 255)
                    }
                    return n = +e[1],
                    g = +e[3],
                    b = +e[5],
                    n = 255 & (e[2] ? Et(n) : Lt(n, 0, 255)),
                    g = 255 & (e[4] ? Et(g) : Lt(g, 0, 255)),
                    b = 255 & (e[6] ? Et(b) : Lt(b, 0, 255)),
                    {
                        r: n,
                        g: g,
                        b: b,
                        a: a
                    }
                }
            }(t) : Kt(t)
        }
        class ae {
            constructor(input) {
                if (input instanceof ae)
                    return input;
                const t = typeof input;
                let e;
                var n, o, r;
                "object" === t ? e = oe(input) : "string" === t && (r = (n = input).length,
                "#" === n[0] && (4 === r || 5 === r ? o = {
                    r: 255 & 17 * Ft[n[1]],
                    g: 255 & 17 * Ft[n[2]],
                    b: 255 & 17 * Ft[n[3]],
                    a: 5 === r ? 17 * Ft[n[4]] : 255
                } : 7 !== r && 9 !== r || (o = {
                    r: Ft[n[1]] << 4 | Ft[n[2]],
                    g: Ft[n[3]] << 4 | Ft[n[4]],
                    b: Ft[n[5]] << 4 | Ft[n[6]],
                    a: 9 === r ? Ft[n[7]] << 4 | Ft[n[8]] : 255
                })),
                e = o || Qt(input) || re(input)),
                this._rgb = e,
                this._valid = !!e
            }
            get valid() {
                return this._valid
            }
            get rgb() {
                var t = se(this._rgb);
                return t && (t.a = It(t.a)),
                t
            }
            set rgb(t) {
                this._rgb = oe(t)
            }
            rgbString() {
                return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${It(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;
                var t
            }
            hexString() {
                return this._valid ? Nt(this._rgb) : void 0
            }
            hslString() {
                return this._valid ? function(t) {
                    if (!t)
                        return;
                    const a = $t(t)
                      , e = a[0]
                      , s = zt(a[1])
                      , n = zt(a[2]);
                    return t.a < 255 ? `hsla(${e}, ${s}%, ${n}%, ${It(t.a)})` : `hsl(${e}, ${s}%, ${n}%)`
                }(this._rgb) : void 0
            }
            mix(t, e) {
                if (t) {
                    const n = this.rgb
                      , o = t.rgb;
                    let r;
                    const p = e === r ? .5 : e
                      , c = 2 * p - 1
                      , a = n.a - o.a
                      , l = ((c * a == -1 ? c : (c + a) / (1 + c * a)) + 1) / 2;
                    r = 1 - l,
                    n.r = 255 & l * n.r + r * o.r + .5,
                    n.g = 255 & l * n.g + r * o.g + .5,
                    n.b = 255 & l * n.b + r * o.b + .5,
                    n.a = p * n.a + (1 - p) * o.a,
                    this.rgb = n
                }
                return this
            }
            interpolate(t, e) {
                return t && (this._rgb = function(t, e, n) {
                    const o = ie(It(t.r))
                      , g = ie(It(t.g))
                      , b = ie(It(t.b));
                    return {
                        r: Rt(ee(o + n * (ie(It(e.r)) - o))),
                        g: Rt(ee(g + n * (ie(It(e.g)) - g))),
                        b: Rt(ee(b + n * (ie(It(e.b)) - b))),
                        a: t.a + n * (e.a - t.a)
                    }
                }(this._rgb, t._rgb, e)),
                this
            }
            clone() {
                return new ae(this.rgb)
            }
            alpha(a) {
                return this._rgb.a = Rt(a),
                this
            }
            clearer(t) {
                return this._rgb.a *= 1 - t,
                this
            }
            greyscale() {
                const t = this._rgb
                  , e = Tt(.3 * t.r + .59 * t.g + .11 * t.b);
                return t.r = t.g = t.b = e,
                this
            }
            opaquer(t) {
                return this._rgb.a *= 1 + t,
                this
            }
            negate() {
                const t = this._rgb;
                return t.r = 255 - t.r,
                t.g = 255 - t.g,
                t.b = 255 - t.b,
                this
            }
            lighten(t) {
                return ne(this._rgb, 2, t),
                this
            }
            darken(t) {
                return ne(this._rgb, 2, -t),
                this
            }
            saturate(t) {
                return ne(this._rgb, 1, t),
                this
            }
            desaturate(t) {
                return ne(this._rgb, 1, -t),
                this
            }
            rotate(t) {
                return function(t, e) {
                    var n = $t(t);
                    n[0] = qt(n[0] + e),
                    n = Zt(n),
                    t.r = n[0],
                    t.g = n[1],
                    t.b = n[2]
                }(this._rgb, t),
                this
            }
        }
        function ce(input) {
            return new ae(input)
        }
        function le(t) {
            if (t && "object" == typeof t) {
                const e = t.toString();
                return "[object CanvasPattern]" === e || "[object CanvasGradient]" === e
            }
            return !1
        }
        function he(t) {
            return le(t) ? t : ce(t)
        }
        function de(t) {
            return le(t) ? t : ce(t).saturate(.5).darken(.1).hexString()
        }
        const ue = Object.create(null)
          , fe = Object.create(null);
        function be(t, e) {
            if (!e)
                return t;
            const n = e.split(".");
            for (let i = 0, e = n.length; i < e; ++i) {
                const e = n[i];
                t = t[e] || (t[e] = Object.create(null))
            }
            return t
        }
        function ge(t, e, n) {
            return "string" == typeof e ? k(be(t, e), n) : k(be(t, ""), e)
        }
        var pe = new class {
            constructor(t) {
                this.animation = void 0,
                this.backgroundColor = "rgba(0,0,0,0.1)",
                this.borderColor = "rgba(0,0,0,0.1)",
                this.color = "#666",
                this.datasets = {},
                this.devicePixelRatio = t=>t.chart.platform.getDevicePixelRatio(),
                this.elements = {},
                this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
                this.font = {
                    family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                    size: 12,
                    style: "normal",
                    lineHeight: 1.2,
                    weight: null
                },
                this.hover = {},
                this.hoverBackgroundColor = (t,e)=>de(e.backgroundColor),
                this.hoverBorderColor = (t,e)=>de(e.borderColor),
                this.hoverColor = (t,e)=>de(e.color),
                this.indexAxis = "x",
                this.interaction = {
                    mode: "nearest",
                    intersect: !0,
                    includeInvisible: !1
                },
                this.maintainAspectRatio = !0,
                this.onHover = null,
                this.onClick = null,
                this.parsing = !0,
                this.plugins = {},
                this.responsive = !0,
                this.scale = void 0,
                this.scales = {},
                this.showLine = !0,
                this.drawActiveElementsOnTop = !0,
                this.describe(t)
            }
            set(t, e) {
                return ge(this, t, e)
            }
            get(t) {
                return be(this, t)
            }
            describe(t, e) {
                return ge(fe, t, e)
            }
            override(t, e) {
                return ge(ue, t, e)
            }
            route(t, e, n, o) {
                const r = be(this, t)
                  , c = be(this, n)
                  , l = "_" + e;
                Object.defineProperties(r, {
                    [l]: {
                        value: r[e],
                        writable: !0
                    },
                    [e]: {
                        enumerable: !0,
                        get() {
                            const t = this[l]
                              , e = c[o];
                            return h(t) ? Object.assign({}, e, t) : m(t, e)
                        },
                        set(t) {
                            this[l] = t
                        }
                    }
                })
            }
        }
        ({
            _scriptable: t=>!t.startsWith("on"),
            _indexable: t=>"events" !== t,
            hover: {
                _fallback: "interaction"
            },
            interaction: {
                _scriptable: !1,
                _indexable: !1
            }
        });
        function me(t, data, e, n, o) {
            let r = data[o];
            return r || (r = data[o] = t.measureText(o).width,
            e.push(o)),
            r > n && (n = r),
            n
        }
        function xe(t, e, n, o) {
            let data = (o = o || {}).data = o.data || {}
              , r = o.garbageCollect = o.garbageCollect || [];
            o.font !== e && (data = o.data = {},
            r = o.garbageCollect = [],
            o.font = e),
            t.save(),
            t.font = e;
            let c = 0;
            const h = n.length;
            let i, d, f, m, x;
            for (i = 0; i < h; i++)
                if (m = n[i],
                null != m && !0 !== l(m))
                    c = me(t, data, r, c, m);
                else if (l(m))
                    for (d = 0,
                    f = m.length; d < f; d++)
                        x = m[d],
                        null == x || l(x) || (c = me(t, data, r, c, x));
            t.restore();
            const y = r.length / 2;
            if (y > n.length) {
                for (i = 0; i < y; i++)
                    delete data[r[i]];
                r.splice(0, y)
            }
            return c
        }
        function ye(t, e, n) {
            const o = t.currentDevicePixelRatio
              , r = 0 !== n ? Math.max(n / 2, .5) : 0;
            return Math.round((e - r) * o) / o + r
        }
        function _e(canvas, t) {
            (t = t || canvas.getContext("2d")).save(),
            t.resetTransform(),
            t.clearRect(0, 0, canvas.width, canvas.height),
            t.restore()
        }
        function ve(t, e, n, o) {
            Oe(t, e, n, o, null)
        }
        function Oe(t, e, n, o, r) {
            let c, l, h, d, f, m;
            const style = e.pointStyle
              , x = e.rotation
              , y = e.radius;
            let _ = (x || 0) * V;
            if (style && "object" == typeof style && (c = style.toString(),
            "[object HTMLImageElement]" === c || "[object HTMLCanvasElement]" === c))
                return t.save(),
                t.translate(n, o),
                t.rotate(_),
                t.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height),
                void t.restore();
            if (!(isNaN(y) || y <= 0)) {
                switch (t.beginPath(),
                style) {
                default:
                    r ? t.ellipse(n, o, r / 2, y, 0, 0, z) : t.arc(n, o, y, 0, z),
                    t.closePath();
                    break;
                case "triangle":
                    t.moveTo(n + Math.sin(_) * y, o - Math.cos(_) * y),
                    _ += H,
                    t.lineTo(n + Math.sin(_) * y, o - Math.cos(_) * y),
                    _ += H,
                    t.lineTo(n + Math.sin(_) * y, o - Math.cos(_) * y),
                    t.closePath();
                    break;
                case "rectRounded":
                    f = .516 * y,
                    d = y - f,
                    l = Math.cos(_ + B) * d,
                    h = Math.sin(_ + B) * d,
                    t.arc(n - l, o - h, f, _ - I, _ - N),
                    t.arc(n + h, o - l, f, _ - N, _),
                    t.arc(n + l, o + h, f, _, _ + N),
                    t.arc(n - h, o + l, f, _ + N, _ + I),
                    t.closePath();
                    break;
                case "rect":
                    if (!x) {
                        d = Math.SQRT1_2 * y,
                        m = r ? r / 2 : d,
                        t.rect(n - m, o - d, 2 * m, 2 * d);
                        break
                    }
                    _ += B;
                case "rectRot":
                    l = Math.cos(_) * y,
                    h = Math.sin(_) * y,
                    t.moveTo(n - l, o - h),
                    t.lineTo(n + h, o - l),
                    t.lineTo(n + l, o + h),
                    t.lineTo(n - h, o + l),
                    t.closePath();
                    break;
                case "crossRot":
                    _ += B;
                case "cross":
                    l = Math.cos(_) * y,
                    h = Math.sin(_) * y,
                    t.moveTo(n - l, o - h),
                    t.lineTo(n + l, o + h),
                    t.moveTo(n + h, o - l),
                    t.lineTo(n - h, o + l);
                    break;
                case "star":
                    l = Math.cos(_) * y,
                    h = Math.sin(_) * y,
                    t.moveTo(n - l, o - h),
                    t.lineTo(n + l, o + h),
                    t.moveTo(n + h, o - l),
                    t.lineTo(n - h, o + l),
                    _ += B,
                    l = Math.cos(_) * y,
                    h = Math.sin(_) * y,
                    t.moveTo(n - l, o - h),
                    t.lineTo(n + l, o + h),
                    t.moveTo(n + h, o - l),
                    t.lineTo(n - h, o + l);
                    break;
                case "line":
                    l = r ? r / 2 : Math.cos(_) * y,
                    h = Math.sin(_) * y,
                    t.moveTo(n - l, o - h),
                    t.lineTo(n + l, o + h);
                    break;
                case "dash":
                    t.moveTo(n, o),
                    t.lineTo(n + Math.cos(_) * y, o + Math.sin(_) * y)
                }
                t.fill(),
                e.borderWidth > 0 && t.stroke()
            }
        }
        function we(t, area, e) {
            return e = e || .5,
            !area || t && t.x > area.left - e && t.x < area.right + e && t.y > area.top - e && t.y < area.bottom + e
        }
        function Me(t, area) {
            t.save(),
            t.beginPath(),
            t.rect(area.left, area.top, area.right - area.left, area.bottom - area.top),
            t.clip()
        }
        function je(t) {
            t.restore()
        }
        function ke(t, e, n, o, r) {
            if (!e)
                return t.lineTo(n.x, n.y);
            if ("middle" === r) {
                const o = (e.x + n.x) / 2;
                t.lineTo(o, e.y),
                t.lineTo(o, n.y)
            } else
                "after" === r != !!o ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y);
            t.lineTo(n.x, n.y)
        }
        function Se(t, e, n, o) {
            if (!e)
                return t.lineTo(n.x, n.y);
            t.bezierCurveTo(o ? e.cp1x : e.cp2x, o ? e.cp1y : e.cp2y, o ? n.cp2x : n.cp1x, o ? n.cp2y : n.cp1y, n.x, n.y)
        }
        function Pe(t, text, e, n, o, r={}) {
            const h = l(text) ? text : [text]
              , d = r.strokeWidth > 0 && "" !== r.strokeColor;
            let i, line;
            for (t.save(),
            t.font = o.string,
            function(t, e) {
                e.translation && t.translate(e.translation[0], e.translation[1]);
                c(e.rotation) || t.rotate(e.rotation);
                e.color && (t.fillStyle = e.color);
                e.textAlign && (t.textAlign = e.textAlign);
                e.textBaseline && (t.textBaseline = e.textBaseline)
            }(t, r),
            i = 0; i < h.length; ++i)
                line = h[i],
                d && (r.strokeColor && (t.strokeStyle = r.strokeColor),
                c(r.strokeWidth) || (t.lineWidth = r.strokeWidth),
                t.strokeText(line, e, n, r.maxWidth)),
                t.fillText(line, e, n, r.maxWidth),
                Ce(t, e, n, line, r),
                n += o.lineHeight;
            t.restore()
        }
        function Ce(t, e, n, line, o) {
            if (o.strikethrough || o.underline) {
                const r = t.measureText(line)
                  , c = e - r.actualBoundingBoxLeft
                  , l = e + r.actualBoundingBoxRight
                  , h = n - r.actualBoundingBoxAscent
                  , d = n + r.actualBoundingBoxDescent
                  , f = o.strikethrough ? (h + d) / 2 : d;
                t.strokeStyle = t.fillStyle,
                t.beginPath(),
                t.lineWidth = o.decorationWidth || 2,
                t.moveTo(c, f),
                t.lineTo(l, f),
                t.stroke()
            }
        }
        function De(t, rect) {
            const {x: e, y: n, w: o, h: r, radius: c} = rect;
            t.arc(e + c.topLeft, n + c.topLeft, c.topLeft, -N, I, !0),
            t.lineTo(e, n + r - c.bottomLeft),
            t.arc(e + c.bottomLeft, n + r - c.bottomLeft, c.bottomLeft, I, N, !0),
            t.lineTo(e + o - c.bottomRight, n + r),
            t.arc(e + o - c.bottomRight, n + r - c.bottomRight, c.bottomRight, N, 0, !0),
            t.lineTo(e + o, n + c.topRight),
            t.arc(e + o - c.topRight, n + c.topRight, c.topRight, 0, -N, !0),
            t.lineTo(e + c.topLeft, n)
        }
        const Ae = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/)
          , Te = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
        function Le(t, e) {
            const n = ("" + t).match(Ae);
            if (!n || "normal" === n[1])
                return 1.2 * e;
            switch (t = +n[2],
            n[3]) {
            case "px":
                return t;
            case "%":
                t /= 100
            }
            return e * t
        }
        const Ee = t=>+t || 0;
        function Re(t, e) {
            const n = {}
              , o = h(e)
              , r = o ? Object.keys(e) : e
              , c = h(t) ? o ? n=>m(t[n], t[e[n]]) : e=>t[e] : ()=>t;
            for (const t of r)
                n[t] = Ee(c(t));
            return n
        }
        function Ie(t) {
            return Re(t, {
                top: "y",
                right: "x",
                bottom: "y",
                left: "x"
            })
        }
        function ze(t) {
            return Re(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
        }
        function Fe(t) {
            const e = Ie(t);
            return e.width = e.left + e.right,
            e.height = e.top + e.bottom,
            e
        }
        function We(t, e) {
            t = t || {},
            e = e || pe.font;
            let n = m(t.size, e.size);
            "string" == typeof n && (n = parseInt(n, 10));
            let style = m(t.style, e.style);
            style && !("" + style).match(Te) && (console.warn('Invalid font style specified: "' + style + '"'),
            style = "");
            const o = {
                family: m(t.family, e.family),
                lineHeight: Le(m(t.lineHeight, e.lineHeight), n),
                size: n,
                style: style,
                weight: m(t.weight, e.weight),
                string: ""
            };
            return o.string = function(t) {
                return !t || c(t.size) || c(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
            }(o),
            o
        }
        function Ve(t, e, n, o) {
            let i, r, c, h = !0;
            for (i = 0,
            r = t.length; i < r; ++i)
                if (c = t[i],
                void 0 !== c && (void 0 !== e && "function" == typeof c && (c = c(e),
                h = !1),
                void 0 !== n && l(c) && (c = c[n % c.length],
                h = !1),
                void 0 !== c))
                    return o && !h && (o.cacheable = !1),
                    c
        }
        function Ne(t, e, n) {
            const {min: o, max: r} = t
              , c = y(e, (r - o) / 2)
              , l = (t,e)=>n && 0 === t ? 0 : t + e;
            return {
                min: l(o, -Math.abs(c)),
                max: l(r, c)
            }
        }
        function Be(t, e) {
            return Object.assign(Object.create(t), e)
        }
        function He(t, e=[""], n=t, o, r=(()=>t[0])) {
            T(o) || (o = ti("_fallback", t));
            const c = {
                [Symbol.toStringTag]: "Object",
                _cacheable: !0,
                _scopes: t,
                _rootScopes: n,
                _fallback: o,
                _getTarget: r,
                override: r=>He([r, ...t], e, n, o)
            };
            return new Proxy(c,{
                deleteProperty: (e,n)=>(delete e[n],
                delete e._keys,
                delete t[0][n],
                !0),
                get: (n,o)=>Ze(n, o, (()=>function(t, e, n, o) {
                    let r;
                    for (const c of e)
                        if (r = ti($e(c, t), n),
                        T(r))
                            return Ue(t, r) ? Ge(n, o, t, r) : r
                }(o, e, t, n))),
                getOwnPropertyDescriptor: (t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
                getPrototypeOf: ()=>Reflect.getPrototypeOf(t[0]),
                has: (t,e)=>ei(t).includes(e),
                ownKeys: t=>ei(t),
                set(t, e, n) {
                    const o = t._storage || (t._storage = r());
                    return t[e] = o[e] = n,
                    delete t._keys,
                    !0
                }
            })
        }
        function Ye(t, e, n, o) {
            const r = {
                _cacheable: !1,
                _proxy: t,
                _context: e,
                _subProxy: n,
                _stack: new Set,
                _descriptors: Xe(t, o),
                setContext: e=>Ye(t, e, n, o),
                override: r=>Ye(t.override(r), e, n, o)
            };
            return new Proxy(r,{
                deleteProperty: (e,n)=>(delete e[n],
                delete t[n],
                !0),
                get: (t,e,n)=>Ze(t, e, (()=>function(t, e, n) {
                    const {_proxy: o, _context: r, _subProxy: c, _descriptors: d} = t;
                    let f = o[e];
                    L(f) && d.isScriptable(e) && (f = function(t, e, n, o) {
                        const {_proxy: r, _context: c, _subProxy: l, _stack: h} = n;
                        if (h.has(t))
                            throw new Error("Recursion detected: " + Array.from(h).join("->") + "->" + t);
                        h.add(t),
                        e = e(c, l || o),
                        h.delete(t),
                        Ue(t, e) && (e = Ge(r._scopes, r, t, e));
                        return e
                    }(e, f, t, n));
                    l(f) && f.length && (f = function(t, e, n, o) {
                        const {_proxy: r, _context: c, _subProxy: l, _descriptors: d} = n;
                        if (T(c.index) && o(t))
                            e = e[c.index % e.length];
                        else if (h(e[0])) {
                            const n = e
                              , o = r._scopes.filter((s=>s !== n));
                            e = [];
                            for (const h of n) {
                                const n = Ge(o, r, t, h);
                                e.push(Ye(n, c, l && l[t], d))
                            }
                        }
                        return e
                    }(e, f, t, d.isIndexable));
                    Ue(e, f) && (f = Ye(f, r, c && c[e], d));
                    return f
                }(t, e, n))),
                getOwnPropertyDescriptor: (e,n)=>e._descriptors.allKeys ? Reflect.has(t, n) ? {
                    enumerable: !0,
                    configurable: !0
                } : void 0 : Reflect.getOwnPropertyDescriptor(t, n),
                getPrototypeOf: ()=>Reflect.getPrototypeOf(t),
                has: (e,n)=>Reflect.has(t, n),
                ownKeys: ()=>Reflect.ownKeys(t),
                set: (e,n,o)=>(t[n] = o,
                delete e[n],
                !0)
            })
        }
        function Xe(t, e={
            scriptable: !0,
            indexable: !0
        }) {
            const {_scriptable: n=e.scriptable, _indexable: o=e.indexable, _allKeys: r=e.allKeys} = t;
            return {
                allKeys: r,
                scriptable: n,
                indexable: o,
                isScriptable: L(n) ? n : ()=>n,
                isIndexable: L(o) ? o : ()=>o
            }
        }
        const $e = (t,e)=>t ? t + A(e) : e
          , Ue = (t,e)=>h(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);
        function Ze(t, e, n) {
            if (Object.prototype.hasOwnProperty.call(t, e))
                return t[e];
            const o = n();
            return t[e] = o,
            o
        }
        function qe(t, e, n) {
            return L(t) ? t(e, n) : t
        }
        const Ke = (t,e)=>!0 === t ? e : "string" == typeof t ? D(e, t) : void 0;
        function Je(t, e, n, o, r) {
            for (const c of e) {
                const e = Ke(n, c);
                if (e) {
                    t.add(e);
                    const c = qe(e._fallback, n, r);
                    if (T(c) && c !== n && c !== o)
                        return c
                } else if (!1 === e && T(o) && n !== o)
                    return null
            }
            return !1
        }
        function Ge(t, e, n, o) {
            const r = e._rootScopes
              , c = qe(e._fallback, n, o)
              , d = [...t, ...r]
              , f = new Set;
            f.add(o);
            let m = Qe(f, d, n, c || n, o);
            return null !== m && ((!T(c) || c === n || (m = Qe(f, d, c, m, o),
            null !== m)) && He(Array.from(f), [""], r, c, (()=>function(t, e, n) {
                const o = t._getTarget();
                e in o || (o[e] = {});
                const r = o[e];
                if (l(r) && h(n))
                    return n;
                return r
            }(e, n, o))))
        }
        function Qe(t, e, n, o, r) {
            for (; n; )
                n = Je(t, e, n, o, r);
            return n
        }
        function ti(t, e) {
            for (const n of e) {
                if (!n)
                    continue;
                const e = n[t];
                if (T(e))
                    return e
            }
        }
        function ei(t) {
            let e = t._keys;
            return e || (e = t._keys = function(t) {
                const e = new Set;
                for (const n of t)
                    for (const t of Object.keys(n).filter((t=>!t.startsWith("_"))))
                        e.add(t);
                return Array.from(e)
            }(t._scopes)),
            e
        }
        function ii(meta, data, t, e) {
            const {iScale: n} = meta
              , {key: o="r"} = this._parsing
              , r = new Array(e);
            let i, c, l, h;
            for (i = 0,
            c = e; i < c; ++i)
                l = i + t,
                h = data[l],
                r[i] = {
                    r: n.parse(D(h, o), l)
                };
            return r
        }
        const ni = Number.EPSILON || 1e-14
          , si = (t,i)=>i < t.length && !t[i].skip && t[i]
          , oi = t=>"x" === t ? "y" : "x";
        function ri(t, e, n, o) {
            const r = t.skip ? e : t
              , c = e
              , l = n.skip ? e : n
              , h = nt(c, r)
              , d = nt(l, c);
            let f = h / (h + d)
              , m = d / (h + d);
            f = isNaN(f) ? 0 : f,
            m = isNaN(m) ? 0 : m;
            const x = o * f
              , y = o * m;
            return {
                previous: {
                    x: c.x - x * (l.x - r.x),
                    y: c.y - x * (l.y - r.y)
                },
                next: {
                    x: c.x + y * (l.x - r.x),
                    y: c.y + y * (l.y - r.y)
                }
            }
        }
        function ai(t, e="x") {
            const n = oi(e)
              , o = t.length
              , r = Array(o).fill(0)
              , c = Array(o);
            let i, l, h, d = si(t, 0);
            for (i = 0; i < o; ++i)
                if (l = h,
                h = d,
                d = si(t, i + 1),
                h) {
                    if (d) {
                        const t = d[e] - h[e];
                        r[i] = 0 !== t ? (d[n] - h[n]) / t : 0
                    }
                    c[i] = l ? d ? X(r[i - 1]) !== X(r[i]) ? 0 : (r[i - 1] + r[i]) / 2 : r[i - 1] : r[i]
                }
            !function(t, e, n) {
                const o = t.length;
                let r, c, l, h, d, f = si(t, 0);
                for (let i = 0; i < o - 1; ++i)
                    d = f,
                    f = si(t, i + 1),
                    d && f && (K(e[i], 0, ni) ? n[i] = n[i + 1] = 0 : (r = n[i] / e[i],
                    c = n[i + 1] / e[i],
                    h = Math.pow(r, 2) + Math.pow(c, 2),
                    h <= 9 || (l = 3 / Math.sqrt(h),
                    n[i] = r * l * e[i],
                    n[i + 1] = c * l * e[i])))
            }(t, r, c),
            function(t, e, n="x") {
                const o = oi(n)
                  , r = t.length;
                let c, l, h, d = si(t, 0);
                for (let i = 0; i < r; ++i) {
                    if (l = h,
                    h = d,
                    d = si(t, i + 1),
                    !h)
                        continue;
                    const r = h[n]
                      , f = h[o];
                    l && (c = (r - l[n]) / 3,
                    h[`cp1${n}`] = r - c,
                    h[`cp1${o}`] = f - c * e[i]),
                    d && (c = (d[n] - r) / 3,
                    h[`cp2${n}`] = r + c,
                    h[`cp2${o}`] = f + c * e[i])
                }
            }(t, c, e)
        }
        function ci(t, e, n) {
            return Math.max(Math.min(t, n), e)
        }
        function hi(t, e, area, n, o) {
            let i, r, c, l;
            if (e.spanGaps && (t = t.filter((t=>!t.skip))),
            "monotone" === e.cubicInterpolationMode)
                ai(t, o);
            else {
                let o = n ? t[t.length - 1] : t[0];
                for (i = 0,
                r = t.length; i < r; ++i)
                    c = t[i],
                    l = ri(o, c, t[Math.min(i + 1, r - (n ? 0 : 1)) % r], e.tension),
                    c.cp1x = l.previous.x,
                    c.cp1y = l.previous.y,
                    c.cp2x = l.next.x,
                    c.cp2y = l.next.y,
                    o = c
            }
            e.capBezierPoints && function(t, area) {
                let i, e, n, o, r, c = we(t[0], area);
                for (i = 0,
                e = t.length; i < e; ++i)
                    r = o,
                    o = c,
                    c = i < e - 1 && we(t[i + 1], area),
                    o && (n = t[i],
                    r && (n.cp1x = ci(n.cp1x, area.left, area.right),
                    n.cp1y = ci(n.cp1y, area.top, area.bottom)),
                    c && (n.cp2x = ci(n.cp2x, area.left, area.right),
                    n.cp2y = ci(n.cp2y, area.top, area.bottom)))
            }(t, area)
        }
        function di() {
            return "undefined" != typeof window && "undefined" != typeof document
        }
        function ui(t) {
            let e = t.parentNode;
            return e && "[object ShadowRoot]" === e.toString() && (e = e.host),
            e
        }
        function fi(t, e, n) {
            let o;
            return "string" == typeof t ? (o = parseInt(t, 10),
            -1 !== t.indexOf("%") && (o = o / 100 * e.parentNode[n])) : o = t,
            o
        }
        const bi = element=>window.getComputedStyle(element, null);
        const gi = ["top", "right", "bottom", "left"];
        function pi(t, style, e) {
            const n = {};
            e = e ? "-" + e : "";
            for (let i = 0; i < 4; i++) {
                const o = gi[i];
                n[o] = parseFloat(t[style + "-" + o + e]) || 0
            }
            return n.width = n.left + n.right,
            n.height = n.top + n.bottom,
            n
        }
        const mi = (t,e,n)=>(t > 0 || e > 0) && (!n || !n.shadowRoot);
        function xi(t, e) {
            if ("native"in t)
                return t;
            const {canvas: canvas, currentDevicePixelRatio: n} = e
              , style = bi(canvas)
              , o = "border-box" === style.boxSizing
              , r = pi(style, "padding")
              , c = pi(style, "border", "width")
              , {x: l, y: h, box: d} = function(t, canvas) {
                const e = t.touches
                  , source = e && e.length ? e[0] : t
                  , {offsetX: n, offsetY: o} = source;
                let r, c, l = !1;
                if (mi(n, o, t.target))
                    r = n,
                    c = o;
                else {
                    const rect = canvas.getBoundingClientRect();
                    r = source.clientX - rect.left,
                    c = source.clientY - rect.top,
                    l = !0
                }
                return {
                    x: r,
                    y: c,
                    box: l
                }
            }(t, canvas)
              , f = r.left + (d && c.left)
              , m = r.top + (d && c.top);
            let {width: x, height: y} = e;
            return o && (x -= r.width + c.width,
            y -= r.height + c.height),
            {
                x: Math.round((l - f) / x * canvas.width / n),
                y: Math.round((h - m) / y * canvas.height / n)
            }
        }
        const yi = t=>Math.round(10 * t) / 10;
        function _i(canvas, t, e, n) {
            const style = bi(canvas)
              , o = pi(style, "margin")
              , r = fi(style.maxWidth, canvas, "clientWidth") || W
              , c = fi(style.maxHeight, canvas, "clientHeight") || W
              , l = function(canvas, t, e) {
                let n, o;
                if (void 0 === t || void 0 === e) {
                    const r = ui(canvas);
                    if (r) {
                        const rect = r.getBoundingClientRect()
                          , c = bi(r)
                          , l = pi(c, "border", "width")
                          , h = pi(c, "padding");
                        t = rect.width - h.width - l.width,
                        e = rect.height - h.height - l.height,
                        n = fi(c.maxWidth, r, "clientWidth"),
                        o = fi(c.maxHeight, r, "clientHeight")
                    } else
                        t = canvas.clientWidth,
                        e = canvas.clientHeight
                }
                return {
                    width: t,
                    height: e,
                    maxWidth: n || W,
                    maxHeight: o || W
                }
            }(canvas, t, e);
            let {width: h, height: d} = l;
            if ("content-box" === style.boxSizing) {
                const t = pi(style, "border", "width")
                  , e = pi(style, "padding");
                h -= e.width + t.width,
                d -= e.height + t.height
            }
            return h = Math.max(0, h - o.width),
            d = Math.max(0, n ? Math.floor(h / n) : d - o.height),
            h = yi(Math.min(h, r, l.maxWidth)),
            d = yi(Math.min(d, c, l.maxHeight)),
            h && !d && (d = yi(h / 2)),
            {
                width: h,
                height: d
            }
        }
        function vi(t, e, n) {
            const o = e || 1
              , r = Math.floor(t.height * o)
              , c = Math.floor(t.width * o);
            t.height = r / o,
            t.width = c / o;
            const canvas = t.canvas;
            return canvas.style && (n || !canvas.style.height && !canvas.style.width) && (canvas.style.height = `${t.height}px`,
            canvas.style.width = `${t.width}px`),
            (t.currentDevicePixelRatio !== o || canvas.height !== r || canvas.width !== c) && (t.currentDevicePixelRatio = o,
            canvas.height = r,
            canvas.width = c,
            t.ctx.setTransform(o, 0, 0, o, 0, 0),
            !0)
        }
        const Oi = function() {
            let t = !1;
            try {
                const e = {
                    get passive() {
                        return t = !0,
                        !1
                    }
                };
                window.addEventListener("test", null, e),
                window.removeEventListener("test", null, e)
            } catch (t) {}
            return t
        }();
        function wi(element, t) {
            const e = function(t, e) {
                return bi(t).getPropertyValue(e)
            }(element, t)
              , n = e && e.match(/^(\d+)(\.\d+)?px$/);
            return n ? +n[1] : void 0
        }
        function Mi(t, e, n, o) {
            return {
                x: t.x + n * (e.x - t.x),
                y: t.y + n * (e.y - t.y)
            }
        }
        function ji(t, e, n, o) {
            return {
                x: t.x + n * (e.x - t.x),
                y: "middle" === o ? n < .5 ? t.y : e.y : "after" === o ? n < 1 ? t.y : e.y : n > 0 ? e.y : t.y
            }
        }
        function ki(t, e, n, o) {
            const r = {
                x: t.cp2x,
                y: t.cp2y
            }
              , c = {
                x: e.cp1x,
                y: e.cp1y
            }
              , a = Mi(t, r, n)
              , b = Mi(r, c, n)
              , l = Mi(c, e, n)
              , h = Mi(a, b, n)
              , d = Mi(b, l, n);
            return Mi(h, d, n)
        }
        const Si = new Map;
        function Pi(t, e, n) {
            return function(t, e) {
                e = e || {};
                const n = t + JSON.stringify(e);
                let o = Si.get(n);
                return o || (o = new Intl.NumberFormat(t,e),
                Si.set(n, o)),
                o
            }(e, n).format(t)
        }
        const Ci = function(t, e) {
            return {
                x: n=>t + t + e - n,
                setWidth(t) {
                    e = t
                },
                textAlign: t=>"center" === t ? t : "right" === t ? "left" : "right",
                xPlus: (t,e)=>t - e,
                leftForLtr: (t,e)=>t - e
            }
        }
          , Di = function() {
            return {
                x: t=>t,
                setWidth(t) {},
                textAlign: t=>t,
                xPlus: (t,e)=>t + e,
                leftForLtr: (t,e)=>t
            }
        };
        function Ai(t, e, n) {
            return t ? Ci(e, n) : Di()
        }
        function Ti(t, e) {
            let style, n;
            "ltr" !== e && "rtl" !== e || (style = t.canvas.style,
            n = [style.getPropertyValue("direction"), style.getPropertyPriority("direction")],
            style.setProperty("direction", e, "important"),
            t.prevTextDirection = n)
        }
        function Li(t, e) {
            void 0 !== e && (delete t.prevTextDirection,
            t.canvas.style.setProperty("direction", e[0], e[1]))
        }
        function Ei(t) {
            return "angle" === t ? {
                between: at,
                compare: st,
                normalize: ot
            } : {
                between: ht,
                compare: (a,b)=>a - b,
                normalize: t=>t
            }
        }
        function Ri({start: t, end: e, count: n, loop: o, style: style}) {
            return {
                start: t % n,
                end: e % n,
                loop: o && (e - t + 1) % n == 0,
                style: style
            }
        }
        function Ii(t, e, n) {
            if (!n)
                return [t];
            const {property: o, start: r, end: c} = n
              , l = e.length
              , {compare: h, between: d, normalize: f} = Ei(o)
              , {start: m, end: x, loop: y, style: style} = function(t, e, n) {
                const {property: o, start: r, end: c} = n
                  , {between: l, normalize: h} = Ei(o)
                  , d = e.length;
                let i, f, {start: m, end: x, loop: y} = t;
                if (y) {
                    for (m += d,
                    x += d,
                    i = 0,
                    f = d; i < f && l(h(e[m % d][o]), r, c); ++i)
                        m--,
                        x--;
                    m %= d,
                    x %= d
                }
                return x < m && (x += d),
                {
                    start: m,
                    end: x,
                    loop: y,
                    style: t.style
                }
            }(t, e, n)
              , _ = [];
            let v, O, w, M = !1, j = null;
            const k = ()=>M || d(r, w, v) && 0 !== h(r, w)
              , S = ()=>!M || 0 === h(c, v) || d(c, w, v);
            for (let i = m, t = m; i <= x; ++i)
                O = e[i % l],
                O.skip || (v = f(O[o]),
                v !== w && (M = d(v, r, c),
                null === j && k() && (j = 0 === h(v, r) ? i : t),
                null !== j && S() && (_.push(Ri({
                    start: j,
                    end: i,
                    loop: y,
                    count: l,
                    style: style
                })),
                j = null),
                t = i,
                w = v));
            return null !== j && _.push(Ri({
                start: j,
                end: x,
                loop: y,
                count: l,
                style: style
            })),
            _
        }
        function zi(line, t) {
            const e = []
              , n = line.segments;
            for (let i = 0; i < n.length; i++) {
                const sub = Ii(n[i], line.points, t);
                sub.length && e.push(...sub)
            }
            return e
        }
        function Fi(line, t) {
            const e = line.points
              , n = line.options.spanGaps
              , o = e.length;
            if (!o)
                return [];
            const r = !!line._loop
              , {start: c, end: l} = function(t, e, n, o) {
                let r = 0
                  , c = e - 1;
                if (n && !o)
                    for (; r < e && !t[r].skip; )
                        r++;
                for (; r < e && t[r].skip; )
                    r++;
                for (r %= e,
                n && (c += r); c > r && t[c % e].skip; )
                    c--;
                return c %= e,
                {
                    start: r,
                    end: c
                }
            }(e, o, r, n);
            if (!0 === n)
                return Wi(line, [{
                    start: c,
                    end: l,
                    loop: r
                }], e, t);
            return Wi(line, function(t, e, n, o) {
                const r = t.length
                  , c = [];
                let l, h = e, d = t[e];
                for (l = e + 1; l <= n; ++l) {
                    const n = t[l % r];
                    n.skip || n.stop ? d.skip || (o = !1,
                    c.push({
                        start: e % r,
                        end: (l - 1) % r,
                        loop: o
                    }),
                    e = h = n.stop ? l : null) : (h = l,
                    d.skip && (e = l)),
                    d = n
                }
                return null !== h && c.push({
                    start: e % r,
                    end: h % r,
                    loop: o
                }),
                c
            }(e, c, l < c ? l + o : l, !!line._fullLoop && 0 === c && l === o - 1), e, t)
        }
        function Wi(line, t, e, n) {
            return n && n.setContext && e ? function(line, t, e, n) {
                const o = line._chart.getContext()
                  , r = Vi(line.options)
                  , {_datasetIndex: c, options: {spanGaps: l}} = line
                  , h = e.length
                  , d = [];
                let f = r
                  , m = t[0].start
                  , i = m;
                function x(s, t, n, o) {
                    const r = l ? -1 : 1;
                    if (s !== t) {
                        for (s += h; e[s % h].skip; )
                            s -= r;
                        for (; e[t % h].skip; )
                            t += r;
                        s % h != t % h && (d.push({
                            start: s % h,
                            end: t % h,
                            loop: n,
                            style: o
                        }),
                        f = o,
                        m = t % h)
                    }
                }
                for (const r of t) {
                    m = l ? m : r.start;
                    let style, t = e[m % h];
                    for (i = m + 1; i <= r.end; i++) {
                        const l = e[i % h];
                        style = Vi(n.setContext(Be(o, {
                            type: "segment",
                            p0: t,
                            p1: l,
                            p0DataIndex: (i - 1) % h,
                            p1DataIndex: i % h,
                            datasetIndex: c
                        }))),
                        Ni(style, f) && x(m, i - 1, r.loop, f),
                        t = l,
                        f = style
                    }
                    m < i - 1 && x(m, i - 1, r.loop, f)
                }
                return d
            }(line, t, e, n) : t
        }
        function Vi(t) {
            return {
                backgroundColor: t.backgroundColor,
                borderCapStyle: t.borderCapStyle,
                borderDash: t.borderDash,
                borderDashOffset: t.borderDashOffset,
                borderJoinStyle: t.borderJoinStyle,
                borderWidth: t.borderWidth,
                borderColor: t.borderColor
            }
        }
        function Ni(style, t) {
            return t && JSON.stringify(style) !== JSON.stringify(t)
        }
    },
    612: function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return f
        }
        )),
        n.d(e, "b", (function() {
            return xe
        }
        )),
        n.d(e, "c", (function() {
            return Y
        }
        )),
        n.d(e, "e", (function() {
            return rn
        }
        ));
        var o = n(459);
        n.d(e, "d", (function() {
            return o.Hb
        }
        ));
        var r = new class {
            constructor() {
                this._request = null,
                this._charts = new Map,
                this._running = !1,
                this._lastDate = void 0
            }
            _notify(t, e, n, o) {
                const r = e.listeners[o]
                  , c = e.duration;
                r.forEach((o=>o({
                    chart: t,
                    initial: e.initial,
                    numSteps: c,
                    currentStep: Math.min(n - e.start, c)
                })))
            }
            _refresh() {
                this._request || (this._running = !0,
                this._request = o.Vb.call(window, (()=>{
                    this._update(),
                    this._request = null,
                    this._running && this._refresh()
                }
                )))
            }
            _update(t=Date.now()) {
                let e = 0;
                this._charts.forEach(((n,o)=>{
                    if (!n.running || !n.items.length)
                        return;
                    const r = n.items;
                    let c, i = r.length - 1, l = !1;
                    for (; i >= 0; --i)
                        c = r[i],
                        c._active ? (c._total > n.duration && (n.duration = c._total),
                        c.tick(t),
                        l = !0) : (r[i] = r[r.length - 1],
                        r.pop());
                    l && (o.draw(),
                    this._notify(o, n, t, "progress")),
                    r.length || (n.running = !1,
                    this._notify(o, n, t, "complete"),
                    n.initial = !1),
                    e += r.length
                }
                )),
                this._lastDate = t,
                0 === e && (this._running = !1)
            }
            _getAnims(t) {
                const e = this._charts;
                let n = e.get(t);
                return n || (n = {
                    running: !1,
                    initial: !0,
                    items: [],
                    listeners: {
                        complete: [],
                        progress: []
                    }
                },
                e.set(t, n)),
                n
            }
            listen(t, e, n) {
                this._getAnims(t).listeners[e].push(n)
            }
            add(t, e) {
                e && e.length && this._getAnims(t).items.push(...e)
            }
            has(t) {
                return this._getAnims(t).items.length > 0
            }
            start(t) {
                const e = this._charts.get(t);
                e && (e.running = !0,
                e.start = Date.now(),
                e.duration = e.items.reduce(((t,e)=>Math.max(t, e._duration)), 0),
                this._refresh())
            }
            running(t) {
                if (!this._running)
                    return !1;
                const e = this._charts.get(t);
                return !!(e && e.running && e.items.length)
            }
            stop(t) {
                const e = this._charts.get(t);
                if (!e || !e.items.length)
                    return;
                const n = e.items;
                let i = n.length - 1;
                for (; i >= 0; --i)
                    n[i].cancel();
                e.items = [],
                this._notify(t, e, Date.now(), "complete")
            }
            remove(t) {
                return this._charts.delete(t)
            }
        }
        ;
        const c = "transparent"
          , l = {
            boolean: (t,e,n)=>n > .5 ? e : t,
            color(t, e, n) {
                const r = Object(o.Gb)(t || c)
                  , l = r.valid && Object(o.Gb)(e || c);
                return l && l.valid ? l.mix(r, n).hexString() : e
            },
            number: (t,e,n)=>t + (e - t) * n
        };
        class h {
            constructor(t, e, n, r) {
                const c = e[n];
                r = Object(o.C)([t.to, r, c, t.from]);
                const h = Object(o.C)([t.from, c, r]);
                this._active = !0,
                this._fn = t.fn || l[t.type || typeof h],
                this._easing = o.Ib[t.easing] || o.Ib.linear,
                this._start = Math.floor(Date.now() + (t.delay || 0)),
                this._duration = this._total = Math.floor(t.duration),
                this._loop = !!t.loop,
                this._target = e,
                this._prop = n,
                this._from = h,
                this._to = r,
                this._promises = void 0
            }
            active() {
                return this._active
            }
            update(t, e, n) {
                if (this._active) {
                    this._notify(!1);
                    const r = this._target[this._prop]
                      , c = n - this._start
                      , l = this._duration - c;
                    this._start = n,
                    this._duration = Math.floor(Math.max(l, t.duration)),
                    this._total += c,
                    this._loop = !!t.loop,
                    this._to = Object(o.C)([t.to, e, r, t.from]),
                    this._from = Object(o.C)([t.from, r, e])
                }
            }
            cancel() {
                this._active && (this.tick(Date.now()),
                this._active = !1,
                this._notify(!1))
            }
            tick(t) {
                const e = t - this._start
                  , n = this._duration
                  , o = this._prop
                  , r = this._from
                  , c = this._loop
                  , l = this._to;
                let h;
                if (this._active = r !== l && (c || e < n),
                !this._active)
                    return this._target[o] = l,
                    void this._notify(!0);
                e < 0 ? this._target[o] = r : (h = e / n % 2,
                h = c && h > 1 ? 2 - h : h,
                h = this._easing(Math.min(1, Math.max(0, h))),
                this._target[o] = this._fn(r, l, h))
            }
            wait() {
                const t = this._promises || (this._promises = []);
                return new Promise(((e,n)=>{
                    t.push({
                        res: e,
                        rej: n
                    })
                }
                ))
            }
            _notify(t) {
                const e = t ? "res" : "rej"
                  , n = this._promises || [];
                for (let i = 0; i < n.length; i++)
                    n[i][e]()
            }
        }
        o.Hb.set("animation", {
            delay: void 0,
            duration: 1e3,
            easing: "easeOutQuart",
            fn: void 0,
            from: void 0,
            loop: void 0,
            to: void 0,
            type: void 0
        });
        const d = Object.keys(o.Hb.animation);
        o.Hb.describe("animation", {
            _fallback: !1,
            _indexable: !1,
            _scriptable: t=>"onProgress" !== t && "onComplete" !== t && "fn" !== t
        }),
        o.Hb.set("animations", {
            colors: {
                type: "color",
                properties: ["color", "borderColor", "backgroundColor"]
            },
            numbers: {
                type: "number",
                properties: ["x", "y", "borderWidth", "radius", "tension"]
            }
        }),
        o.Hb.describe("animations", {
            _fallback: "animation"
        }),
        o.Hb.set("transitions", {
            active: {
                animation: {
                    duration: 400
                }
            },
            resize: {
                animation: {
                    duration: 0
                }
            },
            show: {
                animations: {
                    colors: {
                        from: "transparent"
                    },
                    visible: {
                        type: "boolean",
                        duration: 0
                    }
                }
            },
            hide: {
                animations: {
                    colors: {
                        to: "transparent"
                    },
                    visible: {
                        type: "boolean",
                        easing: "linear",
                        fn: t=>0 | t
                    }
                }
            }
        });
        class f {
            constructor(t, e) {
                this._chart = t,
                this._properties = new Map,
                this.configure(e)
            }
            configure(t) {
                if (!Object(o.Mb)(t))
                    return;
                const e = this._properties;
                Object.getOwnPropertyNames(t).forEach((n=>{
                    const r = t[n];
                    if (!Object(o.Mb)(r))
                        return;
                    const c = {};
                    for (const option of d)
                        c[option] = r[option];
                    (Object(o.Cb)(r.properties) && r.properties || [n]).forEach((t=>{
                        t !== n && e.has(t) || e.set(t, c)
                    }
                    ))
                }
                ))
            }
            _animateOptions(t, e) {
                const n = e.options
                  , o = function(t, e) {
                    if (!e)
                        return;
                    let n = t.options;
                    if (!n)
                        return void (t.options = e);
                    n.$shared && (t.options = n = Object.assign({}, n, {
                        $shared: !1,
                        $animations: {}
                    }));
                    return n
                }(t, n);
                if (!o)
                    return [];
                const r = this._createAnimations(o, n);
                return n.$shared && function(t, e) {
                    const n = []
                      , o = Object.keys(e);
                    for (let i = 0; i < o.length; i++) {
                        const e = t[o[i]];
                        e && e.active() && n.push(e.wait())
                    }
                    return Promise.all(n)
                }(t.options.$animations, n).then((()=>{
                    t.options = n
                }
                ), (()=>{}
                )),
                r
            }
            _createAnimations(t, e) {
                const n = this._properties
                  , o = []
                  , r = t.$animations || (t.$animations = {})
                  , c = Object.keys(e)
                  , l = Date.now();
                let i;
                for (i = c.length - 1; i >= 0; --i) {
                    const d = c[i];
                    if ("$" === d.charAt(0))
                        continue;
                    if ("options" === d) {
                        o.push(...this._animateOptions(t, e));
                        continue
                    }
                    const f = e[d];
                    let m = r[d];
                    const x = n.get(d);
                    if (m) {
                        if (x && m.active()) {
                            m.update(x, f, l);
                            continue
                        }
                        m.cancel()
                    }
                    x && x.duration ? (r[d] = m = new h(x,t,d,f),
                    o.push(m)) : t[d] = f
                }
                return o
            }
            update(t, e) {
                if (0 === this._properties.size)
                    return void Object.assign(t, e);
                const n = this._createAnimations(t, e);
                return n.length ? (r.add(this._chart, n),
                !0) : void 0
            }
        }
        function m(t, e) {
            const n = t && t.options || {}
              , o = n.reverse
              , r = void 0 === n.min ? e : 0
              , c = void 0 === n.max ? e : 0;
            return {
                start: o ? c : r,
                end: o ? r : c
            }
        }
        function x(t, e) {
            const n = []
              , o = t._getSortedDatasetMetas(e);
            let i, r;
            for (i = 0,
            r = o.length; i < r; ++i)
                n.push(o[i].index);
            return n
        }
        function y(t, e, n, r={}) {
            const c = t.keys
              , l = "single" === r.mode;
            let i, h, d, f;
            if (null !== e) {
                for (i = 0,
                h = c.length; i < h; ++i) {
                    if (d = +c[i],
                    d === n) {
                        if (r.all)
                            continue;
                        break
                    }
                    f = t.values[d],
                    Object(o.Kb)(f) && (l || 0 === e || Object(o.Wb)(e) === Object(o.Wb)(f)) && (e += f)
                }
                return e
            }
        }
        function _(t, meta) {
            const e = t && t.options.stacked;
            return e || void 0 === e && void 0 !== meta.stack
        }
        function v(t, e, n) {
            const o = t[e] || (t[e] = {});
            return o[n] || (o[n] = {})
        }
        function O(t, e, n, o) {
            for (const meta of e.getMatchingVisibleMetas(o).reverse()) {
                const e = t[meta.index];
                if (n && e > 0 || !n && e < 0)
                    return meta.index
            }
            return null
        }
        function w(t, e) {
            const {chart: n, _cachedMeta: meta} = t
              , o = n._stacks || (n._stacks = {})
              , {iScale: r, vScale: c, index: l} = meta
              , h = r.axis
              , d = c.axis
              , f = function(t, e, meta) {
                return `${t.id}.${e.id}.${meta.stack || meta.type}`
            }(r, c, meta)
              , m = e.length;
            let x;
            for (let i = 0; i < m; ++i) {
                const t = e[i]
                  , {[h]: n, [d]: r} = t;
                x = (t._stacks || (t._stacks = {}))[d] = v(o, f, n),
                x[l] = r,
                x._top = O(x, c, !0, meta.type),
                x._bottom = O(x, c, !1, meta.type)
            }
        }
        function M(t, e) {
            const n = t.scales;
            return Object.keys(n).filter((t=>n[t].axis === e)).shift()
        }
        function j(meta, t) {
            const e = meta.controller.index
              , n = meta.vScale && meta.vScale.axis;
            if (n) {
                t = t || meta._parsed;
                for (const o of t) {
                    const t = o._stacks;
                    if (!t || void 0 === t[n] || void 0 === t[n][e])
                        return;
                    delete t[n][e]
                }
            }
        }
        const k = t=>"reset" === t || "none" === t
          , S = (t,e)=>e ? t : Object.assign({}, t);
        class P {
            constructor(t, e) {
                this.chart = t,
                this._ctx = t.ctx,
                this.index = e,
                this._cachedDataOpts = {},
                this._cachedMeta = this.getMeta(),
                this._type = this._cachedMeta.type,
                this.options = void 0,
                this._parsing = !1,
                this._data = void 0,
                this._objectData = void 0,
                this._sharedOptions = void 0,
                this._drawStart = void 0,
                this._drawCount = void 0,
                this.enableOptionSharing = !1,
                this.supportsDecimation = !1,
                this.$context = void 0,
                this._syncList = [],
                this.initialize()
            }
            initialize() {
                const meta = this._cachedMeta;
                this.configure(),
                this.linkScales(),
                meta._stacked = _(meta.vScale, meta),
                this.addElements()
            }
            updateIndex(t) {
                this.index !== t && j(this._cachedMeta),
                this.index = t
            }
            linkScales() {
                const t = this.chart
                  , meta = this._cachedMeta
                  , e = this.getDataset()
                  , n = (t,e,n,o)=>"x" === t ? e : "r" === t ? o : n
                  , r = meta.xAxisID = Object(o.Zb)(e.xAxisID, M(t, "x"))
                  , c = meta.yAxisID = Object(o.Zb)(e.yAxisID, M(t, "y"))
                  , l = meta.rAxisID = Object(o.Zb)(e.rAxisID, M(t, "r"))
                  , h = meta.indexAxis
                  , d = meta.iAxisID = n(h, r, c, l)
                  , f = meta.vAxisID = n(h, c, r, l);
                meta.xScale = this.getScaleForId(r),
                meta.yScale = this.getScaleForId(c),
                meta.rScale = this.getScaleForId(l),
                meta.iScale = this.getScaleForId(d),
                meta.vScale = this.getScaleForId(f)
            }
            getDataset() {
                return this.chart.data.datasets[this.index]
            }
            getMeta() {
                return this.chart.getDatasetMeta(this.index)
            }
            getScaleForId(t) {
                return this.chart.scales[t]
            }
            _getOtherScale(t) {
                const meta = this._cachedMeta;
                return t === meta.iScale ? meta.vScale : meta.iScale
            }
            reset() {
                this._update("reset")
            }
            _destroy() {
                const meta = this._cachedMeta;
                this._data && Object(o.Yb)(this._data, this),
                meta._stacked && j(meta)
            }
            _dataCheck() {
                const t = this.getDataset()
                  , data = t.data || (t.data = [])
                  , e = this._data;
                if (Object(o.Mb)(data))
                    this._data = function(data) {
                        const t = Object.keys(data)
                          , e = new Array(t.length);
                        let i, n, o;
                        for (i = 0,
                        n = t.length; i < n; ++i)
                            o = t[i],
                            e[i] = {
                                x: o,
                                y: data[o]
                            };
                        return e
                    }(data);
                else if (e !== data) {
                    if (e) {
                        Object(o.Yb)(e, this);
                        const meta = this._cachedMeta;
                        j(meta),
                        meta._parsed = []
                    }
                    data && Object.isExtensible(data) && Object(o.Pb)(data, this),
                    this._syncList = [],
                    this._data = data
                }
            }
            addElements() {
                const meta = this._cachedMeta;
                this._dataCheck(),
                this.datasetElementType && (meta.dataset = new this.datasetElementType)
            }
            buildOrUpdateElements(t) {
                const meta = this._cachedMeta
                  , e = this.getDataset();
                let n = !1;
                this._dataCheck();
                const o = meta._stacked;
                meta._stacked = _(meta.vScale, meta),
                meta.stack !== e.stack && (n = !0,
                j(meta),
                meta.stack = e.stack),
                this._resyncElements(t),
                (n || o !== meta._stacked) && w(this, meta._parsed)
            }
            configure() {
                const t = this.chart.config
                  , e = t.datasetScopeKeys(this._type)
                  , n = t.getOptionScopes(this.getDataset(), e, !0);
                this.options = t.createResolver(n, this.getContext()),
                this._parsing = this.options.parsing,
                this._cachedDataOpts = {}
            }
            parse(t, e) {
                const {_cachedMeta: meta, _data: data} = this
                  , {iScale: n, _stacked: r} = meta
                  , c = n.axis;
                let i, l, h, d = 0 === t && e === data.length || meta._sorted, f = t > 0 && meta._parsed[t - 1];
                if (!1 === this._parsing)
                    meta._parsed = data,
                    meta._sorted = !0,
                    h = data;
                else {
                    h = Object(o.Cb)(data[t]) ? this.parseArrayData(meta, data, t, e) : Object(o.Mb)(data[t]) ? this.parseObjectData(meta, data, t, e) : this.parsePrimitiveData(meta, data, t, e);
                    const n = ()=>null === l[c] || f && l[c] < f[c];
                    for (i = 0; i < e; ++i)
                        meta._parsed[i + t] = l = h[i],
                        d && (n() && (d = !1),
                        f = l);
                    meta._sorted = d
                }
                r && w(this, h)
            }
            parsePrimitiveData(meta, data, t, e) {
                const {iScale: n, vScale: o} = meta
                  , r = n.axis
                  , c = o.axis
                  , l = n.getLabels()
                  , h = n === o
                  , d = new Array(e);
                let i, f, m;
                for (i = 0,
                f = e; i < f; ++i)
                    m = i + t,
                    d[i] = {
                        [r]: h || n.parse(l[m], m),
                        [c]: o.parse(data[m], m)
                    };
                return d
            }
            parseArrayData(meta, data, t, e) {
                const {xScale: n, yScale: o} = meta
                  , r = new Array(e);
                let i, c, l, h;
                for (i = 0,
                c = e; i < c; ++i)
                    l = i + t,
                    h = data[l],
                    r[i] = {
                        x: n.parse(h[0], l),
                        y: o.parse(h[1], l)
                    };
                return r
            }
            parseObjectData(meta, data, t, e) {
                const {xScale: n, yScale: r} = meta
                  , {xAxisKey: c="x", yAxisKey: l="y"} = this._parsing
                  , h = new Array(e);
                let i, d, f, m;
                for (i = 0,
                d = e; i < d; ++i)
                    f = i + t,
                    m = data[f],
                    h[i] = {
                        x: n.parse(Object(o.Jb)(m, c), f),
                        y: r.parse(Object(o.Jb)(m, l), f)
                    };
                return h
            }
            getParsed(t) {
                return this._cachedMeta._parsed[t]
            }
            getDataElement(t) {
                return this._cachedMeta.data[t]
            }
            applyStack(t, e, n) {
                const o = this.chart
                  , meta = this._cachedMeta
                  , r = e[t.axis];
                return y({
                    keys: x(o, !0),
                    values: e._stacks[t.axis]
                }, r, meta.index, {
                    mode: n
                })
            }
            updateRangeFromParsed(t, e, n, o) {
                const r = n[e.axis];
                let c = null === r ? NaN : r;
                const l = o && n._stacks[e.axis];
                o && l && (o.values = l,
                c = y(o, r, this._cachedMeta.index)),
                t.min = Math.min(t.min, c),
                t.max = Math.max(t.max, c)
            }
            getMinMax(t, e) {
                const meta = this._cachedMeta
                  , n = meta._parsed
                  , r = meta._sorted && t === meta.iScale
                  , c = n.length
                  , l = this._getOtherScale(t)
                  , h = ((t,meta,e)=>t && !meta.hidden && meta._stacked && {
                    keys: x(e, !0),
                    values: null
                })(e, meta, this.chart)
                  , d = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                }
                  , {min: f, max: m} = function(t) {
                    const {min: e, max: n, minDefined: o, maxDefined: r} = t.getUserBounds();
                    return {
                        min: o ? e : Number.NEGATIVE_INFINITY,
                        max: r ? n : Number.POSITIVE_INFINITY
                    }
                }(l);
                let i, y;
                function _() {
                    y = n[i];
                    const e = y[l.axis];
                    return !Object(o.Kb)(y[t.axis]) || f > e || m < e
                }
                for (i = 0; i < c && (_() || (this.updateRangeFromParsed(d, t, y, h),
                !r)); ++i)
                    ;
                if (r)
                    for (i = c - 1; i >= 0; --i)
                        if (!_()) {
                            this.updateRangeFromParsed(d, t, y, h);
                            break
                        }
                return d
            }
            getAllParsedValues(t) {
                const e = this._cachedMeta._parsed
                  , n = [];
                let i, r, c;
                for (i = 0,
                r = e.length; i < r; ++i)
                    c = e[i][t.axis],
                    Object(o.Kb)(c) && n.push(c);
                return n
            }
            getMaxOverflow() {
                return !1
            }
            getLabelAndValue(t) {
                const meta = this._cachedMeta
                  , e = meta.iScale
                  , n = meta.vScale
                  , o = this.getParsed(t);
                return {
                    label: e ? "" + e.getLabelForValue(o[e.axis]) : "",
                    value: n ? "" + n.getLabelForValue(o[n.axis]) : ""
                }
            }
            _update(t) {
                const meta = this._cachedMeta;
                this.update(t || "default"),
                meta._clip = function(t) {
                    let e, n, b, r;
                    return Object(o.Mb)(t) ? (e = t.top,
                    n = t.right,
                    b = t.bottom,
                    r = t.left) : e = n = b = r = t,
                    {
                        top: e,
                        right: n,
                        bottom: b,
                        left: r,
                        disabled: !1 === t
                    }
                }(Object(o.Zb)(this.options.clip, function(t, e, n) {
                    if (!1 === n)
                        return !1;
                    const o = m(t, n)
                      , r = m(e, n);
                    return {
                        top: r.end,
                        right: o.end,
                        bottom: r.start,
                        left: o.start
                    }
                }(meta.xScale, meta.yScale, this.getMaxOverflow())))
            }
            update(t) {}
            draw() {
                const t = this._ctx
                  , e = this.chart
                  , meta = this._cachedMeta
                  , n = meta.data || []
                  , area = e.chartArea
                  , o = []
                  , r = this._drawStart || 0
                  , c = this._drawCount || n.length - r
                  , l = this.options.drawActiveElementsOnTop;
                let i;
                for (meta.dataset && meta.dataset.draw(t, area, r, c),
                i = r; i < r + c; ++i) {
                    const element = n[i];
                    element.hidden || (element.active && l ? o.push(element) : element.draw(t, area))
                }
                for (i = 0; i < o.length; ++i)
                    o[i].draw(t, area)
            }
            getStyle(t, e) {
                const n = e ? "active" : "default";
                return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(t || 0, n)
            }
            getContext(t, e, n) {
                const r = this.getDataset();
                let c;
                if (t >= 0 && t < this._cachedMeta.data.length) {
                    const element = this._cachedMeta.data[t];
                    c = element.$context || (element.$context = function(t, e, element) {
                        return Object(o.Lb)(t, {
                            active: !1,
                            dataIndex: e,
                            parsed: void 0,
                            raw: void 0,
                            element: element,
                            index: e,
                            mode: "default",
                            type: "data"
                        })
                    }(this.getContext(), t, element)),
                    c.parsed = this.getParsed(t),
                    c.raw = r.data[t],
                    c.index = c.dataIndex = t
                } else
                    c = this.$context || (this.$context = function(t, e) {
                        return Object(o.Lb)(t, {
                            active: !1,
                            dataset: void 0,
                            datasetIndex: e,
                            index: e,
                            mode: "default",
                            type: "dataset"
                        })
                    }(this.chart.getContext(), this.index)),
                    c.dataset = r,
                    c.index = c.datasetIndex = this.index;
                return c.active = !!e,
                c.mode = n,
                c
            }
            resolveDatasetElementOptions(t) {
                return this._resolveElementOptions(this.datasetElementType.id, t)
            }
            resolveDataElementOptions(t, e) {
                return this._resolveElementOptions(this.dataElementType.id, e, t)
            }
            _resolveElementOptions(t, e="default", n) {
                const r = "active" === e
                  , c = this._cachedDataOpts
                  , l = t + "-" + e
                  , h = c[l]
                  , d = this.enableOptionSharing && Object(o.Nb)(n);
                if (h)
                    return S(h, d);
                const f = this.chart.config
                  , m = f.datasetElementScopeKeys(this._type, t)
                  , x = r ? [`${t}Hover`, "hover", t, ""] : [t, ""]
                  , y = f.getOptionScopes(this.getDataset(), m)
                  , _ = Object.keys(o.Hb.elements[t])
                  , v = f.resolveNamedOptions(y, _, (()=>this.getContext(n, r)), x);
                return v.$shared && (v.$shared = d,
                c[l] = Object.freeze(S(v, d))),
                v
            }
            _resolveAnimations(t, e, n) {
                const o = this.chart
                  , r = this._cachedDataOpts
                  , c = `animation-${e}`
                  , l = r[c];
                if (l)
                    return l;
                let h;
                if (!1 !== o.options.animation) {
                    const o = this.chart.config
                      , r = o.datasetAnimationScopeKeys(this._type, e)
                      , c = o.getOptionScopes(this.getDataset(), r);
                    h = o.createResolver(c, this.getContext(t, n, e))
                }
                const d = new f(o,h && h.animations);
                return h && h._cacheable && (r[c] = Object.freeze(d)),
                d
            }
            getSharedOptions(t) {
                if (t.$shared)
                    return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
            }
            includeOptions(t, e) {
                return !e || k(t) || this.chart._animationsDisabled
            }
            _getSharedOptions(t, e) {
                const n = this.resolveDataElementOptions(t, e)
                  , o = this._sharedOptions
                  , r = this.getSharedOptions(n)
                  , c = this.includeOptions(e, r) || r !== o;
                return this.updateSharedOptions(r, e, n),
                {
                    sharedOptions: r,
                    includeOptions: c
                }
            }
            updateElement(element, t, e, n) {
                k(n) ? Object.assign(element, e) : this._resolveAnimations(t, n).update(element, e)
            }
            updateSharedOptions(t, e, n) {
                t && !k(e) && this._resolveAnimations(void 0, e).update(t, n)
            }
            _setStyle(element, t, e, n) {
                element.active = n;
                const o = this.getStyle(t, n);
                this._resolveAnimations(t, e, n).update(element, {
                    options: !n && this.getSharedOptions(o) || o
                })
            }
            removeHoverStyle(element, t, e) {
                this._setStyle(element, e, "active", !1)
            }
            setHoverStyle(element, t, e) {
                this._setStyle(element, e, "active", !0)
            }
            _removeDatasetHoverStyle() {
                const element = this._cachedMeta.dataset;
                element && this._setStyle(element, void 0, "active", !1)
            }
            _setDatasetHoverStyle() {
                const element = this._cachedMeta.dataset;
                element && this._setStyle(element, void 0, "active", !0)
            }
            _resyncElements(t) {
                const data = this._data
                  , e = this._cachedMeta.data;
                for (const [t,e,n] of this._syncList)
                    this[t](e, n);
                this._syncList = [];
                const n = e.length
                  , o = data.length
                  , r = Math.min(o, n);
                r && this.parse(0, r),
                o > n ? this._insertElements(n, o - n, t) : o < n && this._removeElements(o, n - o)
            }
            _insertElements(t, e, n=!0) {
                const meta = this._cachedMeta
                  , data = meta.data
                  , o = t + e;
                let i;
                const r = t=>{
                    for (t.length += e,
                    i = t.length - 1; i >= o; i--)
                        t[i] = t[i - e]
                }
                ;
                for (r(data),
                i = t; i < o; ++i)
                    data[i] = new this.dataElementType;
                this._parsing && r(meta._parsed),
                this.parse(t, e),
                n && this.updateElements(data, t, e, "reset")
            }
            updateElements(element, t, e, n) {}
            _removeElements(t, e) {
                const meta = this._cachedMeta;
                if (this._parsing) {
                    const n = meta._parsed.splice(t, e);
                    meta._stacked && j(meta, n)
                }
                meta.data.splice(t, e)
            }
            _sync(t) {
                if (this._parsing)
                    this._syncList.push(t);
                else {
                    const [e,n,o] = t;
                    this[e](n, o)
                }
                this.chart._dataChanges.push([this.index, ...t])
            }
            _onDataPush() {
                const t = arguments.length;
                this._sync(["_insertElements", this.getDataset().data.length - t, t])
            }
            _onDataPop() {
                this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
            }
            _onDataShift() {
                this._sync(["_removeElements", 0, 1])
            }
            _onDataSplice(t, e) {
                e && this._sync(["_removeElements", t, e]);
                const n = arguments.length - 2;
                n && this._sync(["_insertElements", t, n])
            }
            _onDataUnshift() {
                this._sync(["_insertElements", 0, arguments.length])
            }
        }
        function C(meta) {
            const t = meta.iScale
              , e = function(t, e) {
                if (!t._cache.$bar) {
                    const n = t.getMatchingVisibleMetas(e);
                    let r = [];
                    for (let i = 0, e = n.length; i < e; i++)
                        r = r.concat(n[i].controller.getAllParsedValues(t));
                    t._cache.$bar = Object(o.B)(r.sort(((a,b)=>a - b)))
                }
                return t._cache.$bar
            }(t, meta.type);
            let i, n, r, c, l = t._length;
            const h = ()=>{
                32767 !== r && -32768 !== r && (Object(o.Nb)(c) && (l = Math.min(l, Math.abs(r - c) || l)),
                c = r)
            }
            ;
            for (i = 0,
            n = e.length; i < n; ++i)
                r = t.getPixelForValue(e[i]),
                h();
            for (c = void 0,
            i = 0,
            n = t.ticks.length; i < n; ++i)
                r = t.getPixelForTick(i),
                h();
            return l
        }
        function D(t, e, n, i) {
            return Object(o.Cb)(t) ? function(t, e, n, i) {
                const o = n.parse(t[0], i)
                  , r = n.parse(t[1], i)
                  , c = Math.min(o, r)
                  , l = Math.max(o, r);
                let h = c
                  , d = l;
                Math.abs(c) > Math.abs(l) && (h = l,
                d = c),
                e[n.axis] = d,
                e._custom = {
                    barStart: h,
                    barEnd: d,
                    start: o,
                    end: r,
                    min: c,
                    max: l
                }
            }(t, e, n, i) : e[n.axis] = n.parse(t, i),
            e
        }
        function A(meta, data, t, e) {
            const n = meta.iScale
              , o = meta.vScale
              , r = n.getLabels()
              , c = n === o
              , l = [];
            let i, h, d, f;
            for (i = t,
            h = t + e; i < h; ++i)
                f = data[i],
                d = {},
                d[n.axis] = c || n.parse(r[i], i),
                l.push(D(f, d, o, i));
            return l
        }
        function T(t) {
            return t && void 0 !== t.barStart && void 0 !== t.barEnd
        }
        function L(t, e, n, o) {
            let r = e.borderSkipped;
            const c = {};
            if (!r)
                return void (t.borderSkipped = c);
            if (!0 === r)
                return void (t.borderSkipped = {
                    top: !0,
                    right: !0,
                    bottom: !0,
                    left: !0
                });
            const {start: l, end: h, reverse: d, top: f, bottom: m} = function(t) {
                let e, n, o, r, c;
                return t.horizontal ? (e = t.base > t.x,
                n = "left",
                o = "right") : (e = t.base < t.y,
                n = "bottom",
                o = "top"),
                e ? (r = "end",
                c = "start") : (r = "start",
                c = "end"),
                {
                    start: n,
                    end: o,
                    reverse: e,
                    top: r,
                    bottom: c
                }
            }(t);
            "middle" === r && n && (t.enableBorderRadius = !0,
            (n._top || 0) === o ? r = f : (n._bottom || 0) === o ? r = m : (c[E(m, l, h, d)] = !0,
            r = f)),
            c[E(r, l, h, d)] = !0,
            t.borderSkipped = c
        }
        function E(t, a, b, e) {
            var n, o, r;
            return e ? (r = b,
            t = R(t = (n = t) === (o = a) ? r : n === r ? o : n, b, a)) : t = R(t, a, b),
            t
        }
        function R(t, e, n) {
            return "start" === t ? e : "end" === t ? n : t
        }
        function I(t, {inflateAmount: e}, n) {
            t.inflateAmount = "auto" === e ? 1 === n ? .33 : 0 : e
        }
        P.defaults = {},
        P.prototype.datasetElementType = null,
        P.prototype.dataElementType = null;
        class z extends P {
            parsePrimitiveData(meta, data, t, e) {
                return A(meta, data, t, e)
            }
            parseArrayData(meta, data, t, e) {
                return A(meta, data, t, e)
            }
            parseObjectData(meta, data, t, e) {
                const {iScale: n, vScale: r} = meta
                  , {xAxisKey: c="x", yAxisKey: l="y"} = this._parsing
                  , h = "x" === n.axis ? c : l
                  , d = "x" === r.axis ? c : l
                  , f = [];
                let i, m, x, y;
                for (i = t,
                m = t + e; i < m; ++i)
                    y = data[i],
                    x = {},
                    x[n.axis] = n.parse(Object(o.Jb)(y, h), i),
                    f.push(D(Object(o.Jb)(y, d), x, r, i));
                return f
            }
            updateRangeFromParsed(t, e, n, o) {
                super.updateRangeFromParsed(t, e, n, o);
                const r = n._custom;
                r && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, r.min),
                t.max = Math.max(t.max, r.max))
            }
            getMaxOverflow() {
                return 0
            }
            getLabelAndValue(t) {
                const meta = this._cachedMeta
                  , {iScale: e, vScale: n} = meta
                  , o = this.getParsed(t)
                  , r = o._custom
                  , c = T(r) ? "[" + r.start + ", " + r.end + "]" : "" + n.getLabelForValue(o[n.axis]);
                return {
                    label: "" + e.getLabelForValue(o[e.axis]),
                    value: c
                }
            }
            initialize() {
                this.enableOptionSharing = !0,
                super.initialize();
                this._cachedMeta.stack = this.getDataset().stack
            }
            update(t) {
                const meta = this._cachedMeta;
                this.updateElements(meta.data, 0, meta.data.length, t)
            }
            updateElements(t, e, n, r) {
                const c = "reset" === r
                  , {index: l, _cachedMeta: {vScale: h}} = this
                  , base = h.getBasePixel()
                  , d = h.isHorizontal()
                  , f = this._getRuler()
                  , {sharedOptions: m, includeOptions: x} = this._getSharedOptions(e, r);
                for (let i = e; i < e + n; i++) {
                    const e = this.getParsed(i)
                      , n = c || Object(o.Ob)(e[h.axis]) ? {
                        base: base,
                        head: base
                    } : this._calculateBarValuePixels(i)
                      , y = this._calculateBarIndexPixels(i, f)
                      , _ = (e._stacks || {})[h.axis]
                      , v = {
                        horizontal: d,
                        base: n.base,
                        enableBorderRadius: !_ || T(e._custom) || l === _._top || l === _._bottom,
                        x: d ? n.head : y.center,
                        y: d ? y.center : n.head,
                        height: d ? y.size : Math.abs(n.size),
                        width: d ? Math.abs(n.size) : y.size
                    };
                    x && (v.options = m || this.resolveDataElementOptions(i, t[i].active ? "active" : r));
                    const O = v.options || t[i].options;
                    L(v, O, _, l),
                    I(v, O, f.ratio),
                    this.updateElement(t[i], i, v, r)
                }
            }
            _getStacks(t, e) {
                const {iScale: n} = this._cachedMeta
                  , r = n.getMatchingVisibleMetas(this._type).filter((meta=>meta.controller.options.grouped))
                  , c = n.options.stacked
                  , l = []
                  , h = meta=>{
                    const t = meta.controller.getParsed(e)
                      , n = t && t[meta.vScale.axis];
                    if (Object(o.Ob)(n) || isNaN(n))
                        return !0
                }
                ;
                for (const meta of r)
                    if ((void 0 === e || !h(meta)) && ((!1 === c || -1 === l.indexOf(meta.stack) || void 0 === c && void 0 === meta.stack) && l.push(meta.stack),
                    meta.index === t))
                        break;
                return l.length || l.push(void 0),
                l
            }
            _getStackCount(t) {
                return this._getStacks(void 0, t).length
            }
            _getStackIndex(t, e, n) {
                const o = this._getStacks(t, n)
                  , r = void 0 !== e ? o.indexOf(e) : -1;
                return -1 === r ? o.length - 1 : r
            }
            _getRuler() {
                const t = this.options
                  , meta = this._cachedMeta
                  , e = meta.iScale
                  , n = [];
                let i, o;
                for (i = 0,
                o = meta.data.length; i < o; ++i)
                    n.push(e.getPixelForValue(this.getParsed(i)[e.axis], i));
                const r = t.barThickness;
                return {
                    min: r || C(meta),
                    pixels: n,
                    start: e._startPixel,
                    end: e._endPixel,
                    stackCount: this._getStackCount(),
                    scale: e,
                    grouped: t.grouped,
                    ratio: r ? 1 : t.categoryPercentage * t.barPercentage
                }
            }
            _calculateBarValuePixels(t) {
                const {_cachedMeta: {vScale: e, _stacked: n}, options: {base: r, minBarLength: c}} = this
                  , l = r || 0
                  , h = this.getParsed(t)
                  , d = h._custom
                  , f = T(d);
                let head, m, x = h[e.axis], y = 0, _ = n ? this.applyStack(e, h, n) : x;
                _ !== x && (y = _ - x,
                _ = x),
                f && (x = d.barStart,
                _ = d.barEnd - d.barStart,
                0 !== x && Object(o.Wb)(x) !== Object(o.Wb)(d.barEnd) && (y = 0),
                y += x);
                const v = Object(o.Ob)(r) || f ? y : r;
                let base = e.getPixelForValue(v);
                if (head = this.chart.getDataVisibility(t) ? e.getPixelForValue(y + _) : base,
                m = head - base,
                Math.abs(m) < c) {
                    m = function(t, e, n) {
                        return 0 !== t ? Object(o.Wb)(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1)
                    }(m, e, l) * c,
                    x === l && (base -= m / 2);
                    const t = e.getPixelForDecimal(0)
                      , n = e.getPixelForDecimal(1)
                      , r = Math.min(t, n)
                      , h = Math.max(t, n);
                    base = Math.max(Math.min(base, h), r),
                    head = base + m
                }
                if (base === e.getPixelForValue(l)) {
                    const t = Object(o.Wb)(m) * e.getLineWidthForValue(l) / 2;
                    base += t,
                    m -= t
                }
                return {
                    size: m,
                    base: base,
                    head: head,
                    center: head + m / 2
                }
            }
            _calculateBarIndexPixels(t, e) {
                const n = e.scale
                  , r = this.options
                  , c = r.skipNull
                  , l = Object(o.Zb)(r.maxBarThickness, 1 / 0);
                let h, d;
                if (e.grouped) {
                    const n = c ? this._getStackCount(t) : e.stackCount
                      , f = "flex" === r.barThickness ? function(t, e, n, o) {
                        const r = e.pixels
                          , c = r[t];
                        let l = t > 0 ? r[t - 1] : null
                          , h = t < r.length - 1 ? r[t + 1] : null;
                        const d = n.categoryPercentage;
                        null === l && (l = c - (null === h ? e.end - e.start : h - c)),
                        null === h && (h = c + c - l);
                        const f = c - (c - Math.min(l, h)) / 2 * d;
                        return {
                            chunk: Math.abs(h - l) / 2 * d / o,
                            ratio: n.barPercentage,
                            start: f
                        }
                    }(t, e, r, n) : function(t, e, n, r) {
                        const c = n.barThickness;
                        let l, h;
                        return Object(o.Ob)(c) ? (l = e.min * n.categoryPercentage,
                        h = n.barPercentage) : (l = c * r,
                        h = 1),
                        {
                            chunk: l / r,
                            ratio: h,
                            start: e.pixels[t] - l / 2
                        }
                    }(t, e, r, n)
                      , m = this._getStackIndex(this.index, this._cachedMeta.stack, c ? t : void 0);
                    h = f.start + f.chunk * m + f.chunk / 2,
                    d = Math.min(l, f.chunk * f.ratio)
                } else
                    h = n.getPixelForValue(this.getParsed(t)[n.axis], t),
                    d = Math.min(l, e.min * e.ratio);
                return {
                    base: h - d / 2,
                    head: h + d / 2,
                    center: h,
                    size: d
                }
            }
            draw() {
                const meta = this._cachedMeta
                  , t = meta.vScale
                  , e = meta.data
                  , n = e.length;
                let i = 0;
                for (; i < n; ++i)
                    null !== this.getParsed(i)[t.axis] && e[i].draw(this._ctx)
            }
        }
        z.id = "bar",
        z.defaults = {
            datasetElementType: !1,
            dataElementType: "bar",
            categoryPercentage: .8,
            barPercentage: .9,
            grouped: !0,
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "base", "width", "height"]
                }
            }
        },
        z.overrides = {
            scales: {
                _index_: {
                    type: "category",
                    offset: !0,
                    grid: {
                        offset: !0
                    }
                },
                _value_: {
                    type: "linear",
                    beginAtZero: !0
                }
            }
        };
        class F extends P {
            initialize() {
                this.enableOptionSharing = !0,
                super.initialize()
            }
            parsePrimitiveData(meta, data, t, e) {
                const n = super.parsePrimitiveData(meta, data, t, e);
                for (let i = 0; i < n.length; i++)
                    n[i]._custom = this.resolveDataElementOptions(i + t).radius;
                return n
            }
            parseArrayData(meta, data, t, e) {
                const n = super.parseArrayData(meta, data, t, e);
                for (let i = 0; i < n.length; i++) {
                    const e = data[t + i];
                    n[i]._custom = Object(o.Zb)(e[2], this.resolveDataElementOptions(i + t).radius)
                }
                return n
            }
            parseObjectData(meta, data, t, e) {
                const n = super.parseObjectData(meta, data, t, e);
                for (let i = 0; i < n.length; i++) {
                    const e = data[t + i];
                    n[i]._custom = Object(o.Zb)(e && e.r && +e.r, this.resolveDataElementOptions(i + t).radius)
                }
                return n
            }
            getMaxOverflow() {
                const data = this._cachedMeta.data;
                let t = 0;
                for (let i = data.length - 1; i >= 0; --i)
                    t = Math.max(t, data[i].size(this.resolveDataElementOptions(i)) / 2);
                return t > 0 && t
            }
            getLabelAndValue(t) {
                const meta = this._cachedMeta
                  , {xScale: e, yScale: n} = meta
                  , o = this.getParsed(t)
                  , r = e.getLabelForValue(o.x)
                  , c = n.getLabelForValue(o.y)
                  , l = o._custom;
                return {
                    label: meta.label,
                    value: "(" + r + ", " + c + (l ? ", " + l : "") + ")"
                }
            }
            update(t) {
                const e = this._cachedMeta.data;
                this.updateElements(e, 0, e.length, t)
            }
            updateElements(t, e, n, o) {
                const r = "reset" === o
                  , {iScale: c, vScale: l} = this._cachedMeta
                  , {sharedOptions: h, includeOptions: d} = this._getSharedOptions(e, o)
                  , f = c.axis
                  , m = l.axis;
                for (let i = e; i < e + n; i++) {
                    const e = t[i]
                      , n = !r && this.getParsed(i)
                      , x = {}
                      , y = x[f] = r ? c.getPixelForDecimal(.5) : c.getPixelForValue(n[f])
                      , _ = x[m] = r ? l.getBasePixel() : l.getPixelForValue(n[m]);
                    x.skip = isNaN(y) || isNaN(_),
                    d && (x.options = h || this.resolveDataElementOptions(i, e.active ? "active" : o),
                    r && (x.options.radius = 0)),
                    this.updateElement(e, i, x, o)
                }
            }
            resolveDataElementOptions(t, e) {
                const n = this.getParsed(t);
                let r = super.resolveDataElementOptions(t, e);
                r.$shared && (r = Object.assign({}, r, {
                    $shared: !1
                }));
                const c = r.radius;
                return "active" !== e && (r.radius = 0),
                r.radius += Object(o.Zb)(n && n._custom, c),
                r
            }
        }
        F.id = "bubble",
        F.defaults = {
            datasetElementType: !1,
            dataElementType: "point",
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "borderWidth", "radius"]
                }
            }
        },
        F.overrides = {
            scales: {
                x: {
                    type: "linear"
                },
                y: {
                    type: "linear"
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        title: ()=>""
                    }
                }
            }
        };
        class W extends P {
            constructor(t, e) {
                super(t, e),
                this.enableOptionSharing = !0,
                this.innerRadius = void 0,
                this.outerRadius = void 0,
                this.offsetX = void 0,
                this.offsetY = void 0
            }
            linkScales() {}
            parse(t, e) {
                const data = this.getDataset().data
                  , meta = this._cachedMeta;
                if (!1 === this._parsing)
                    meta._parsed = data;
                else {
                    let i, n, r = i=>+data[i];
                    if (Object(o.Mb)(data[t])) {
                        const {key: t="value"} = this._parsing;
                        r = i=>+Object(o.Jb)(data[i], t)
                    }
                    for (i = t,
                    n = t + e; i < n; ++i)
                        meta._parsed[i] = r(i)
                }
            }
            _getRotation() {
                return Object(o.Xb)(this.options.rotation - 90)
            }
            _getCircumference() {
                return Object(o.Xb)(this.options.circumference)
            }
            _getRotationExtents() {
                let t = o.u
                  , e = -o.u;
                for (let i = 0; i < this.chart.data.datasets.length; ++i)
                    if (this.chart.isDatasetVisible(i)) {
                        const n = this.chart.getDatasetMeta(i).controller
                          , o = n._getRotation()
                          , r = n._getCircumference();
                        t = Math.min(t, o),
                        e = Math.max(e, o + r)
                    }
                return {
                    rotation: t,
                    circumference: e - t
                }
            }
            update(t) {
                const e = this.chart
                  , {chartArea: n} = e
                  , meta = this._cachedMeta
                  , r = meta.data
                  , c = this.getMaxBorderWidth() + this.getMaxOffset(r) + this.options.spacing
                  , l = Math.max((Math.min(n.width, n.height) - c) / 2, 0)
                  , h = Math.min(Object(o.Qb)(this.options.cutout, l), 1)
                  , d = this._getRingWeight(this.index)
                  , {circumference: f, rotation: m} = this._getRotationExtents()
                  , {ratioX: x, ratioY: y, offsetX: _, offsetY: v} = function(t, e, n) {
                    let r = 1
                      , c = 1
                      , l = 0
                      , h = 0;
                    if (e < o.u) {
                        const d = t
                          , f = d + e
                          , m = Math.cos(d)
                          , x = Math.sin(d)
                          , y = Math.cos(f)
                          , _ = Math.sin(f)
                          , v = (t,a,b)=>Object(o.Tb)(t, d, f, !0) ? 1 : Math.max(a, a * n, b, b * n)
                          , O = (t,a,b)=>Object(o.Tb)(t, d, f, !0) ? -1 : Math.min(a, a * n, b, b * n)
                          , w = v(0, m, y)
                          , M = v(o.i, x, _)
                          , j = O(o.q, m, y)
                          , k = O(o.q + o.i, x, _);
                        r = (w - j) / 2,
                        c = (M - k) / 2,
                        l = -(w + j) / 2,
                        h = -(M + k) / 2
                    }
                    return {
                        ratioX: r,
                        ratioY: c,
                        offsetX: l,
                        offsetY: h
                    }
                }(m, f, h)
                  , O = (n.width - c) / x
                  , w = (n.height - c) / y
                  , M = Math.max(Math.min(O, w) / 2, 0)
                  , j = Object(o.Rb)(this.options.radius, M)
                  , k = (j - Math.max(j * h, 0)) / this._getVisibleDatasetWeightTotal();
                this.offsetX = _ * j,
                this.offsetY = v * j,
                meta.total = this.calculateTotal(),
                this.outerRadius = j - k * this._getRingWeightOffset(this.index),
                this.innerRadius = Math.max(this.outerRadius - k * d, 0),
                this.updateElements(r, 0, r.length, t)
            }
            _circumference(i, t) {
                const e = this.options
                  , meta = this._cachedMeta
                  , n = this._getCircumference();
                return t && e.animation.animateRotate || !this.chart.getDataVisibility(i) || null === meta._parsed[i] || meta.data[i].hidden ? 0 : this.calculateCircumference(meta._parsed[i] * n / o.u)
            }
            updateElements(t, e, n, o) {
                const r = "reset" === o
                  , c = this.chart
                  , l = c.chartArea
                  , h = c.options.animation
                  , d = (l.left + l.right) / 2
                  , f = (l.top + l.bottom) / 2
                  , m = r && h.animateScale
                  , x = m ? 0 : this.innerRadius
                  , y = m ? 0 : this.outerRadius
                  , {sharedOptions: _, includeOptions: v} = this._getSharedOptions(e, o);
                let i, O = this._getRotation();
                for (i = 0; i < e; ++i)
                    O += this._circumference(i, r);
                for (i = e; i < e + n; ++i) {
                    const e = this._circumference(i, r)
                      , n = t[i]
                      , c = {
                        x: d + this.offsetX,
                        y: f + this.offsetY,
                        startAngle: O,
                        endAngle: O + e,
                        circumference: e,
                        outerRadius: y,
                        innerRadius: x
                    };
                    v && (c.options = _ || this.resolveDataElementOptions(i, n.active ? "active" : o)),
                    O += e,
                    this.updateElement(n, i, c, o)
                }
            }
            calculateTotal() {
                const meta = this._cachedMeta
                  , t = meta.data;
                let i, e = 0;
                for (i = 0; i < t.length; i++) {
                    const n = meta._parsed[i];
                    null === n || isNaN(n) || !this.chart.getDataVisibility(i) || t[i].hidden || (e += Math.abs(n))
                }
                return e
            }
            calculateCircumference(t) {
                const e = this._cachedMeta.total;
                return e > 0 && !isNaN(t) ? o.u * (Math.abs(t) / e) : 0
            }
            getLabelAndValue(t) {
                const meta = this._cachedMeta
                  , e = this.chart
                  , n = e.data.labels || []
                  , r = Object(o.Sb)(meta._parsed[t], e.options.locale);
                return {
                    label: n[t] || "",
                    value: r
                }
            }
            getMaxBorderWidth(t) {
                let e = 0;
                const n = this.chart;
                let i, o, meta, r, c;
                if (!t)
                    for (i = 0,
                    o = n.data.datasets.length; i < o; ++i)
                        if (n.isDatasetVisible(i)) {
                            meta = n.getDatasetMeta(i),
                            t = meta.data,
                            r = meta.controller;
                            break
                        }
                if (!t)
                    return 0;
                for (i = 0,
                o = t.length; i < o; ++i)
                    c = r.resolveDataElementOptions(i),
                    "inner" !== c.borderAlign && (e = Math.max(e, c.borderWidth || 0, c.hoverBorderWidth || 0));
                return e
            }
            getMaxOffset(t) {
                let e = 0;
                for (let i = 0, n = t.length; i < n; ++i) {
                    const t = this.resolveDataElementOptions(i);
                    e = Math.max(e, t.offset || 0, t.hoverOffset || 0)
                }
                return e
            }
            _getRingWeightOffset(t) {
                let e = 0;
                for (let i = 0; i < t; ++i)
                    this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
                return e
            }
            _getRingWeight(t) {
                return Math.max(Object(o.Zb)(this.chart.data.datasets[t].weight, 1), 0)
            }
            _getVisibleDatasetWeightTotal() {
                return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
            }
        }
        W.id = "doughnut",
        W.defaults = {
            datasetElementType: !1,
            dataElementType: "arc",
            animation: {
                animateRotate: !0,
                animateScale: !1
            },
            animations: {
                numbers: {
                    type: "number",
                    properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
                }
            },
            cutout: "50%",
            rotation: 0,
            circumference: 360,
            radius: "100%",
            spacing: 0,
            indexAxis: "r"
        },
        W.descriptors = {
            _scriptable: t=>"spacing" !== t,
            _indexable: t=>"spacing" !== t
        },
        W.overrides = {
            aspectRatio: 1,
            plugins: {
                legend: {
                    labels: {
                        generateLabels(t) {
                            const data = t.data;
                            if (data.labels.length && data.datasets.length) {
                                const {labels: {pointStyle: e}} = t.legend.options;
                                return data.labels.map(((label,i)=>{
                                    const style = t.getDatasetMeta(0).controller.getStyle(i);
                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        lineWidth: style.borderWidth,
                                        pointStyle: e,
                                        hidden: !t.getDataVisibility(i),
                                        index: i
                                    }
                                }
                                ))
                            }
                            return []
                        }
                    },
                    onClick(t, e, legend) {
                        legend.chart.toggleDataVisibility(e.index),
                        legend.chart.update()
                    }
                },
                tooltip: {
                    callbacks: {
                        title: ()=>"",
                        label(t) {
                            let e = t.label;
                            const n = ": " + t.formattedValue;
                            return Object(o.Cb)(e) ? (e = e.slice(),
                            e[0] += n) : e += n,
                            e
                        }
                    }
                }
            }
        };
        class V extends P {
            initialize() {
                this.enableOptionSharing = !0,
                this.supportsDecimation = !0,
                super.initialize()
            }
            update(t) {
                const meta = this._cachedMeta
                  , {dataset: line, data: e=[], _dataset: n} = meta
                  , r = this.chart._animationsDisabled;
                let {start: c, count: l} = Object(o.Ub)(meta, e, r);
                this._drawStart = c,
                this._drawCount = l,
                Object(o.ac)(meta) && (c = 0,
                l = e.length),
                line._chart = this.chart,
                line._datasetIndex = this.index,
                line._decimated = !!n._decimated,
                line.points = e;
                const h = this.resolveDatasetElementOptions(t);
                this.options.showLine || (h.borderWidth = 0),
                h.segment = this.options.segment,
                this.updateElement(line, void 0, {
                    animated: !r,
                    options: h
                }, t),
                this.updateElements(e, c, l, t)
            }
            updateElements(t, e, n, r) {
                const c = "reset" === r
                  , {iScale: l, vScale: h, _stacked: d, _dataset: f} = this._cachedMeta
                  , {sharedOptions: m, includeOptions: x} = this._getSharedOptions(e, r)
                  , y = l.axis
                  , _ = h.axis
                  , {spanGaps: v, segment: O} = this.options
                  , w = Object(o.bc)(v) ? v : Number.POSITIVE_INFINITY
                  , M = this.chart._animationsDisabled || c || "none" === r;
                let j = e > 0 && this.getParsed(e - 1);
                for (let i = e; i < e + n; ++i) {
                    const e = t[i]
                      , n = this.getParsed(i)
                      , v = M ? e : {}
                      , k = Object(o.Ob)(n[_])
                      , S = v[y] = l.getPixelForValue(n[y], i)
                      , P = v[_] = c || k ? h.getBasePixel() : h.getPixelForValue(d ? this.applyStack(h, n, d) : n[_], i);
                    v.skip = isNaN(S) || isNaN(P) || k,
                    v.stop = i > 0 && Math.abs(n[y] - j[y]) > w,
                    O && (v.parsed = n,
                    v.raw = f.data[i]),
                    x && (v.options = m || this.resolveDataElementOptions(i, e.active ? "active" : r)),
                    M || this.updateElement(e, i, v, r),
                    j = n
                }
            }
            getMaxOverflow() {
                const meta = this._cachedMeta
                  , t = meta.dataset
                  , e = t.options && t.options.borderWidth || 0
                  , data = meta.data || [];
                if (!data.length)
                    return e;
                const n = data[0].size(this.resolveDataElementOptions(0))
                  , o = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(e, n, o) / 2
            }
            draw() {
                const meta = this._cachedMeta;
                meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis),
                super.draw()
            }
        }
        V.id = "line",
        V.defaults = {
            datasetElementType: "line",
            dataElementType: "point",
            showLine: !0,
            spanGaps: !1
        },
        V.overrides = {
            scales: {
                _index_: {
                    type: "category"
                },
                _value_: {
                    type: "linear"
                }
            }
        };
        class N extends P {
            constructor(t, e) {
                super(t, e),
                this.innerRadius = void 0,
                this.outerRadius = void 0
            }
            getLabelAndValue(t) {
                const meta = this._cachedMeta
                  , e = this.chart
                  , n = e.data.labels || []
                  , r = Object(o.Sb)(meta._parsed[t].r, e.options.locale);
                return {
                    label: n[t] || "",
                    value: r
                }
            }
            parseObjectData(meta, data, t, e) {
                return o.cc.bind(this)(meta, data, t, e)
            }
            update(t) {
                const e = this._cachedMeta.data;
                this._updateRadius(),
                this.updateElements(e, 0, e.length, t)
            }
            getMinMax() {
                const meta = this._cachedMeta
                  , t = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                };
                return meta.data.forEach(((element,e)=>{
                    const n = this.getParsed(e).r;
                    !isNaN(n) && this.chart.getDataVisibility(e) && (n < t.min && (t.min = n),
                    n > t.max && (t.max = n))
                }
                )),
                t
            }
            _updateRadius() {
                const t = this.chart
                  , e = t.chartArea
                  , n = t.options
                  , o = Math.min(e.right - e.left, e.bottom - e.top)
                  , r = Math.max(o / 2, 0)
                  , c = (r - Math.max(n.cutoutPercentage ? r / 100 * n.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
                this.outerRadius = r - c * this.index,
                this.innerRadius = this.outerRadius - c
            }
            updateElements(t, e, n, r) {
                const c = "reset" === r
                  , l = this.chart
                  , h = l.options.animation
                  , d = this._cachedMeta.rScale
                  , f = d.xCenter
                  , m = d.yCenter
                  , x = d.getIndexAngle(0) - .5 * o.q;
                let i, y = x;
                const _ = 360 / this.countVisibleElements();
                for (i = 0; i < e; ++i)
                    y += this._computeAngle(i, r, _);
                for (i = e; i < e + n; i++) {
                    const e = t[i];
                    let n = y
                      , o = y + this._computeAngle(i, r, _)
                      , v = l.getDataVisibility(i) ? d.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
                    y = o,
                    c && (h.animateScale && (v = 0),
                    h.animateRotate && (n = o = x));
                    const O = {
                        x: f,
                        y: m,
                        innerRadius: 0,
                        outerRadius: v,
                        startAngle: n,
                        endAngle: o,
                        options: this.resolveDataElementOptions(i, e.active ? "active" : r)
                    };
                    this.updateElement(e, i, O, r)
                }
            }
            countVisibleElements() {
                const meta = this._cachedMeta;
                let t = 0;
                return meta.data.forEach(((element,e)=>{
                    !isNaN(this.getParsed(e).r) && this.chart.getDataVisibility(e) && t++
                }
                )),
                t
            }
            _computeAngle(t, e, n) {
                return this.chart.getDataVisibility(t) ? Object(o.Xb)(this.resolveDataElementOptions(t, e).angle || n) : 0
            }
        }
        N.id = "polarArea",
        N.defaults = {
            dataElementType: "arc",
            animation: {
                animateRotate: !0,
                animateScale: !0
            },
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
                }
            },
            indexAxis: "r",
            startAngle: 0
        },
        N.overrides = {
            aspectRatio: 1,
            plugins: {
                legend: {
                    labels: {
                        generateLabels(t) {
                            const data = t.data;
                            if (data.labels.length && data.datasets.length) {
                                const {labels: {pointStyle: e}} = t.legend.options;
                                return data.labels.map(((label,i)=>{
                                    const style = t.getDatasetMeta(0).controller.getStyle(i);
                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        lineWidth: style.borderWidth,
                                        pointStyle: e,
                                        hidden: !t.getDataVisibility(i),
                                        index: i
                                    }
                                }
                                ))
                            }
                            return []
                        }
                    },
                    onClick(t, e, legend) {
                        legend.chart.toggleDataVisibility(e.index),
                        legend.chart.update()
                    }
                },
                tooltip: {
                    callbacks: {
                        title: ()=>"",
                        label: t=>t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue
                    }
                }
            },
            scales: {
                r: {
                    type: "radialLinear",
                    angleLines: {
                        display: !1
                    },
                    beginAtZero: !0,
                    grid: {
                        circular: !0
                    },
                    pointLabels: {
                        display: !1
                    },
                    startAngle: 0
                }
            }
        };
        class B extends W {
        }
        B.id = "pie",
        B.defaults = {
            cutout: 0,
            rotation: 0,
            circumference: 360,
            radius: "100%"
        };
        class H extends P {
            getLabelAndValue(t) {
                const e = this._cachedMeta.vScale
                  , n = this.getParsed(t);
                return {
                    label: e.getLabels()[t],
                    value: "" + e.getLabelForValue(n[e.axis])
                }
            }
            parseObjectData(meta, data, t, e) {
                return o.cc.bind(this)(meta, data, t, e)
            }
            update(t) {
                const meta = this._cachedMeta
                  , line = meta.dataset
                  , e = meta.data || []
                  , n = meta.iScale.getLabels();
                if (line.points = e,
                "resize" !== t) {
                    const o = this.resolveDatasetElementOptions(t);
                    this.options.showLine || (o.borderWidth = 0);
                    const r = {
                        _loop: !0,
                        _fullLoop: n.length === e.length,
                        options: o
                    };
                    this.updateElement(line, void 0, r, t)
                }
                this.updateElements(e, 0, e.length, t)
            }
            updateElements(t, e, n, o) {
                const r = this._cachedMeta.rScale
                  , c = "reset" === o;
                for (let i = e; i < e + n; i++) {
                    const e = t[i]
                      , n = this.resolveDataElementOptions(i, e.active ? "active" : o)
                      , l = r.getPointPositionForValue(i, this.getParsed(i).r)
                      , h = c ? r.xCenter : l.x
                      , d = c ? r.yCenter : l.y
                      , f = {
                        x: h,
                        y: d,
                        angle: l.angle,
                        skip: isNaN(h) || isNaN(d),
                        options: n
                    };
                    this.updateElement(e, i, f, o)
                }
            }
        }
        H.id = "radar",
        H.defaults = {
            datasetElementType: "line",
            dataElementType: "point",
            indexAxis: "r",
            showLine: !0,
            elements: {
                line: {
                    fill: "start"
                }
            }
        },
        H.overrides = {
            aspectRatio: 1,
            scales: {
                r: {
                    type: "radialLinear"
                }
            }
        };
        class Y {
            constructor() {
                this.x = void 0,
                this.y = void 0,
                this.active = !1,
                this.options = void 0,
                this.$animations = void 0
            }
            tooltipPosition(t) {
                const {x: e, y: n} = this.getProps(["x", "y"], t);
                return {
                    x: e,
                    y: n
                }
            }
            hasValue() {
                return Object(o.bc)(this.x) && Object(o.bc)(this.y)
            }
            getProps(t, e) {
                const n = this.$animations;
                if (!e || !n)
                    return this;
                const o = {};
                return t.forEach((t=>{
                    o[t] = n[t] && n[t].active() ? n[t]._to : this[t]
                }
                )),
                o
            }
        }
        Y.defaults = {},
        Y.defaultRoutes = void 0;
        const X = {
            values: t=>Object(o.Cb)(t) ? t : "" + t,
            numeric(t, e, n) {
                if (0 === t)
                    return "0";
                const r = this.chart.options.locale;
                let c, l = t;
                if (n.length > 1) {
                    const e = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
                    (e < 1e-4 || e > 1e15) && (c = "scientific"),
                    l = function(t, e) {
                        let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
                        Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t));
                        return n
                    }(t, n)
                }
                const h = Object(o.dc)(Math.abs(l))
                  , d = Math.max(Math.min(-1 * Math.floor(h), 20), 0)
                  , f = {
                    notation: c,
                    minimumFractionDigits: d,
                    maximumFractionDigits: d
                };
                return Object.assign(f, this.options.ticks.format),
                Object(o.Sb)(t, r, f)
            },
            logarithmic(t, e, n) {
                if (0 === t)
                    return "0";
                const r = t / Math.pow(10, Math.floor(Object(o.dc)(t)));
                return 1 === r || 2 === r || 5 === r ? X.numeric.call(this, t, e, n) : ""
            }
        };
        var $ = {
            formatters: X
        };
        function U(t, e) {
            const n = t.options.ticks
              , r = n.maxTicksLimit || function(t) {
                const e = t.options.offset
                  , n = t._tickSize()
                  , o = t._length / n + (e ? 0 : 1)
                  , r = t._maxLength / n;
                return Math.floor(Math.min(o, r))
            }(t)
              , c = n.major.enabled ? function(t) {
                const e = [];
                let i, n;
                for (i = 0,
                n = t.length; i < n; i++)
                    t[i].major && e.push(i);
                return e
            }(e) : []
              , l = c.length
              , h = c[0]
              , d = c[l - 1]
              , f = [];
            if (l > r)
                return function(t, e, n, o) {
                    let i, r = 0, c = n[0];
                    for (o = Math.ceil(o),
                    i = 0; i < t.length; i++)
                        i === c && (e.push(t[i]),
                        r++,
                        c = n[r * o])
                }(e, f, c, l / r),
                f;
            const m = function(t, e, n) {
                const r = function(t) {
                    const e = t.length;
                    let i, n;
                    if (e < 2)
                        return !1;
                    for (n = t[0],
                    i = 1; i < e; ++i)
                        if (t[i] - t[i - 1] !== n)
                            return !1;
                    return n
                }(t)
                  , c = e.length / n;
                if (!r)
                    return Math.max(c, 1);
                const l = Object(o.b)(r);
                for (let i = 0, t = l.length - 1; i < t; i++) {
                    const t = l[i];
                    if (t > c)
                        return t
                }
                return Math.max(c, 1)
            }(c, e, r);
            if (l > 0) {
                let i, t;
                const n = l > 1 ? Math.round((d - h) / (l - 1)) : null;
                for (Z(e, f, m, Object(o.Ob)(n) ? 0 : h - n, h),
                i = 0,
                t = l - 1; i < t; i++)
                    Z(e, f, m, c[i], c[i + 1]);
                return Z(e, f, m, d, Object(o.Ob)(n) ? e.length : d + n),
                f
            }
            return Z(e, f, m),
            f
        }
        function Z(t, e, n, r, c) {
            const l = Object(o.Zb)(r, 0)
              , h = Math.min(Object(o.Zb)(c, t.length), t.length);
            let d, i, f, m = 0;
            for (n = Math.ceil(n),
            c && (d = c - r,
            n = d / Math.floor(d / n)),
            f = l; f < 0; )
                m++,
                f = Math.round(l + m * n);
            for (i = Math.max(l, 0); i < h; i++)
                i === f && (e.push(t[i]),
                m++,
                f = Math.round(l + m * n))
        }
        o.Hb.set("scale", {
            display: !0,
            offset: !1,
            reverse: !1,
            beginAtZero: !1,
            bounds: "ticks",
            grace: 0,
            grid: {
                display: !0,
                lineWidth: 1,
                drawBorder: !0,
                drawOnChartArea: !0,
                drawTicks: !0,
                tickLength: 8,
                tickWidth: (t,e)=>e.lineWidth,
                tickColor: (t,e)=>e.color,
                offset: !1,
                borderDash: [],
                borderDashOffset: 0,
                borderWidth: 1
            },
            title: {
                display: !1,
                text: "",
                padding: {
                    top: 4,
                    bottom: 4
                }
            },
            ticks: {
                minRotation: 0,
                maxRotation: 50,
                mirror: !1,
                textStrokeWidth: 0,
                textStrokeColor: "",
                padding: 3,
                display: !0,
                autoSkip: !0,
                autoSkipPadding: 3,
                labelOffset: 0,
                callback: $.formatters.values,
                minor: {},
                major: {},
                align: "center",
                crossAlign: "near",
                showLabelBackdrop: !1,
                backdropColor: "rgba(255, 255, 255, 0.75)",
                backdropPadding: 2
            }
        }),
        o.Hb.route("scale.ticks", "color", "", "color"),
        o.Hb.route("scale.grid", "color", "", "borderColor"),
        o.Hb.route("scale.grid", "borderColor", "", "borderColor"),
        o.Hb.route("scale.title", "color", "", "color"),
        o.Hb.describe("scale", {
            _fallback: !1,
            _scriptable: t=>!t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
            _indexable: t=>"borderDash" !== t && "tickBorderDash" !== t
        }),
        o.Hb.describe("scales", {
            _fallback: "scale"
        }),
        o.Hb.describe("scale.ticks", {
            _scriptable: t=>"backdropPadding" !== t && "callback" !== t,
            _indexable: t=>"backdropPadding" !== t
        });
        const K = (t,e,n)=>"top" === e || "left" === e ? t[e] + n : t[e] - n;
        function J(t, e) {
            const n = []
              , o = t.length / e
              , r = t.length;
            let i = 0;
            for (; i < r; i += o)
                n.push(t[Math.floor(i)]);
            return n
        }
        function G(t, e, n) {
            const o = t.ticks.length
              , r = Math.min(e, o - 1)
              , c = t._startPixel
              , l = t._endPixel
              , h = 1e-6;
            let d, f = t.getPixelForTick(r);
            if (!(n && (d = 1 === o ? Math.max(f - c, l - f) : 0 === e ? (t.getPixelForTick(1) - f) / 2 : (f - t.getPixelForTick(r - 1)) / 2,
            f += r < e ? d : -d,
            f < c - h || f > l + h)))
                return f
        }
        function Q(t) {
            return t.drawTicks ? t.tickLength : 0
        }
        function tt(t, e) {
            if (!t.display)
                return 0;
            const n = Object(o.p)(t.font, e)
              , r = Object(o.l)(t.padding);
            return (Object(o.Cb)(t.text) ? t.text.length : 1) * n.lineHeight + r.height
        }
        function et(t, e, n) {
            let r = Object(o.s)(t);
            return (n && "right" !== e || !n && "right" === e) && (r = (t=>"left" === t ? "right" : "right" === t ? "left" : t)(r)),
            r
        }
        class it extends Y {
            constructor(t) {
                super(),
                this.id = t.id,
                this.type = t.type,
                this.options = void 0,
                this.ctx = t.ctx,
                this.chart = t.chart,
                this.top = void 0,
                this.bottom = void 0,
                this.left = void 0,
                this.right = void 0,
                this.width = void 0,
                this.height = void 0,
                this._margins = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                },
                this.maxWidth = void 0,
                this.maxHeight = void 0,
                this.paddingTop = void 0,
                this.paddingBottom = void 0,
                this.paddingLeft = void 0,
                this.paddingRight = void 0,
                this.axis = void 0,
                this.labelRotation = void 0,
                this.min = void 0,
                this.max = void 0,
                this._range = void 0,
                this.ticks = [],
                this._gridLineItems = null,
                this._labelItems = null,
                this._labelSizes = null,
                this._length = 0,
                this._maxLength = 0,
                this._longestTextCache = {},
                this._startPixel = void 0,
                this._endPixel = void 0,
                this._reversePixels = !1,
                this._userMax = void 0,
                this._userMin = void 0,
                this._suggestedMax = void 0,
                this._suggestedMin = void 0,
                this._ticksLength = 0,
                this._borderValue = 0,
                this._cache = {},
                this._dataLimitsCached = !1,
                this.$context = void 0
            }
            init(t) {
                this.options = t.setContext(this.getContext()),
                this.axis = t.axis,
                this._userMin = this.parse(t.min),
                this._userMax = this.parse(t.max),
                this._suggestedMin = this.parse(t.suggestedMin),
                this._suggestedMax = this.parse(t.suggestedMax)
            }
            parse(t, e) {
                return t
            }
            getUserBounds() {
                let {_userMin: t, _userMax: e, _suggestedMin: n, _suggestedMax: r} = this;
                return t = Object(o.c)(t, Number.POSITIVE_INFINITY),
                e = Object(o.c)(e, Number.NEGATIVE_INFINITY),
                n = Object(o.c)(n, Number.POSITIVE_INFINITY),
                r = Object(o.c)(r, Number.NEGATIVE_INFINITY),
                {
                    min: Object(o.c)(t, n),
                    max: Object(o.c)(e, r),
                    minDefined: Object(o.Kb)(t),
                    maxDefined: Object(o.Kb)(e)
                }
            }
            getMinMax(t) {
                let e, {min: n, max: r, minDefined: c, maxDefined: l} = this.getUserBounds();
                if (c && l)
                    return {
                        min: n,
                        max: r
                    };
                const h = this.getMatchingVisibleMetas();
                for (let i = 0, o = h.length; i < o; ++i)
                    e = h[i].controller.getMinMax(this, t),
                    c || (n = Math.min(n, e.min)),
                    l || (r = Math.max(r, e.max));
                return n = l && n > r ? r : n,
                r = c && n > r ? n : r,
                {
                    min: Object(o.c)(n, Object(o.c)(r, n)),
                    max: Object(o.c)(r, Object(o.c)(n, r))
                }
            }
            getPadding() {
                return {
                    left: this.paddingLeft || 0,
                    top: this.paddingTop || 0,
                    right: this.paddingRight || 0,
                    bottom: this.paddingBottom || 0
                }
            }
            getTicks() {
                return this.ticks
            }
            getLabels() {
                const data = this.chart.data;
                return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || []
            }
            beforeLayout() {
                this._cache = {},
                this._dataLimitsCached = !1
            }
            beforeUpdate() {
                Object(o.d)(this.options.beforeUpdate, [this])
            }
            update(t, e, n) {
                const {beginAtZero: r, grace: c, ticks: l} = this.options
                  , h = l.sampleSize;
                this.beforeUpdate(),
                this.maxWidth = t,
                this.maxHeight = e,
                this._margins = n = Object.assign({
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, n),
                this.ticks = null,
                this._labelSizes = null,
                this._gridLineItems = null,
                this._labelItems = null,
                this.beforeSetDimensions(),
                this.setDimensions(),
                this.afterSetDimensions(),
                this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom,
                this._dataLimitsCached || (this.beforeDataLimits(),
                this.determineDataLimits(),
                this.afterDataLimits(),
                this._range = Object(o.e)(this, c, r),
                this._dataLimitsCached = !0),
                this.beforeBuildTicks(),
                this.ticks = this.buildTicks() || [],
                this.afterBuildTicks();
                const d = h < this.ticks.length;
                this._convertTicksToLabels(d ? J(this.ticks, h) : this.ticks),
                this.configure(),
                this.beforeCalculateLabelRotation(),
                this.calculateLabelRotation(),
                this.afterCalculateLabelRotation(),
                l.display && (l.autoSkip || "auto" === l.source) && (this.ticks = U(this, this.ticks),
                this._labelSizes = null,
                this.afterAutoSkip()),
                d && this._convertTicksToLabels(this.ticks),
                this.beforeFit(),
                this.fit(),
                this.afterFit(),
                this.afterUpdate()
            }
            configure() {
                let t, e, n = this.options.reverse;
                this.isHorizontal() ? (t = this.left,
                e = this.right) : (t = this.top,
                e = this.bottom,
                n = !n),
                this._startPixel = t,
                this._endPixel = e,
                this._reversePixels = n,
                this._length = e - t,
                this._alignToPixels = this.options.alignToPixels
            }
            afterUpdate() {
                Object(o.d)(this.options.afterUpdate, [this])
            }
            beforeSetDimensions() {
                Object(o.d)(this.options.beforeSetDimensions, [this])
            }
            setDimensions() {
                this.isHorizontal() ? (this.width = this.maxWidth,
                this.left = 0,
                this.right = this.width) : (this.height = this.maxHeight,
                this.top = 0,
                this.bottom = this.height),
                this.paddingLeft = 0,
                this.paddingTop = 0,
                this.paddingRight = 0,
                this.paddingBottom = 0
            }
            afterSetDimensions() {
                Object(o.d)(this.options.afterSetDimensions, [this])
            }
            _callHooks(t) {
                this.chart.notifyPlugins(t, this.getContext()),
                Object(o.d)(this.options[t], [this])
            }
            beforeDataLimits() {
                this._callHooks("beforeDataLimits")
            }
            determineDataLimits() {}
            afterDataLimits() {
                this._callHooks("afterDataLimits")
            }
            beforeBuildTicks() {
                this._callHooks("beforeBuildTicks")
            }
            buildTicks() {
                return []
            }
            afterBuildTicks() {
                this._callHooks("afterBuildTicks")
            }
            beforeTickToLabelConversion() {
                Object(o.d)(this.options.beforeTickToLabelConversion, [this])
            }
            generateTickLabels(t) {
                const e = this.options.ticks;
                let i, n, r;
                for (i = 0,
                n = t.length; i < n; i++)
                    r = t[i],
                    r.label = Object(o.d)(e.callback, [r.value, i, t], this)
            }
            afterTickToLabelConversion() {
                Object(o.d)(this.options.afterTickToLabelConversion, [this])
            }
            beforeCalculateLabelRotation() {
                Object(o.d)(this.options.beforeCalculateLabelRotation, [this])
            }
            calculateLabelRotation() {
                const t = this.options
                  , e = t.ticks
                  , n = this.ticks.length
                  , r = e.minRotation || 0
                  , c = e.maxRotation;
                let l, h, d, f = r;
                if (!this._isVisible() || !e.display || r >= c || n <= 1 || !this.isHorizontal())
                    return void (this.labelRotation = r);
                const m = this._getLabelSizes()
                  , x = m.widest.width
                  , y = m.highest.height
                  , _ = Object(o.f)(this.chart.width - x, 0, this.maxWidth);
                l = t.offset ? this.maxWidth / n : _ / (n - 1),
                x + 6 > l && (l = _ / (n - (t.offset ? .5 : 1)),
                h = this.maxHeight - Q(t.grid) - e.padding - tt(t.title, this.chart.options.font),
                d = Math.sqrt(x * x + y * y),
                f = Object(o.g)(Math.min(Math.asin(Object(o.f)((m.highest.height + 6) / l, -1, 1)), Math.asin(Object(o.f)(h / d, -1, 1)) - Math.asin(Object(o.f)(y / d, -1, 1)))),
                f = Math.max(r, Math.min(c, f))),
                this.labelRotation = f
            }
            afterCalculateLabelRotation() {
                Object(o.d)(this.options.afterCalculateLabelRotation, [this])
            }
            afterAutoSkip() {}
            beforeFit() {
                Object(o.d)(this.options.beforeFit, [this])
            }
            fit() {
                const t = {
                    width: 0,
                    height: 0
                }
                  , {chart: e, options: {ticks: n, title: r, grid: c}} = this
                  , l = this._isVisible()
                  , h = this.isHorizontal();
                if (l) {
                    const l = tt(r, e.options.font);
                    if (h ? (t.width = this.maxWidth,
                    t.height = Q(c) + l) : (t.height = this.maxHeight,
                    t.width = Q(c) + l),
                    n.display && this.ticks.length) {
                        const {first: e, last: r, widest: c, highest: l} = this._getLabelSizes()
                          , d = 2 * n.padding
                          , f = Object(o.Xb)(this.labelRotation)
                          , m = Math.cos(f)
                          , x = Math.sin(f);
                        if (h) {
                            const e = n.mirror ? 0 : x * c.width + m * l.height;
                            t.height = Math.min(this.maxHeight, t.height + e + d)
                        } else {
                            const e = n.mirror ? 0 : m * c.width + x * l.height;
                            t.width = Math.min(this.maxWidth, t.width + e + d)
                        }
                        this._calculatePadding(e, r, x, m)
                    }
                }
                this._handleMargins(),
                h ? (this.width = this._length = e.width - this._margins.left - this._margins.right,
                this.height = t.height) : (this.width = t.width,
                this.height = this._length = e.height - this._margins.top - this._margins.bottom)
            }
            _calculatePadding(t, e, n, o) {
                const {ticks: {align: r, padding: c}, position: l} = this.options
                  , h = 0 !== this.labelRotation
                  , d = "top" !== l && "x" === this.axis;
                if (this.isHorizontal()) {
                    const l = this.getPixelForTick(0) - this.left
                      , f = this.right - this.getPixelForTick(this.ticks.length - 1);
                    let m = 0
                      , x = 0;
                    h ? d ? (m = o * t.width,
                    x = n * e.height) : (m = n * t.height,
                    x = o * e.width) : "start" === r ? x = e.width : "end" === r ? m = t.width : "inner" !== r && (m = t.width / 2,
                    x = e.width / 2),
                    this.paddingLeft = Math.max((m - l + c) * this.width / (this.width - l), 0),
                    this.paddingRight = Math.max((x - f + c) * this.width / (this.width - f), 0)
                } else {
                    let n = e.height / 2
                      , o = t.height / 2;
                    "start" === r ? (n = 0,
                    o = t.height) : "end" === r && (n = e.height,
                    o = 0),
                    this.paddingTop = n + c,
                    this.paddingBottom = o + c
                }
            }
            _handleMargins() {
                this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left),
                this._margins.top = Math.max(this.paddingTop, this._margins.top),
                this._margins.right = Math.max(this.paddingRight, this._margins.right),
                this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
            }
            afterFit() {
                Object(o.d)(this.options.afterFit, [this])
            }
            isHorizontal() {
                const {axis: t, position: e} = this.options;
                return "top" === e || "bottom" === e || "x" === t
            }
            isFullSize() {
                return this.options.fullSize
            }
            _convertTicksToLabels(t) {
                let i, e;
                for (this.beforeTickToLabelConversion(),
                this.generateTickLabels(t),
                i = 0,
                e = t.length; i < e; i++)
                    Object(o.Ob)(t[i].label) && (t.splice(i, 1),
                    e--,
                    i--);
                this.afterTickToLabelConversion()
            }
            _getLabelSizes() {
                let t = this._labelSizes;
                if (!t) {
                    const e = this.options.ticks.sampleSize;
                    let n = this.ticks;
                    e < n.length && (n = J(n, e)),
                    this._labelSizes = t = this._computeLabelSizes(n, n.length)
                }
                return t
            }
            _computeLabelSizes(t, e) {
                const {ctx: n, _longestTextCache: r} = this
                  , c = []
                  , l = [];
                let i, h, d, label, f, m, x, y, _, v, O, w = 0, M = 0;
                for (i = 0; i < e; ++i) {
                    if (label = t[i].label,
                    f = this._resolveTickFontOptions(i),
                    n.font = m = f.string,
                    x = r[m] = r[m] || {
                        data: {},
                        gc: []
                    },
                    y = f.lineHeight,
                    _ = v = 0,
                    Object(o.Ob)(label) || Object(o.Cb)(label)) {
                        if (Object(o.Cb)(label))
                            for (h = 0,
                            d = label.length; h < d; ++h)
                                O = label[h],
                                Object(o.Ob)(O) || Object(o.Cb)(O) || (_ = Object(o.h)(n, x.data, x.gc, _, O),
                                v += y)
                    } else
                        _ = Object(o.h)(n, x.data, x.gc, _, label),
                        v = y;
                    c.push(_),
                    l.push(v),
                    w = Math.max(_, w),
                    M = Math.max(v, M)
                }
                !function(t, e) {
                    Object(o.r)(t, (t=>{
                        const n = t.gc
                          , o = n.length / 2;
                        let i;
                        if (o > e) {
                            for (i = 0; i < o; ++i)
                                delete t.data[n[i]];
                            n.splice(0, o)
                        }
                    }
                    ))
                }(r, e);
                const j = c.indexOf(w)
                  , k = l.indexOf(M)
                  , S = t=>({
                    width: c[t] || 0,
                    height: l[t] || 0
                });
                return {
                    first: S(0),
                    last: S(e - 1),
                    widest: S(j),
                    highest: S(k),
                    widths: c,
                    heights: l
                }
            }
            getLabelForValue(t) {
                return t
            }
            getPixelForValue(t, e) {
                return NaN
            }
            getValueForPixel(t) {}
            getPixelForTick(t) {
                const e = this.ticks;
                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
            }
            getPixelForDecimal(t) {
                this._reversePixels && (t = 1 - t);
                const e = this._startPixel + t * this._length;
                return Object(o.j)(this._alignToPixels ? Object(o.k)(this.chart, e, 0) : e)
            }
            getDecimalForPixel(t) {
                const e = (t - this._startPixel) / this._length;
                return this._reversePixels ? 1 - e : e
            }
            getBasePixel() {
                return this.getPixelForValue(this.getBaseValue())
            }
            getBaseValue() {
                const {min: t, max: e} = this;
                return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
            }
            getContext(t) {
                const e = this.ticks || [];
                if (t >= 0 && t < e.length) {
                    const n = e[t];
                    return n.$context || (n.$context = function(t, e, n) {
                        return Object(o.Lb)(t, {
                            tick: n,
                            index: e,
                            type: "tick"
                        })
                    }(this.getContext(), t, n))
                }
                return this.$context || (this.$context = (n = this.chart.getContext(),
                r = this,
                Object(o.Lb)(n, {
                    scale: r,
                    type: "scale"
                })));
                var n, r
            }
            _tickSize() {
                const t = this.options.ticks
                  , e = Object(o.Xb)(this.labelRotation)
                  , n = Math.abs(Math.cos(e))
                  , r = Math.abs(Math.sin(e))
                  , c = this._getLabelSizes()
                  , l = t.autoSkipPadding || 0
                  , h = c ? c.widest.width + l : 0
                  , d = c ? c.highest.height + l : 0;
                return this.isHorizontal() ? d * n > h * r ? h / n : d / r : d * r < h * n ? d / n : h / r
            }
            _isVisible() {
                const t = this.options.display;
                return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0
            }
            _computeGridLineItems(t) {
                const e = this.axis
                  , n = this.chart
                  , r = this.options
                  , {grid: c, position: l} = r
                  , h = c.offset
                  , d = this.isHorizontal()
                  , f = this.ticks.length + (h ? 1 : 0)
                  , m = Q(c)
                  , x = []
                  , y = c.setContext(this.getContext())
                  , _ = y.drawBorder ? y.borderWidth : 0
                  , v = _ / 2
                  , O = function(t) {
                    return Object(o.k)(n, t, _)
                };
                let w, i, M, j, k, S, P, C, D, A, T, L;
                if ("top" === l)
                    w = O(this.bottom),
                    S = this.bottom - m,
                    C = w - v,
                    A = O(t.top) + v,
                    L = t.bottom;
                else if ("bottom" === l)
                    w = O(this.top),
                    A = t.top,
                    L = O(t.bottom) - v,
                    S = w + v,
                    C = this.top + m;
                else if ("left" === l)
                    w = O(this.right),
                    k = this.right - m,
                    P = w - v,
                    D = O(t.left) + v,
                    T = t.right;
                else if ("right" === l)
                    w = O(this.left),
                    D = t.left,
                    T = O(t.right) - v,
                    k = w + v,
                    P = this.left + m;
                else if ("x" === e) {
                    if ("center" === l)
                        w = O((t.top + t.bottom) / 2 + .5);
                    else if (Object(o.Mb)(l)) {
                        const t = Object.keys(l)[0]
                          , e = l[t];
                        w = O(this.chart.scales[t].getPixelForValue(e))
                    }
                    A = t.top,
                    L = t.bottom,
                    S = w + v,
                    C = S + m
                } else if ("y" === e) {
                    if ("center" === l)
                        w = O((t.left + t.right) / 2);
                    else if (Object(o.Mb)(l)) {
                        const t = Object.keys(l)[0]
                          , e = l[t];
                        w = O(this.chart.scales[t].getPixelForValue(e))
                    }
                    k = w - v,
                    P = k - m,
                    D = t.left,
                    T = t.right
                }
                const E = Object(o.Zb)(r.ticks.maxTicksLimit, f)
                  , R = Math.max(1, Math.ceil(f / E));
                for (i = 0; i < f; i += R) {
                    const t = c.setContext(this.getContext(i))
                      , e = t.lineWidth
                      , r = t.color
                      , l = t.borderDash || []
                      , f = t.borderDashOffset
                      , m = t.tickWidth
                      , y = t.tickColor
                      , _ = t.tickBorderDash || []
                      , v = t.tickBorderDashOffset;
                    M = G(this, i, h),
                    void 0 !== M && (j = Object(o.k)(n, M, e),
                    d ? k = P = D = T = j : S = C = A = L = j,
                    x.push({
                        tx1: k,
                        ty1: S,
                        tx2: P,
                        ty2: C,
                        x1: D,
                        y1: A,
                        x2: T,
                        y2: L,
                        width: e,
                        color: r,
                        borderDash: l,
                        borderDashOffset: f,
                        tickWidth: m,
                        tickColor: y,
                        tickBorderDash: _,
                        tickBorderDashOffset: v
                    }))
                }
                return this._ticksLength = f,
                this._borderValue = w,
                x
            }
            _computeLabelItems(t) {
                const e = this.axis
                  , n = this.options
                  , {position: r, ticks: c} = n
                  , l = this.isHorizontal()
                  , h = this.ticks
                  , {align: d, crossAlign: f, padding: m, mirror: x} = c
                  , y = Q(n.grid)
                  , _ = y + m
                  , v = x ? -m : _
                  , O = -Object(o.Xb)(this.labelRotation)
                  , w = [];
                let i, M, j, label, k, S, P, C, D, A, T, L, E = "middle";
                if ("top" === r)
                    S = this.bottom - v,
                    P = this._getXAxisLabelAlignment();
                else if ("bottom" === r)
                    S = this.top + v,
                    P = this._getXAxisLabelAlignment();
                else if ("left" === r) {
                    const t = this._getYAxisLabelAlignment(y);
                    P = t.textAlign,
                    k = t.x
                } else if ("right" === r) {
                    const t = this._getYAxisLabelAlignment(y);
                    P = t.textAlign,
                    k = t.x
                } else if ("x" === e) {
                    if ("center" === r)
                        S = (t.top + t.bottom) / 2 + _;
                    else if (Object(o.Mb)(r)) {
                        const t = Object.keys(r)[0]
                          , e = r[t];
                        S = this.chart.scales[t].getPixelForValue(e) + _
                    }
                    P = this._getXAxisLabelAlignment()
                } else if ("y" === e) {
                    if ("center" === r)
                        k = (t.left + t.right) / 2 - _;
                    else if (Object(o.Mb)(r)) {
                        const t = Object.keys(r)[0]
                          , e = r[t];
                        k = this.chart.scales[t].getPixelForValue(e)
                    }
                    P = this._getYAxisLabelAlignment(y).textAlign
                }
                "y" === e && ("start" === d ? E = "top" : "end" === d && (E = "bottom"));
                const R = this._getLabelSizes();
                for (i = 0,
                M = h.length; i < M; ++i) {
                    j = h[i],
                    label = j.label;
                    const t = c.setContext(this.getContext(i));
                    C = this.getPixelForTick(i) + c.labelOffset,
                    D = this._resolveTickFontOptions(i),
                    A = D.lineHeight,
                    T = Object(o.Cb)(label) ? label.length : 1;
                    const e = T / 2
                      , n = t.color
                      , d = t.textStrokeColor
                      , m = t.textStrokeWidth;
                    let y, _ = P;
                    if (l ? (k = C,
                    "inner" === P && (_ = i === M - 1 ? this.options.reverse ? "left" : "right" : 0 === i ? this.options.reverse ? "right" : "left" : "center"),
                    L = "top" === r ? "near" === f || 0 !== O ? -T * A + A / 2 : "center" === f ? -R.highest.height / 2 - e * A + A : -R.highest.height + A / 2 : "near" === f || 0 !== O ? A / 2 : "center" === f ? R.highest.height / 2 - e * A : R.highest.height - T * A,
                    x && (L *= -1)) : (S = C,
                    L = (1 - T) * A / 2),
                    t.showLabelBackdrop) {
                        const e = Object(o.l)(t.backdropPadding)
                          , n = R.heights[i]
                          , r = R.widths[i];
                        let c = S + L - e.top
                          , l = k - e.left;
                        switch (E) {
                        case "middle":
                            c -= n / 2;
                            break;
                        case "bottom":
                            c -= n
                        }
                        switch (P) {
                        case "center":
                            l -= r / 2;
                            break;
                        case "right":
                            l -= r
                        }
                        y = {
                            left: l,
                            top: c,
                            width: r + e.width,
                            height: n + e.height,
                            color: t.backdropColor
                        }
                    }
                    w.push({
                        rotation: O,
                        label: label,
                        font: D,
                        color: n,
                        strokeColor: d,
                        strokeWidth: m,
                        textOffset: L,
                        textAlign: _,
                        textBaseline: E,
                        translation: [k, S],
                        backdrop: y
                    })
                }
                return w
            }
            _getXAxisLabelAlignment() {
                const {position: t, ticks: e} = this.options;
                if (-Object(o.Xb)(this.labelRotation))
                    return "top" === t ? "left" : "right";
                let n = "center";
                return "start" === e.align ? n = "left" : "end" === e.align ? n = "right" : "inner" === e.align && (n = "inner"),
                n
            }
            _getYAxisLabelAlignment(t) {
                const {position: e, ticks: {crossAlign: n, mirror: o, padding: r}} = this.options
                  , c = t + r
                  , l = this._getLabelSizes().widest.width;
                let h, d;
                return "left" === e ? o ? (d = this.right + r,
                "near" === n ? h = "left" : "center" === n ? (h = "center",
                d += l / 2) : (h = "right",
                d += l)) : (d = this.right - c,
                "near" === n ? h = "right" : "center" === n ? (h = "center",
                d -= l / 2) : (h = "left",
                d = this.left)) : "right" === e ? o ? (d = this.left + r,
                "near" === n ? h = "right" : "center" === n ? (h = "center",
                d -= l / 2) : (h = "left",
                d -= l)) : (d = this.left + c,
                "near" === n ? h = "left" : "center" === n ? (h = "center",
                d += l / 2) : (h = "right",
                d = this.right)) : h = "right",
                {
                    textAlign: h,
                    x: d
                }
            }
            _computeLabelArea() {
                if (this.options.ticks.mirror)
                    return;
                const t = this.chart
                  , e = this.options.position;
                return "left" === e || "right" === e ? {
                    top: 0,
                    left: this.left,
                    bottom: t.height,
                    right: this.right
                } : "top" === e || "bottom" === e ? {
                    top: this.top,
                    left: 0,
                    bottom: this.bottom,
                    right: t.width
                } : void 0
            }
            drawBackground() {
                const {ctx: t, options: {backgroundColor: e}, left: n, top: o, width: r, height: c} = this;
                e && (t.save(),
                t.fillStyle = e,
                t.fillRect(n, o, r, c),
                t.restore())
            }
            getLineWidthForValue(t) {
                const e = this.options.grid;
                if (!this._isVisible() || !e.display)
                    return 0;
                const n = this.ticks.findIndex((e=>e.value === t));
                if (n >= 0) {
                    return e.setContext(this.getContext(n)).lineWidth
                }
                return 0
            }
            drawGrid(t) {
                const e = this.options.grid
                  , n = this.ctx
                  , o = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
                let i, r;
                const c = (t,e,style)=>{
                    style.width && style.color && (n.save(),
                    n.lineWidth = style.width,
                    n.strokeStyle = style.color,
                    n.setLineDash(style.borderDash || []),
                    n.lineDashOffset = style.borderDashOffset,
                    n.beginPath(),
                    n.moveTo(t.x, t.y),
                    n.lineTo(e.x, e.y),
                    n.stroke(),
                    n.restore())
                }
                ;
                if (e.display)
                    for (i = 0,
                    r = o.length; i < r; ++i) {
                        const t = o[i];
                        e.drawOnChartArea && c({
                            x: t.x1,
                            y: t.y1
                        }, {
                            x: t.x2,
                            y: t.y2
                        }, t),
                        e.drawTicks && c({
                            x: t.tx1,
                            y: t.ty1
                        }, {
                            x: t.tx2,
                            y: t.ty2
                        }, {
                            color: t.tickColor,
                            width: t.tickWidth,
                            borderDash: t.tickBorderDash,
                            borderDashOffset: t.tickBorderDashOffset
                        })
                    }
            }
            drawBorder() {
                const {chart: t, ctx: e, options: {grid: n}} = this
                  , r = n.setContext(this.getContext())
                  , c = n.drawBorder ? r.borderWidth : 0;
                if (!c)
                    return;
                const l = n.setContext(this.getContext(0)).lineWidth
                  , h = this._borderValue;
                let d, f, m, x;
                this.isHorizontal() ? (d = Object(o.k)(t, this.left, c) - c / 2,
                f = Object(o.k)(t, this.right, l) + l / 2,
                m = x = h) : (m = Object(o.k)(t, this.top, c) - c / 2,
                x = Object(o.k)(t, this.bottom, l) + l / 2,
                d = f = h),
                e.save(),
                e.lineWidth = r.borderWidth,
                e.strokeStyle = r.borderColor,
                e.beginPath(),
                e.moveTo(d, m),
                e.lineTo(f, x),
                e.stroke(),
                e.restore()
            }
            drawLabels(t) {
                if (!this.options.ticks.display)
                    return;
                const e = this.ctx
                  , area = this._computeLabelArea();
                area && Object(o.m)(e, area);
                const n = this._labelItems || (this._labelItems = this._computeLabelItems(t));
                let i, r;
                for (i = 0,
                r = n.length; i < r; ++i) {
                    const t = n[i]
                      , r = t.font
                      , label = t.label;
                    t.backdrop && (e.fillStyle = t.backdrop.color,
                    e.fillRect(t.backdrop.left, t.backdrop.top, t.backdrop.width, t.backdrop.height));
                    let c = t.textOffset;
                    Object(o.n)(e, label, 0, c, r, t)
                }
                area && Object(o.o)(e)
            }
            drawTitle() {
                const {ctx: t, options: {position: e, title: title, reverse: n}} = this;
                if (!title.display)
                    return;
                const r = Object(o.p)(title.font)
                  , c = Object(o.l)(title.padding)
                  , l = title.align;
                let h = r.lineHeight / 2;
                "bottom" === e || "center" === e || Object(o.Mb)(e) ? (h += c.bottom,
                Object(o.Cb)(title.text) && (h += r.lineHeight * (title.text.length - 1))) : h += c.top;
                const {titleX: d, titleY: f, maxWidth: m, rotation: x} = function(t, e, n, r) {
                    const {top: c, left: l, bottom: h, right: d, chart: f} = t
                      , {chartArea: m, scales: x} = f;
                    let y, _, v, O = 0;
                    const w = h - c
                      , M = d - l;
                    if (t.isHorizontal()) {
                        if (_ = Object(o.t)(r, l, d),
                        Object(o.Mb)(n)) {
                            const t = Object.keys(n)[0]
                              , o = n[t];
                            v = x[t].getPixelForValue(o) + w - e
                        } else
                            v = "center" === n ? (m.bottom + m.top) / 2 + w - e : K(t, n, e);
                        y = d - l
                    } else {
                        if (Object(o.Mb)(n)) {
                            const t = Object.keys(n)[0]
                              , o = n[t];
                            _ = x[t].getPixelForValue(o) - M + e
                        } else
                            _ = "center" === n ? (m.left + m.right) / 2 - M + e : K(t, n, e);
                        v = Object(o.t)(r, h, c),
                        O = "left" === n ? -o.i : o.i
                    }
                    return {
                        titleX: _,
                        titleY: v,
                        maxWidth: y,
                        rotation: O
                    }
                }(this, h, e, l);
                Object(o.n)(t, title.text, 0, 0, r, {
                    color: title.color,
                    maxWidth: m,
                    rotation: x,
                    textAlign: et(l, e, n),
                    textBaseline: "middle",
                    translation: [d, f]
                })
            }
            draw(t) {
                this._isVisible() && (this.drawBackground(),
                this.drawGrid(t),
                this.drawBorder(),
                this.drawTitle(),
                this.drawLabels(t))
            }
            _layers() {
                const t = this.options
                  , e = t.ticks && t.ticks.z || 0
                  , n = Object(o.Zb)(t.grid && t.grid.z, -1);
                return this._isVisible() && this.draw === it.prototype.draw ? [{
                    z: n,
                    draw: t=>{
                        this.drawBackground(),
                        this.drawGrid(t),
                        this.drawTitle()
                    }
                }, {
                    z: n + 1,
                    draw: ()=>{
                        this.drawBorder()
                    }
                }, {
                    z: e,
                    draw: t=>{
                        this.drawLabels(t)
                    }
                }] : [{
                    z: e,
                    draw: t=>{
                        this.draw(t)
                    }
                }]
            }
            getMatchingVisibleMetas(t) {
                const e = this.chart.getSortedVisibleDatasetMetas()
                  , n = this.axis + "AxisID"
                  , o = [];
                let i, r;
                for (i = 0,
                r = e.length; i < r; ++i) {
                    const meta = e[i];
                    meta[n] !== this.id || t && meta.type !== t || o.push(meta)
                }
                return o
            }
            _resolveTickFontOptions(t) {
                const e = this.options.ticks.setContext(this.getContext(t));
                return Object(o.p)(e.font)
            }
            _maxDigits() {
                const t = this._resolveTickFontOptions(0).lineHeight;
                return (this.isHorizontal() ? this.width : this.height) / t
            }
        }
        class nt {
            constructor(t, e, n) {
                this.type = t,
                this.scope = e,
                this.override = n,
                this.items = Object.create(null)
            }
            isForType(t) {
                return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
            }
            register(t) {
                const e = Object.getPrototypeOf(t);
                let n;
                (function(t) {
                    return "id"in t && "defaults"in t
                }
                )(e) && (n = this.register(e));
                const r = this.items
                  , c = t.id
                  , l = this.scope + "." + c;
                if (!c)
                    throw new Error("class does not have id: " + t);
                return c in r || (r[c] = t,
                function(t, e, n) {
                    const r = Object(o.w)(Object.create(null), [n ? o.Hb.get(n) : {}, o.Hb.get(e), t.defaults]);
                    o.Hb.set(e, r),
                    t.defaultRoutes && function(t, e) {
                        Object.keys(e).forEach((n=>{
                            const r = n.split(".")
                              , c = r.pop()
                              , l = [t].concat(r).join(".")
                              , h = e[n].split(".")
                              , d = h.pop()
                              , f = h.join(".");
                            o.Hb.route(l, c, f, d)
                        }
                        ))
                    }(e, t.defaultRoutes);
                    t.descriptors && o.Hb.describe(e, t.descriptors)
                }(t, l, n),
                this.override && o.Hb.override(t.id, t.overrides)),
                l
            }
            get(t) {
                return this.items[t]
            }
            unregister(t) {
                const e = this.items
                  , n = t.id
                  , r = this.scope;
                n in e && delete e[n],
                r && n in o.Hb[r] && (delete o.Hb[r][n],
                this.override && delete o.v[n])
            }
        }
        var st = new class {
            constructor() {
                this.controllers = new nt(P,"datasets",!0),
                this.elements = new nt(Y,"elements"),
                this.plugins = new nt(Object,"plugins"),
                this.scales = new nt(it,"scales"),
                this._typedRegistries = [this.controllers, this.scales, this.elements]
            }
            add(...t) {
                this._each("register", t)
            }
            remove(...t) {
                this._each("unregister", t)
            }
            addControllers(...t) {
                this._each("register", t, this.controllers)
            }
            addElements(...t) {
                this._each("register", t, this.elements)
            }
            addPlugins(...t) {
                this._each("register", t, this.plugins)
            }
            addScales(...t) {
                this._each("register", t, this.scales)
            }
            getController(t) {
                return this._get(t, this.controllers, "controller")
            }
            getElement(t) {
                return this._get(t, this.elements, "element")
            }
            getPlugin(t) {
                return this._get(t, this.plugins, "plugin")
            }
            getScale(t) {
                return this._get(t, this.scales, "scale")
            }
            removeControllers(...t) {
                this._each("unregister", t, this.controllers)
            }
            removeElements(...t) {
                this._each("unregister", t, this.elements)
            }
            removePlugins(...t) {
                this._each("unregister", t, this.plugins)
            }
            removeScales(...t) {
                this._each("unregister", t, this.scales)
            }
            _each(t, e, n) {
                [...e].forEach((e=>{
                    const r = n || this._getRegistryForType(e);
                    n || r.isForType(e) || r === this.plugins && e.id ? this._exec(t, r, e) : Object(o.r)(e, (e=>{
                        const o = n || this._getRegistryForType(e);
                        this._exec(t, o, e)
                    }
                    ))
                }
                ))
            }
            _exec(t, e, component) {
                const n = Object(o.x)(t);
                Object(o.d)(component["before" + n], [], component),
                e[t](component),
                Object(o.d)(component["after" + n], [], component)
            }
            _getRegistryForType(t) {
                for (let i = 0; i < this._typedRegistries.length; i++) {
                    const e = this._typedRegistries[i];
                    if (e.isForType(t))
                        return e
                }
                return this.plugins
            }
            _get(t, e, n) {
                const o = e.get(t);
                if (void 0 === o)
                    throw new Error('"' + t + '" is not a registered ' + n + ".");
                return o
            }
        }
        ;
        class ot extends P {
            update(t) {
                const meta = this._cachedMeta
                  , {data: e=[]} = meta
                  , n = this.chart._animationsDisabled;
                let {start: r, count: c} = Object(o.Ub)(meta, e, n);
                if (this._drawStart = r,
                this._drawCount = c,
                Object(o.ac)(meta) && (r = 0,
                c = e.length),
                this.options.showLine) {
                    const {dataset: line, _dataset: o} = meta;
                    line._chart = this.chart,
                    line._datasetIndex = this.index,
                    line._decimated = !!o._decimated,
                    line.points = e;
                    const r = this.resolveDatasetElementOptions(t);
                    r.segment = this.options.segment,
                    this.updateElement(line, void 0, {
                        animated: !n,
                        options: r
                    }, t)
                }
                this.updateElements(e, r, c, t)
            }
            addElements() {
                const {showLine: t} = this.options;
                !this.datasetElementType && t && (this.datasetElementType = st.getElement("line")),
                super.addElements()
            }
            updateElements(t, e, n, r) {
                const c = "reset" === r
                  , {iScale: l, vScale: h, _stacked: d, _dataset: f} = this._cachedMeta
                  , m = this.resolveDataElementOptions(e, r)
                  , x = this.getSharedOptions(m)
                  , y = this.includeOptions(r, x)
                  , _ = l.axis
                  , v = h.axis
                  , {spanGaps: O, segment: w} = this.options
                  , M = Object(o.bc)(O) ? O : Number.POSITIVE_INFINITY
                  , j = this.chart._animationsDisabled || c || "none" === r;
                let k = e > 0 && this.getParsed(e - 1);
                for (let i = e; i < e + n; ++i) {
                    const e = t[i]
                      , n = this.getParsed(i)
                      , m = j ? e : {}
                      , O = Object(o.Ob)(n[v])
                      , S = m[_] = l.getPixelForValue(n[_], i)
                      , P = m[v] = c || O ? h.getBasePixel() : h.getPixelForValue(d ? this.applyStack(h, n, d) : n[v], i);
                    m.skip = isNaN(S) || isNaN(P) || O,
                    m.stop = i > 0 && Math.abs(n[_] - k[_]) > M,
                    w && (m.parsed = n,
                    m.raw = f.data[i]),
                    y && (m.options = x || this.resolveDataElementOptions(i, e.active ? "active" : r)),
                    j || this.updateElement(e, i, m, r),
                    k = n
                }
                this.updateSharedOptions(x, r, m)
            }
            getMaxOverflow() {
                const meta = this._cachedMeta
                  , data = meta.data || [];
                if (!this.options.showLine) {
                    let t = 0;
                    for (let i = data.length - 1; i >= 0; --i)
                        t = Math.max(t, data[i].size(this.resolveDataElementOptions(i)) / 2);
                    return t > 0 && t
                }
                const t = meta.dataset
                  , e = t.options && t.options.borderWidth || 0;
                if (!data.length)
                    return e;
                const n = data[0].size(this.resolveDataElementOptions(0))
                  , o = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(e, n, o) / 2
            }
        }
        ot.id = "scatter",
        ot.defaults = {
            datasetElementType: !1,
            dataElementType: "point",
            showLine: !1,
            fill: !1
        },
        ot.overrides = {
            interaction: {
                mode: "point"
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        title: ()=>"",
                        label: t=>"(" + t.label + ", " + t.formattedValue + ")"
                    }
                }
            },
            scales: {
                x: {
                    type: "linear"
                },
                y: {
                    type: "linear"
                }
            }
        };
        var at = Object.freeze({
            __proto__: null,
            BarController: z,
            BubbleController: F,
            DoughnutController: W,
            LineController: V,
            PolarAreaController: N,
            PieController: B,
            RadarController: H,
            ScatterController: ot
        });
        function ct() {
            throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
        }
        class lt {
            constructor(t) {
                this.options = t || {}
            }
            init(t) {}
            formats() {
                return ct()
            }
            parse(t, e) {
                return ct()
            }
            format(t, e) {
                return ct()
            }
            add(t, e, n) {
                return ct()
            }
            diff(a, b, t) {
                return ct()
            }
            startOf(t, e, n) {
                return ct()
            }
            endOf(t, e) {
                return ct()
            }
        }
        lt.override = function(t) {
            Object.assign(lt.prototype, t)
        }
        ;
        var ht = {
            _date: lt
        };
        function ut(t, e, n, r) {
            const {controller: c, data: data, _sorted: l} = t
              , h = c._cachedMeta.iScale;
            if (h && e === h.axis && "r" !== e && l && data.length) {
                const t = h._reversePixels ? o.z : o.A;
                if (!r)
                    return t(data, e, n);
                if (c._sharedOptions) {
                    const o = data[0]
                      , r = "function" == typeof o.getRange && o.getRange(e);
                    if (r) {
                        const o = t(data, e, n - r)
                          , c = t(data, e, n + r);
                        return {
                            lo: o.lo,
                            hi: c.hi
                        }
                    }
                }
            }
            return {
                lo: 0,
                hi: data.length - 1
            }
        }
        function ft(t, e, n, o, r) {
            const c = t.getSortedVisibleDatasetMetas()
              , l = n[e];
            for (let i = 0, t = c.length; i < t; ++i) {
                const {index: t, data: data} = c[i]
                  , {lo: n, hi: h} = ut(c[i], e, l, r);
                for (let e = n; e <= h; ++e) {
                    const element = data[e];
                    element.skip || o(element, t, e)
                }
            }
        }
        function bt(t, e, n, r, c) {
            const l = [];
            if (!c && !t.isPointInArea(e))
                return l;
            return ft(t, n, e, (function(element, n, h) {
                (c || Object(o.a)(element, t.chartArea, 0)) && element.inRange(e.x, e.y, r) && l.push({
                    element: element,
                    datasetIndex: n,
                    index: h
                })
            }
            ), !0),
            l
        }
        function gt(t, e, n, o, r, c) {
            let l = [];
            const h = function(t) {
                const e = -1 !== t.indexOf("x")
                  , n = -1 !== t.indexOf("y");
                return function(t, o) {
                    const r = e ? Math.abs(t.x - o.x) : 0
                      , c = n ? Math.abs(t.y - o.y) : 0;
                    return Math.sqrt(Math.pow(r, 2) + Math.pow(c, 2))
                }
            }(n);
            let d = Number.POSITIVE_INFINITY;
            return ft(t, n, e, (function(element, n, f) {
                const m = element.inRange(e.x, e.y, r);
                if (o && !m)
                    return;
                const x = element.getCenterPoint(r);
                if (!(!!c || t.isPointInArea(x)) && !m)
                    return;
                const y = h(e, x);
                y < d ? (l = [{
                    element: element,
                    datasetIndex: n,
                    index: f
                }],
                d = y) : y === d && l.push({
                    element: element,
                    datasetIndex: n,
                    index: f
                })
            }
            )),
            l
        }
        function pt(t, e, n, r, c, l) {
            return l || t.isPointInArea(e) ? "r" !== n || r ? gt(t, e, n, r, c, l) : function(t, e, n, r) {
                let c = [];
                return ft(t, n, e, (function(element, t, n) {
                    const {startAngle: l, endAngle: h} = element.getProps(["startAngle", "endAngle"], r)
                      , {angle: d} = Object(o.D)(element, {
                        x: e.x,
                        y: e.y
                    });
                    Object(o.Tb)(d, l, h) && c.push({
                        element: element,
                        datasetIndex: t,
                        index: n
                    })
                }
                )),
                c
            }(t, e, n, c) : []
        }
        function mt(t, e, n, o, r) {
            const c = []
              , l = "x" === n ? "inXRange" : "inYRange";
            let h = !1;
            return ft(t, n, e, ((element,t,o)=>{
                element[l](e[n], r) && (c.push({
                    element: element,
                    datasetIndex: t,
                    index: o
                }),
                h = h || element.inRange(e.x, e.y, r))
            }
            )),
            o && !h ? [] : c
        }
        var xt = {
            evaluateInteractionItems: ft,
            modes: {
                index(t, e, n, r) {
                    const c = Object(o.y)(e, t)
                      , l = n.axis || "x"
                      , h = n.includeInvisible || !1
                      , d = n.intersect ? bt(t, c, l, r, h) : pt(t, c, l, !1, r, h)
                      , f = [];
                    return d.length ? (t.getSortedVisibleDatasetMetas().forEach((meta=>{
                        const t = d[0].index
                          , element = meta.data[t];
                        element && !element.skip && f.push({
                            element: element,
                            datasetIndex: meta.index,
                            index: t
                        })
                    }
                    )),
                    f) : []
                },
                dataset(t, e, n, r) {
                    const c = Object(o.y)(e, t)
                      , l = n.axis || "xy"
                      , h = n.includeInvisible || !1;
                    let d = n.intersect ? bt(t, c, l, r, h) : pt(t, c, l, !1, r, h);
                    if (d.length > 0) {
                        const e = d[0].datasetIndex
                          , data = t.getDatasetMeta(e).data;
                        d = [];
                        for (let i = 0; i < data.length; ++i)
                            d.push({
                                element: data[i],
                                datasetIndex: e,
                                index: i
                            })
                    }
                    return d
                },
                point: (t,e,n,r)=>bt(t, Object(o.y)(e, t), n.axis || "xy", r, n.includeInvisible || !1),
                nearest(t, e, n, r) {
                    const c = Object(o.y)(e, t)
                      , l = n.axis || "xy"
                      , h = n.includeInvisible || !1;
                    return pt(t, c, l, n.intersect, r, h)
                },
                x: (t,e,n,r)=>mt(t, Object(o.y)(e, t), "x", n.intersect, r),
                y: (t,e,n,r)=>mt(t, Object(o.y)(e, t), "y", n.intersect, r)
            }
        };
        const yt = ["left", "top", "right", "bottom"];
        function _t(t, e) {
            return t.filter((t=>t.pos === e))
        }
        function vt(t, e) {
            return t.filter((t=>-1 === yt.indexOf(t.pos) && t.box.axis === e))
        }
        function Ot(t, e) {
            return t.sort(((a,b)=>{
                const t = e ? b : a
                  , n = e ? a : b;
                return t.weight === n.weight ? t.index - n.index : t.weight - n.weight
            }
            ))
        }
        function wt(t, e) {
            const n = function(t) {
                const e = {};
                for (const n of t) {
                    const {stack: t, pos: o, stackWeight: r} = n;
                    if (!t || !yt.includes(o))
                        continue;
                    const c = e[t] || (e[t] = {
                        count: 0,
                        placed: 0,
                        weight: 0,
                        size: 0
                    });
                    c.count++,
                    c.weight += r
                }
                return e
            }(t)
              , {vBoxMaxWidth: o, hBoxMaxHeight: r} = e;
            let i, c, l;
            for (i = 0,
            c = t.length; i < c; ++i) {
                l = t[i];
                const {fullSize: c} = l.box
                  , h = n[l.stack]
                  , d = h && l.stackWeight / h.weight;
                l.horizontal ? (l.width = d ? d * o : c && e.availableWidth,
                l.height = r) : (l.width = o,
                l.height = d ? d * r : c && e.availableHeight)
            }
            return n
        }
        function Mt(t, e, a, b) {
            return Math.max(t[a], e[a]) + Math.max(t[b], e[b])
        }
        function jt(t, e) {
            t.top = Math.max(t.top, e.top),
            t.left = Math.max(t.left, e.left),
            t.bottom = Math.max(t.bottom, e.bottom),
            t.right = Math.max(t.right, e.right)
        }
        function kt(t, e, n, r) {
            const {pos: c, box: l} = n
              , h = t.maxPadding;
            if (!Object(o.Mb)(c)) {
                n.size && (t[c] -= n.size);
                const e = r[n.stack] || {
                    size: 0,
                    count: 1
                };
                e.size = Math.max(e.size, n.horizontal ? l.height : l.width),
                n.size = e.size / e.count,
                t[c] += n.size
            }
            l.getPadding && jt(h, l.getPadding());
            const d = Math.max(0, e.outerWidth - Mt(h, t, "left", "right"))
              , f = Math.max(0, e.outerHeight - Mt(h, t, "top", "bottom"))
              , m = d !== t.w
              , x = f !== t.h;
            return t.w = d,
            t.h = f,
            n.horizontal ? {
                same: m,
                other: x
            } : {
                same: x,
                other: m
            }
        }
        function St(t, e) {
            const n = e.maxPadding;
            function o(t) {
                const o = {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                };
                return t.forEach((t=>{
                    o[t] = Math.max(e[t], n[t])
                }
                )),
                o
            }
            return o(t ? ["left", "right"] : ["top", "bottom"])
        }
        function Pt(t, e, n, o) {
            const r = [];
            let i, c, l, h, d, f;
            for (i = 0,
            c = t.length,
            d = 0; i < c; ++i) {
                l = t[i],
                h = l.box,
                h.update(l.width || e.w, l.height || e.h, St(l.horizontal, e));
                const {same: c, other: m} = kt(e, n, l, o);
                d |= c && r.length,
                f = f || m,
                h.fullSize || r.push(l)
            }
            return d && Pt(r, e, n, o) || f
        }
        function Ct(t, e, n, o, r) {
            t.top = n,
            t.left = e,
            t.right = e + o,
            t.bottom = n + r,
            t.width = o,
            t.height = r
        }
        function Dt(t, e, n, r) {
            const c = n.padding;
            let {x: l, y: h} = e;
            for (const d of t) {
                const t = d.box
                  , f = r[d.stack] || {
                    count: 1,
                    placed: 0,
                    weight: 1
                }
                  , m = d.stackWeight / f.weight || 1;
                if (d.horizontal) {
                    const r = e.w * m
                      , l = f.size || t.height;
                    Object(o.Nb)(f.start) && (h = f.start),
                    t.fullSize ? Ct(t, c.left, h, n.outerWidth - c.right - c.left, l) : Ct(t, e.left + f.placed, h, r, l),
                    f.start = h,
                    f.placed += r,
                    h = t.bottom
                } else {
                    const r = e.h * m
                      , h = f.size || t.width;
                    Object(o.Nb)(f.start) && (l = f.start),
                    t.fullSize ? Ct(t, l, c.top, h, n.outerHeight - c.bottom - c.top) : Ct(t, l, e.top + f.placed, h, r),
                    f.start = l,
                    f.placed += r,
                    l = t.right
                }
            }
            e.x = l,
            e.y = h
        }
        o.Hb.set("layout", {
            autoPadding: !0,
            padding: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }
        });
        var At = {
            addBox(t, e) {
                t.boxes || (t.boxes = []),
                e.fullSize = e.fullSize || !1,
                e.position = e.position || "top",
                e.weight = e.weight || 0,
                e._layers = e._layers || function() {
                    return [{
                        z: 0,
                        draw(t) {
                            e.draw(t)
                        }
                    }]
                }
                ,
                t.boxes.push(e)
            },
            removeBox(t, e) {
                const n = t.boxes ? t.boxes.indexOf(e) : -1;
                -1 !== n && t.boxes.splice(n, 1)
            },
            configure(t, e, n) {
                e.fullSize = n.fullSize,
                e.position = n.position,
                e.weight = n.weight
            },
            update(t, e, n, r) {
                if (!t)
                    return;
                const c = Object(o.l)(t.options.layout.padding)
                  , l = Math.max(e - c.width, 0)
                  , h = Math.max(n - c.height, 0)
                  , d = function(t) {
                    const e = function(t) {
                        const e = [];
                        let i, n, o, r, c, l;
                        for (i = 0,
                        n = (t || []).length; i < n; ++i)
                            o = t[i],
                            ({position: r, options: {stack: c, stackWeight: l=1}} = o),
                            e.push({
                                index: i,
                                box: o,
                                pos: r,
                                horizontal: o.isHorizontal(),
                                weight: o.weight,
                                stack: c && r + c,
                                stackWeight: l
                            });
                        return e
                    }(t)
                      , n = Ot(e.filter((t=>t.box.fullSize)), !0)
                      , o = Ot(_t(e, "left"), !0)
                      , r = Ot(_t(e, "right"))
                      , c = Ot(_t(e, "top"), !0)
                      , l = Ot(_t(e, "bottom"))
                      , h = vt(e, "x")
                      , d = vt(e, "y");
                    return {
                        fullSize: n,
                        leftAndTop: o.concat(c),
                        rightAndBottom: r.concat(d).concat(l).concat(h),
                        chartArea: _t(e, "chartArea"),
                        vertical: o.concat(r).concat(d),
                        horizontal: c.concat(l).concat(h)
                    }
                }(t.boxes)
                  , f = d.vertical
                  , m = d.horizontal;
                Object(o.r)(t.boxes, (t=>{
                    "function" == typeof t.beforeLayout && t.beforeLayout()
                }
                ));
                const x = f.reduce(((t,e)=>e.box.options && !1 === e.box.options.display ? t : t + 1), 0) || 1
                  , y = Object.freeze({
                    outerWidth: e,
                    outerHeight: n,
                    padding: c,
                    availableWidth: l,
                    availableHeight: h,
                    vBoxMaxWidth: l / 2 / x,
                    hBoxMaxHeight: h / 2
                })
                  , _ = Object.assign({}, c);
                jt(_, Object(o.l)(r));
                const v = Object.assign({
                    maxPadding: _,
                    w: l,
                    h: h,
                    x: c.left,
                    y: c.top
                }, c)
                  , O = wt(f.concat(m), y);
                Pt(d.fullSize, v, y, O),
                Pt(f, v, y, O),
                Pt(m, v, y, O) && Pt(f, v, y, O),
                function(t) {
                    const e = t.maxPadding;
                    function n(n) {
                        const o = Math.max(e[n] - t[n], 0);
                        return t[n] += o,
                        o
                    }
                    t.y += n("top"),
                    t.x += n("left"),
                    n("right"),
                    n("bottom")
                }(v),
                Dt(d.leftAndTop, v, y, O),
                v.x += v.w,
                v.y += v.h,
                Dt(d.rightAndBottom, v, y, O),
                t.chartArea = {
                    left: v.left,
                    top: v.top,
                    right: v.left + v.w,
                    bottom: v.top + v.h,
                    height: v.h,
                    width: v.w
                },
                Object(o.r)(d.chartArea, (e=>{
                    const n = e.box;
                    Object.assign(n, t.chartArea),
                    n.update(v.w, v.h, {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    })
                }
                ))
            }
        };
        class Tt {
            acquireContext(canvas, t) {}
            releaseContext(t) {
                return !1
            }
            addEventListener(t, e, n) {}
            removeEventListener(t, e, n) {}
            getDevicePixelRatio() {
                return 1
            }
            getMaximumSize(element, t, e, n) {
                return t = Math.max(0, t || element.width),
                e = e || element.height,
                {
                    width: t,
                    height: Math.max(0, n ? Math.floor(t / n) : e)
                }
            }
            isAttached(canvas) {
                return !0
            }
            updateConfig(t) {}
        }
        class Lt extends Tt {
            acquireContext(t) {
                return t && t.getContext && t.getContext("2d") || null
            }
            updateConfig(t) {
                t.options.animation = !1
            }
        }
        const Et = "$chartjs"
          , Rt = {
            touchstart: "mousedown",
            touchmove: "mousemove",
            touchend: "mouseup",
            pointerenter: "mouseenter",
            pointerdown: "mousedown",
            pointermove: "mousemove",
            pointerup: "mouseup",
            pointerleave: "mouseout",
            pointerout: "mouseout"
        }
          , It = t=>null === t || "" === t;
        const zt = !!o.I && {
            passive: !0
        };
        function Ft(t, e, n) {
            t.canvas.removeEventListener(e, n, zt)
        }
        function Wt(t, canvas) {
            for (const e of t)
                if (e === canvas || e.contains(canvas))
                    return !0
        }
        function Vt(t, e, n) {
            const canvas = t.canvas
              , o = new MutationObserver((t=>{
                let e = !1;
                for (const n of t)
                    e = e || Wt(n.addedNodes, canvas),
                    e = e && !Wt(n.removedNodes, canvas);
                e && n()
            }
            ));
            return o.observe(document, {
                childList: !0,
                subtree: !0
            }),
            o
        }
        function Nt(t, e, n) {
            const canvas = t.canvas
              , o = new MutationObserver((t=>{
                let e = !1;
                for (const n of t)
                    e = e || Wt(n.removedNodes, canvas),
                    e = e && !Wt(n.addedNodes, canvas);
                e && n()
            }
            ));
            return o.observe(document, {
                childList: !0,
                subtree: !0
            }),
            o
        }
        const Bt = new Map;
        let Ht = 0;
        function Yt() {
            const t = window.devicePixelRatio;
            t !== Ht && (Ht = t,
            Bt.forEach(((e,n)=>{
                n.currentDevicePixelRatio !== t && e()
            }
            )))
        }
        function Xt(t, e, n) {
            const canvas = t.canvas
              , r = canvas && Object(o.F)(canvas);
            if (!r)
                return;
            const c = Object(o.H)(((t,e)=>{
                const o = r.clientWidth;
                n(t, e),
                o < r.clientWidth && n()
            }
            ), window)
              , l = new ResizeObserver((t=>{
                const e = t[0]
                  , n = e.contentRect.width
                  , o = e.contentRect.height;
                0 === n && 0 === o || c(n, o)
            }
            ));
            return l.observe(r),
            function(t, e) {
                Bt.size || window.addEventListener("resize", Yt),
                Bt.set(t, e)
            }(t, c),
            l
        }
        function $t(t, e, n) {
            n && n.disconnect(),
            "resize" === e && function(t) {
                Bt.delete(t),
                Bt.size || window.removeEventListener("resize", Yt)
            }(t)
        }
        function Ut(t, e, n) {
            const canvas = t.canvas
              , r = Object(o.H)((e=>{
                null !== t.ctx && n(function(t, e) {
                    const n = Rt[t.type] || t.type
                      , {x: r, y: c} = Object(o.y)(t, e);
                    return {
                        type: n,
                        chart: e,
                        native: t,
                        x: void 0 !== r ? r : null,
                        y: void 0 !== c ? c : null
                    }
                }(e, t))
            }
            ), t, (t=>{
                const e = t[0];
                return [e, e.offsetX, e.offsetY]
            }
            ));
            return function(t, e, n) {
                t.addEventListener(e, n, zt)
            }(canvas, e, r),
            r
        }
        class Zt extends Tt {
            acquireContext(canvas, t) {
                const e = canvas && canvas.getContext && canvas.getContext("2d");
                return e && e.canvas === canvas ? (function(canvas, t) {
                    const style = canvas.style
                      , e = canvas.getAttribute("height")
                      , n = canvas.getAttribute("width");
                    if (canvas[Et] = {
                        initial: {
                            height: e,
                            width: n,
                            style: {
                                display: style.display,
                                height: style.height,
                                width: style.width
                            }
                        }
                    },
                    style.display = style.display || "block",
                    style.boxSizing = style.boxSizing || "border-box",
                    It(n)) {
                        const t = Object(o.G)(canvas, "width");
                        void 0 !== t && (canvas.width = t)
                    }
                    if (It(e))
                        if ("" === canvas.style.height)
                            canvas.height = canvas.width / (t || 2);
                        else {
                            const t = Object(o.G)(canvas, "height");
                            void 0 !== t && (canvas.height = t)
                        }
                }(canvas, t),
                e) : null
            }
            releaseContext(t) {
                const canvas = t.canvas;
                if (!canvas[Et])
                    return !1;
                const e = canvas[Et].initial;
                ["height", "width"].forEach((t=>{
                    const n = e[t];
                    Object(o.Ob)(n) ? canvas.removeAttribute(t) : canvas.setAttribute(t, n)
                }
                ));
                const style = e.style || {};
                return Object.keys(style).forEach((t=>{
                    canvas.style[t] = style[t]
                }
                )),
                canvas.width = canvas.width,
                delete canvas[Et],
                !0
            }
            addEventListener(t, e, n) {
                this.removeEventListener(t, e);
                const o = t.$proxies || (t.$proxies = {})
                  , r = {
                    attach: Vt,
                    detach: Nt,
                    resize: Xt
                }[e] || Ut;
                o[e] = r(t, e, n)
            }
            removeEventListener(t, e) {
                const n = t.$proxies || (t.$proxies = {})
                  , o = n[e];
                if (!o)
                    return;
                ({
                    attach: $t,
                    detach: $t,
                    resize: $t
                }[e] || Ft)(t, e, o),
                n[e] = void 0
            }
            getDevicePixelRatio() {
                return window.devicePixelRatio
            }
            getMaximumSize(canvas, t, e, n) {
                return Object(o.E)(canvas, t, e, n)
            }
            isAttached(canvas) {
                const t = Object(o.F)(canvas);
                return !(!t || !t.isConnected)
            }
        }
        class qt {
            constructor() {
                this._init = []
            }
            notify(t, e, n, filter) {
                "beforeInit" === e && (this._init = this._createDescriptors(t, !0),
                this._notify(this._init, t, "install"));
                const o = filter ? this._descriptors(t).filter(filter) : this._descriptors(t)
                  , r = this._notify(o, t, e, n);
                return "afterDestroy" === e && (this._notify(o, t, "stop"),
                this._notify(this._init, t, "uninstall")),
                r
            }
            _notify(t, e, n, r) {
                r = r || {};
                for (const c of t) {
                    const t = c.plugin
                      , l = t[n]
                      , h = [e, r, c.options];
                    if (!1 === Object(o.d)(l, h, t) && r.cancelable)
                        return !1
                }
                return !0
            }
            invalidate() {
                Object(o.Ob)(this._cache) || (this._oldCache = this._cache,
                this._cache = void 0)
            }
            _descriptors(t) {
                if (this._cache)
                    return this._cache;
                const e = this._cache = this._createDescriptors(t);
                return this._notifyStateChanges(t),
                e
            }
            _createDescriptors(t, e) {
                const n = t && t.config
                  , r = Object(o.Zb)(n.options && n.options.plugins, {})
                  , c = function(t) {
                    const e = {}
                      , n = []
                      , o = Object.keys(st.plugins.items);
                    for (let i = 0; i < o.length; i++)
                        n.push(st.getPlugin(o[i]));
                    const r = t.plugins || [];
                    for (let i = 0; i < r.length; i++) {
                        const t = r[i];
                        -1 === n.indexOf(t) && (n.push(t),
                        e[t.id] = !0)
                    }
                    return {
                        plugins: n,
                        localIds: e
                    }
                }(n);
                return !1 !== r || e ? function(t, {plugins: e, localIds: n}, o, r) {
                    const c = []
                      , l = t.getContext();
                    for (const h of e) {
                        const e = h.id
                          , d = Kt(o[e], r);
                        null !== d && c.push({
                            plugin: h,
                            options: Jt(t.config, {
                                plugin: h,
                                local: n[e]
                            }, d, l)
                        })
                    }
                    return c
                }(t, c, r, e) : []
            }
            _notifyStateChanges(t) {
                const e = this._oldCache || []
                  , n = this._cache
                  , o = (a,b)=>a.filter((t=>!b.some((e=>t.plugin.id === e.plugin.id))));
                this._notify(o(e, n), t, "stop"),
                this._notify(o(n, e), t, "start")
            }
        }
        function Kt(t, e) {
            return e || !1 !== t ? !0 === t ? {} : t : null
        }
        function Jt(t, {plugin: e, local: n}, o, r) {
            const c = t.pluginScopeKeys(e)
              , l = t.getOptionScopes(o, c);
            return n && e.defaults && l.push(e.defaults),
            t.createResolver(l, r, [""], {
                scriptable: !1,
                indexable: !1,
                allKeys: !0
            })
        }
        function Gt(t, e) {
            const n = o.Hb.datasets[t] || {};
            return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x"
        }
        function Qt(t, e) {
            return "x" === t || "y" === t ? t : e.axis || ("top" === (n = e.position) || "bottom" === n ? "x" : "left" === n || "right" === n ? "y" : void 0) || t.charAt(0).toLowerCase();
            var n
        }
        function te(t) {
            const e = t.options || (t.options = {});
            e.plugins = Object(o.Zb)(e.plugins, {}),
            e.scales = function(t, e) {
                const n = o.v[t.type] || {
                    scales: {}
                }
                  , r = e.scales || {}
                  , c = Gt(t.type, e)
                  , l = Object.create(null)
                  , h = Object.create(null);
                return Object.keys(r).forEach((t=>{
                    const e = r[t];
                    if (!Object(o.Mb)(e))
                        return console.error(`Invalid scale configuration for scale: ${t}`);
                    if (e._proxy)
                        return console.warn(`Ignoring resolver passed as options for scale: ${t}`);
                    const d = Qt(t, e)
                      , f = function(t, e) {
                        return t === e ? "_index_" : "_value_"
                    }(d, c)
                      , m = n.scales || {};
                    l[d] = l[d] || t,
                    h[t] = Object(o.eb)(Object.create(null), [{
                        axis: d
                    }, e, m[d], m[f]])
                }
                )),
                t.data.datasets.forEach((n=>{
                    const c = n.type || t.type
                      , d = n.indexAxis || Gt(c, e)
                      , f = (o.v[c] || {}).scales || {};
                    Object.keys(f).forEach((t=>{
                        const e = function(t, e) {
                            let n = t;
                            return "_index_" === t ? n = e : "_value_" === t && (n = "x" === e ? "y" : "x"),
                            n
                        }(t, d)
                          , c = n[e + "AxisID"] || l[e] || e;
                        h[c] = h[c] || Object.create(null),
                        Object(o.eb)(h[c], [{
                            axis: e
                        }, r[c], f[t]])
                    }
                    ))
                }
                )),
                Object.keys(h).forEach((t=>{
                    const e = h[t];
                    Object(o.eb)(e, [o.Hb.scales[e.type], o.Hb.scale])
                }
                )),
                h
            }(t, e)
        }
        function ee(data) {
            return (data = data || {}).datasets = data.datasets || [],
            data.labels = data.labels || [],
            data
        }
        const ie = new Map
          , ne = new Set;
        function se(t, e) {
            let n = ie.get(t);
            return n || (n = e(),
            ie.set(t, n),
            ne.add(n)),
            n
        }
        const oe = (t,e,n)=>{
            const r = Object(o.Jb)(e, n);
            void 0 !== r && t.add(r)
        }
        ;
        class re {
            constructor(t) {
                this._config = function(t) {
                    return (t = t || {}).data = ee(t.data),
                    te(t),
                    t
                }(t),
                this._scopeCache = new Map,
                this._resolverCache = new Map
            }
            get platform() {
                return this._config.platform
            }
            get type() {
                return this._config.type
            }
            set type(t) {
                this._config.type = t
            }
            get data() {
                return this._config.data
            }
            set data(data) {
                this._config.data = ee(data)
            }
            get options() {
                return this._config.options
            }
            set options(t) {
                this._config.options = t
            }
            get plugins() {
                return this._config.plugins
            }
            update() {
                const t = this._config;
                this.clearCache(),
                te(t)
            }
            clearCache() {
                this._scopeCache.clear(),
                this._resolverCache.clear()
            }
            datasetScopeKeys(t) {
                return se(t, (()=>[[`datasets.${t}`, ""]]))
            }
            datasetAnimationScopeKeys(t, e) {
                return se(`${t}.transition.${e}`, (()=>[[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]]))
            }
            datasetElementScopeKeys(t, e) {
                return se(`${t}-${e}`, (()=>[[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]]))
            }
            pluginScopeKeys(t) {
                const e = t.id;
                return se(`${this.type}-plugin-${e}`, (()=>[[`plugins.${e}`, ...t.additionalOptionScopes || []]]))
            }
            _cachedScopes(t, e) {
                const n = this._scopeCache;
                let o = n.get(t);
                return o && !e || (o = new Map,
                n.set(t, o)),
                o
            }
            getOptionScopes(t, e, n) {
                const {options: r, type: c} = this
                  , l = this._cachedScopes(t, n)
                  , h = l.get(e);
                if (h)
                    return h;
                const d = new Set;
                e.forEach((e=>{
                    t && (d.add(t),
                    e.forEach((e=>oe(d, t, e)))),
                    e.forEach((t=>oe(d, r, t))),
                    e.forEach((t=>oe(d, o.v[c] || {}, t))),
                    e.forEach((t=>oe(d, o.Hb, t))),
                    e.forEach((t=>oe(d, o.K, t)))
                }
                ));
                const f = Array.from(d);
                return 0 === f.length && f.push(Object.create(null)),
                ne.has(e) && l.set(e, f),
                f
            }
            chartOptionScopes() {
                const {options: t, type: e} = this;
                return [t, o.v[e] || {}, o.Hb.datasets[e] || {}, {
                    type: e
                }, o.Hb, o.K]
            }
            resolveNamedOptions(t, e, n, r=[""]) {
                const c = {
                    $shared: !0
                }
                  , {resolver: l, subPrefixes: h} = ae(this._resolverCache, t, r);
                let d = l;
                if (function(t, e) {
                    const {isScriptable: n, isIndexable: r} = Object(o.db)(t);
                    for (const c of e) {
                        const e = n(c)
                          , l = r(c)
                          , h = (l || e) && t[c];
                        if (e && (Object(o.L)(h) || ce(h)) || l && Object(o.Cb)(h))
                            return !0
                    }
                    return !1
                }(l, e)) {
                    c.$shared = !1,
                    n = Object(o.L)(n) ? n() : n;
                    const e = this.createResolver(t, n, h);
                    d = Object(o.M)(l, n, e)
                }
                for (const t of e)
                    c[t] = d[t];
                return c
            }
            createResolver(t, e, n=[""], r) {
                const {resolver: c} = ae(this._resolverCache, t, n);
                return Object(o.Mb)(e) ? Object(o.M)(c, e, void 0, r) : c
            }
        }
        function ae(t, e, n) {
            let r = t.get(e);
            r || (r = new Map,
            t.set(e, r));
            const c = n.join();
            let l = r.get(c);
            if (!l) {
                l = {
                    resolver: Object(o.cb)(e, n),
                    subPrefixes: n.filter((p=>!p.toLowerCase().includes("hover")))
                },
                r.set(c, l)
            }
            return l
        }
        const ce = t=>Object(o.Mb)(t) && Object.getOwnPropertyNames(t).reduce(((e,n)=>e || Object(o.L)(t[n])), !1);
        const le = ["top", "bottom", "left", "right", "chartArea"];
        function he(t, e) {
            return "top" === t || "bottom" === t || -1 === le.indexOf(t) && "x" === e
        }
        function de(t, e) {
            return function(a, b) {
                return a[t] === b[t] ? a[e] - b[e] : a[t] - b[t]
            }
        }
        function ue(t) {
            const e = t.chart
              , n = e.options.animation;
            e.notifyPlugins("afterRender"),
            Object(o.d)(n && n.onComplete, [t], e)
        }
        function fe(t) {
            const e = t.chart
              , n = e.options.animation;
            Object(o.d)(n && n.onProgress, [t], e)
        }
        function be(t) {
            return Object(o.J)() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]),
            t && t.canvas && (t = t.canvas),
            t
        }
        const ge = {}
          , pe = t=>{
            const canvas = be(t);
            return Object.values(ge).filter((t=>t.canvas === canvas)).pop()
        }
        ;
        function me(t, e, n) {
            const o = Object.keys(t);
            for (const r of o) {
                const o = +r;
                if (o >= e) {
                    const c = t[r];
                    delete t[r],
                    (n > 0 || o > e) && (t[o + n] = c)
                }
            }
        }
        class xe {
            constructor(t, e) {
                const n = this.config = new re(e)
                  , c = be(t)
                  , l = pe(c);
                if (l)
                    throw new Error("Canvas is already in use. Chart with ID '" + l.id + "' must be destroyed before the canvas with ID '" + l.canvas.id + "' can be reused.");
                const h = n.createResolver(n.chartOptionScopes(), this.getContext());
                this.platform = new (n.platform || function(canvas) {
                    return !Object(o.J)() || "undefined" != typeof OffscreenCanvas && canvas instanceof OffscreenCanvas ? Lt : Zt
                }(c)),
                this.platform.updateConfig(n);
                const d = this.platform.acquireContext(c, h.aspectRatio)
                  , canvas = d && d.canvas
                  , f = canvas && canvas.height
                  , m = canvas && canvas.width;
                this.id = Object(o.fb)(),
                this.ctx = d,
                this.canvas = canvas,
                this.width = m,
                this.height = f,
                this._options = h,
                this._aspectRatio = this.aspectRatio,
                this._layers = [],
                this._metasets = [],
                this._stacks = void 0,
                this.boxes = [],
                this.currentDevicePixelRatio = void 0,
                this.chartArea = void 0,
                this._active = [],
                this._lastEvent = void 0,
                this._listeners = {},
                this._responsiveListeners = void 0,
                this._sortedMetasets = [],
                this.scales = {},
                this._plugins = new qt,
                this.$proxies = {},
                this._hiddenIndices = {},
                this.attached = !1,
                this._animationsDisabled = void 0,
                this.$context = void 0,
                this._doResize = Object(o.gb)((t=>this.update(t)), h.resizeDelay || 0),
                this._dataChanges = [],
                ge[this.id] = this,
                d && canvas ? (r.listen(this, "complete", ue),
                r.listen(this, "progress", fe),
                this._initialize(),
                this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
            }
            get aspectRatio() {
                const {options: {aspectRatio: t, maintainAspectRatio: e}, width: n, height: r, _aspectRatio: c} = this;
                return Object(o.Ob)(t) ? e && c ? c : r ? n / r : null : t
            }
            get data() {
                return this.config.data
            }
            set data(data) {
                this.config.data = data
            }
            get options() {
                return this._options
            }
            set options(t) {
                this.config.options = t
            }
            _initialize() {
                return this.notifyPlugins("beforeInit"),
                this.options.responsive ? this.resize() : Object(o.hb)(this, this.options.devicePixelRatio),
                this.bindEvents(),
                this.notifyPlugins("afterInit"),
                this
            }
            clear() {
                return Object(o.ib)(this.canvas, this.ctx),
                this
            }
            stop() {
                return r.stop(this),
                this
            }
            resize(t, e) {
                r.running(this) ? this._resizeBeforeDraw = {
                    width: t,
                    height: e
                } : this._resize(t, e)
            }
            _resize(t, e) {
                const n = this.options
                  , canvas = this.canvas
                  , r = n.maintainAspectRatio && this.aspectRatio
                  , c = this.platform.getMaximumSize(canvas, t, e, r)
                  , l = n.devicePixelRatio || this.platform.getDevicePixelRatio()
                  , h = this.width ? "resize" : "attach";
                this.width = c.width,
                this.height = c.height,
                this._aspectRatio = this.aspectRatio,
                Object(o.hb)(this, l, !0) && (this.notifyPlugins("resize", {
                    size: c
                }),
                Object(o.d)(n.onResize, [this, c], this),
                this.attached && this._doResize(h) && this.render())
            }
            ensureScalesHaveIDs() {
                const t = this.options.scales || {};
                Object(o.r)(t, ((t,e)=>{
                    t.id = e
                }
                ))
            }
            buildOrUpdateScales() {
                const t = this.options
                  , e = t.scales
                  , n = this.scales
                  , r = Object.keys(n).reduce(((t,e)=>(t[e] = !1,
                t)), {});
                let c = [];
                e && (c = c.concat(Object.keys(e).map((t=>{
                    const n = e[t]
                      , o = Qt(t, n)
                      , r = "r" === o
                      , c = "x" === o;
                    return {
                        options: n,
                        dposition: r ? "chartArea" : c ? "bottom" : "left",
                        dtype: r ? "radialLinear" : c ? "category" : "linear"
                    }
                }
                )))),
                Object(o.r)(c, (e=>{
                    const c = e.options
                      , l = c.id
                      , h = Qt(l, c)
                      , d = Object(o.Zb)(c.type, e.dtype);
                    void 0 !== c.position && he(c.position, h) === he(e.dposition) || (c.position = e.dposition),
                    r[l] = !0;
                    let f = null;
                    if (l in n && n[l].type === d)
                        f = n[l];
                    else {
                        f = new (st.getScale(d))({
                            id: l,
                            type: d,
                            ctx: this.ctx,
                            chart: this
                        }),
                        n[f.id] = f
                    }
                    f.init(c, t)
                }
                )),
                Object(o.r)(r, ((t,e)=>{
                    t || delete n[e]
                }
                )),
                Object(o.r)(n, (t=>{
                    At.configure(this, t, t.options),
                    At.addBox(this, t)
                }
                ))
            }
            _updateMetasets() {
                const t = this._metasets
                  , e = this.data.datasets.length
                  , n = t.length;
                if (t.sort(((a,b)=>a.index - b.index)),
                n > e) {
                    for (let i = e; i < n; ++i)
                        this._destroyDatasetMeta(i);
                    t.splice(e, n - e)
                }
                this._sortedMetasets = t.slice(0).sort(de("order", "index"))
            }
            _removeUnreferencedMetasets() {
                const {_metasets: t, data: {datasets: e}} = this;
                t.length > e.length && delete this._stacks,
                t.forEach(((meta,t)=>{
                    0 === e.filter((t=>t === meta._dataset)).length && this._destroyDatasetMeta(t)
                }
                ))
            }
            buildOrUpdateControllers() {
                const t = []
                  , e = this.data.datasets;
                let i, n;
                for (this._removeUnreferencedMetasets(),
                i = 0,
                n = e.length; i < n; i++) {
                    const n = e[i];
                    let meta = this.getDatasetMeta(i);
                    const r = n.type || this.config.type;
                    if (meta.type && meta.type !== r && (this._destroyDatasetMeta(i),
                    meta = this.getDatasetMeta(i)),
                    meta.type = r,
                    meta.indexAxis = n.indexAxis || Gt(r, this.options),
                    meta.order = n.order || 0,
                    meta.index = i,
                    meta.label = "" + n.label,
                    meta.visible = this.isDatasetVisible(i),
                    meta.controller)
                        meta.controller.updateIndex(i),
                        meta.controller.linkScales();
                    else {
                        const e = st.getController(r)
                          , {datasetElementType: n, dataElementType: c} = o.Hb.datasets[r];
                        Object.assign(e.prototype, {
                            dataElementType: st.getElement(c),
                            datasetElementType: n && st.getElement(n)
                        }),
                        meta.controller = new e(this,i),
                        t.push(meta.controller)
                    }
                }
                return this._updateMetasets(),
                t
            }
            _resetElements() {
                Object(o.r)(this.data.datasets, ((t,e)=>{
                    this.getDatasetMeta(e).controller.reset()
                }
                ), this)
            }
            reset() {
                this._resetElements(),
                this.notifyPlugins("reset")
            }
            update(t) {
                const e = this.config;
                e.update();
                const n = this._options = e.createResolver(e.chartOptionScopes(), this.getContext())
                  , r = this._animationsDisabled = !n.animation;
                if (this._updateScales(),
                this._checkEventBindings(),
                this._updateHiddenIndices(),
                this._plugins.invalidate(),
                !1 === this.notifyPlugins("beforeUpdate", {
                    mode: t,
                    cancelable: !0
                }))
                    return;
                const c = this.buildOrUpdateControllers();
                this.notifyPlugins("beforeElementsUpdate");
                let l = 0;
                for (let i = 0, t = this.data.datasets.length; i < t; i++) {
                    const {controller: t} = this.getDatasetMeta(i)
                      , e = !r && -1 === c.indexOf(t);
                    t.buildOrUpdateElements(e),
                    l = Math.max(+t.getMaxOverflow(), l)
                }
                l = this._minPadding = n.layout.autoPadding ? l : 0,
                this._updateLayout(l),
                r || Object(o.r)(c, (t=>{
                    t.reset()
                }
                )),
                this._updateDatasets(t),
                this.notifyPlugins("afterUpdate", {
                    mode: t
                }),
                this._layers.sort(de("z", "_idx"));
                const {_active: h, _lastEvent: d} = this;
                d ? this._eventHandler(d, !0) : h.length && this._updateHoverStyles(h, h, !0),
                this.render()
            }
            _updateScales() {
                Object(o.r)(this.scales, (t=>{
                    At.removeBox(this, t)
                }
                )),
                this.ensureScalesHaveIDs(),
                this.buildOrUpdateScales()
            }
            _checkEventBindings() {
                const t = this.options
                  , e = new Set(Object.keys(this._listeners))
                  , n = new Set(t.events);
                Object(o.jb)(e, n) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(),
                this.bindEvents())
            }
            _updateHiddenIndices() {
                const {_hiddenIndices: t} = this
                  , e = this._getUniformDataChanges() || [];
                for (const {method: n, start: o, count: r} of e) {
                    me(t, o, "_removeElements" === n ? -r : r)
                }
            }
            _getUniformDataChanges() {
                const t = this._dataChanges;
                if (!t || !t.length)
                    return;
                this._dataChanges = [];
                const e = this.data.datasets.length
                  , n = e=>new Set(t.filter((t=>t[0] === e)).map(((t,i)=>i + "," + t.splice(1).join(","))))
                  , r = n(0);
                for (let i = 1; i < e; i++)
                    if (!Object(o.jb)(r, n(i)))
                        return;
                return Array.from(r).map((t=>t.split(","))).map((a=>({
                    method: a[1],
                    start: +a[2],
                    count: +a[3]
                })))
            }
            _updateLayout(t) {
                if (!1 === this.notifyPlugins("beforeLayout", {
                    cancelable: !0
                }))
                    return;
                At.update(this, this.width, this.height, t);
                const area = this.chartArea
                  , e = area.width <= 0 || area.height <= 0;
                this._layers = [],
                Object(o.r)(this.boxes, (t=>{
                    e && "chartArea" === t.position || (t.configure && t.configure(),
                    this._layers.push(...t._layers()))
                }
                ), this),
                this._layers.forEach(((t,e)=>{
                    t._idx = e
                }
                )),
                this.notifyPlugins("afterLayout")
            }
            _updateDatasets(t) {
                if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
                    mode: t,
                    cancelable: !0
                })) {
                    for (let i = 0, t = this.data.datasets.length; i < t; ++i)
                        this.getDatasetMeta(i).controller.configure();
                    for (let i = 0, e = this.data.datasets.length; i < e; ++i)
                        this._updateDataset(i, Object(o.L)(t) ? t({
                            datasetIndex: i
                        }) : t);
                    this.notifyPlugins("afterDatasetsUpdate", {
                        mode: t
                    })
                }
            }
            _updateDataset(t, e) {
                const meta = this.getDatasetMeta(t)
                  , n = {
                    meta: meta,
                    index: t,
                    mode: e,
                    cancelable: !0
                };
                !1 !== this.notifyPlugins("beforeDatasetUpdate", n) && (meta.controller._update(e),
                n.cancelable = !1,
                this.notifyPlugins("afterDatasetUpdate", n))
            }
            render() {
                !1 !== this.notifyPlugins("beforeRender", {
                    cancelable: !0
                }) && (r.has(this) ? this.attached && !r.running(this) && r.start(this) : (this.draw(),
                ue({
                    chart: this
                })))
            }
            draw() {
                let i;
                if (this._resizeBeforeDraw) {
                    const {width: t, height: e} = this._resizeBeforeDraw;
                    this._resize(t, e),
                    this._resizeBeforeDraw = null
                }
                if (this.clear(),
                this.width <= 0 || this.height <= 0)
                    return;
                if (!1 === this.notifyPlugins("beforeDraw", {
                    cancelable: !0
                }))
                    return;
                const t = this._layers;
                for (i = 0; i < t.length && t[i].z <= 0; ++i)
                    t[i].draw(this.chartArea);
                for (this._drawDatasets(); i < t.length; ++i)
                    t[i].draw(this.chartArea);
                this.notifyPlugins("afterDraw")
            }
            _getSortedDatasetMetas(t) {
                const e = this._sortedMetasets
                  , n = [];
                let i, o;
                for (i = 0,
                o = e.length; i < o; ++i) {
                    const meta = e[i];
                    t && !meta.visible || n.push(meta)
                }
                return n
            }
            getSortedVisibleDatasetMetas() {
                return this._getSortedDatasetMetas(!0)
            }
            _drawDatasets() {
                if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
                    cancelable: !0
                }))
                    return;
                const t = this.getSortedVisibleDatasetMetas();
                for (let i = t.length - 1; i >= 0; --i)
                    this._drawDataset(t[i]);
                this.notifyPlugins("afterDatasetsDraw")
            }
            _drawDataset(meta) {
                const t = this.ctx
                  , e = meta._clip
                  , n = !e.disabled
                  , area = this.chartArea
                  , r = {
                    meta: meta,
                    index: meta.index,
                    cancelable: !0
                };
                !1 !== this.notifyPlugins("beforeDatasetDraw", r) && (n && Object(o.m)(t, {
                    left: !1 === e.left ? 0 : area.left - e.left,
                    right: !1 === e.right ? this.width : area.right + e.right,
                    top: !1 === e.top ? 0 : area.top - e.top,
                    bottom: !1 === e.bottom ? this.height : area.bottom + e.bottom
                }),
                meta.controller.draw(),
                n && Object(o.o)(t),
                r.cancelable = !1,
                this.notifyPlugins("afterDatasetDraw", r))
            }
            isPointInArea(t) {
                return Object(o.a)(t, this.chartArea, this._minPadding)
            }
            getElementsAtEventForMode(t, e, n, o) {
                const r = xt.modes[e];
                return "function" == typeof r ? r(this, t, n, o) : []
            }
            getDatasetMeta(t) {
                const e = this.data.datasets[t]
                  , n = this._metasets;
                let meta = n.filter((t=>t && t._dataset === e)).pop();
                return meta || (meta = {
                    type: null,
                    data: [],
                    dataset: null,
                    controller: null,
                    hidden: null,
                    xAxisID: null,
                    yAxisID: null,
                    order: e && e.order || 0,
                    index: t,
                    _dataset: e,
                    _parsed: [],
                    _sorted: !1
                },
                n.push(meta)),
                meta
            }
            getContext() {
                return this.$context || (this.$context = Object(o.Lb)(null, {
                    chart: this,
                    type: "chart"
                }))
            }
            getVisibleDatasetCount() {
                return this.getSortedVisibleDatasetMetas().length
            }
            isDatasetVisible(t) {
                const e = this.data.datasets[t];
                if (!e)
                    return !1;
                const meta = this.getDatasetMeta(t);
                return "boolean" == typeof meta.hidden ? !meta.hidden : !e.hidden
            }
            setDatasetVisibility(t, e) {
                this.getDatasetMeta(t).hidden = !e
            }
            toggleDataVisibility(t) {
                this._hiddenIndices[t] = !this._hiddenIndices[t]
            }
            getDataVisibility(t) {
                return !this._hiddenIndices[t]
            }
            _updateVisibility(t, e, n) {
                const r = n ? "show" : "hide"
                  , meta = this.getDatasetMeta(t)
                  , c = meta.controller._resolveAnimations(void 0, r);
                Object(o.Nb)(e) ? (meta.data[e].hidden = !n,
                this.update()) : (this.setDatasetVisibility(t, n),
                c.update(meta, {
                    visible: n
                }),
                this.update((e=>e.datasetIndex === t ? r : void 0)))
            }
            hide(t, e) {
                this._updateVisibility(t, e, !1)
            }
            show(t, e) {
                this._updateVisibility(t, e, !0)
            }
            _destroyDatasetMeta(t) {
                const meta = this._metasets[t];
                meta && meta.controller && meta.controller._destroy(),
                delete this._metasets[t]
            }
            _stop() {
                let i, t;
                for (this.stop(),
                r.remove(this),
                i = 0,
                t = this.data.datasets.length; i < t; ++i)
                    this._destroyDatasetMeta(i)
            }
            destroy() {
                this.notifyPlugins("beforeDestroy");
                const {canvas: canvas, ctx: t} = this;
                this._stop(),
                this.config.clearCache(),
                canvas && (this.unbindEvents(),
                Object(o.ib)(canvas, t),
                this.platform.releaseContext(t),
                this.canvas = null,
                this.ctx = null),
                this.notifyPlugins("destroy"),
                delete ge[this.id],
                this.notifyPlugins("afterDestroy")
            }
            toBase64Image(...t) {
                return this.canvas.toDataURL(...t)
            }
            bindEvents() {
                this.bindUserEvents(),
                this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
            }
            bindUserEvents() {
                const t = this._listeners
                  , e = this.platform
                  , n = (n,o)=>{
                    e.addEventListener(this, n, o),
                    t[n] = o
                }
                  , r = (t,e,n)=>{
                    t.offsetX = e,
                    t.offsetY = n,
                    this._eventHandler(t)
                }
                ;
                Object(o.r)(this.options.events, (t=>n(t, r)))
            }
            bindResponsiveEvents() {
                this._responsiveListeners || (this._responsiveListeners = {});
                const t = this._responsiveListeners
                  , e = this.platform
                  , n = (n,o)=>{
                    e.addEventListener(this, n, o),
                    t[n] = o
                }
                  , o = (n,o)=>{
                    t[n] && (e.removeEventListener(this, n, o),
                    delete t[n])
                }
                  , r = (t,e)=>{
                    this.canvas && this.resize(t, e)
                }
                ;
                let c;
                const l = ()=>{
                    o("attach", l),
                    this.attached = !0,
                    this.resize(),
                    n("resize", r),
                    n("detach", c)
                }
                ;
                c = ()=>{
                    this.attached = !1,
                    o("resize", r),
                    this._stop(),
                    this._resize(0, 0),
                    n("attach", l)
                }
                ,
                e.isAttached(this.canvas) ? l() : c()
            }
            unbindEvents() {
                Object(o.r)(this._listeners, ((t,e)=>{
                    this.platform.removeEventListener(this, e, t)
                }
                )),
                this._listeners = {},
                Object(o.r)(this._responsiveListeners, ((t,e)=>{
                    this.platform.removeEventListener(this, e, t)
                }
                )),
                this._responsiveListeners = void 0
            }
            updateHoverStyle(t, e, n) {
                const o = n ? "set" : "remove";
                let meta, r, i, c;
                for ("dataset" === e && (meta = this.getDatasetMeta(t[0].datasetIndex),
                meta.controller["_" + o + "DatasetHoverStyle"]()),
                i = 0,
                c = t.length; i < c; ++i) {
                    r = t[i];
                    const e = r && this.getDatasetMeta(r.datasetIndex).controller;
                    e && e[o + "HoverStyle"](r.element, r.datasetIndex, r.index)
                }
            }
            getActiveElements() {
                return this._active || []
            }
            setActiveElements(t) {
                const e = this._active || []
                  , n = t.map((({datasetIndex: t, index: e})=>{
                    const meta = this.getDatasetMeta(t);
                    if (!meta)
                        throw new Error("No dataset found at index " + t);
                    return {
                        datasetIndex: t,
                        element: meta.data[e],
                        index: e
                    }
                }
                ));
                !Object(o.kb)(n, e) && (this._active = n,
                this._lastEvent = null,
                this._updateHoverStyles(n, e))
            }
            notifyPlugins(t, e, filter) {
                return this._plugins.notify(this, t, e, filter)
            }
            _updateHoverStyles(t, e, n) {
                const o = this.options.hover
                  , r = (a,b)=>a.filter((t=>!b.some((e=>t.datasetIndex === e.datasetIndex && t.index === e.index))))
                  , c = r(e, t)
                  , l = n ? t : r(t, e);
                c.length && this.updateHoverStyle(c, o.mode, !1),
                l.length && o.mode && this.updateHoverStyle(l, o.mode, !0)
            }
            _eventHandler(t, e) {
                const n = {
                    event: t,
                    replay: e,
                    cancelable: !0,
                    inChartArea: this.isPointInArea(t)
                }
                  , o = e=>(e.options.events || this.options.events).includes(t.native.type);
                if (!1 === this.notifyPlugins("beforeEvent", n, o))
                    return;
                const r = this._handleEvent(t, e, n.inChartArea);
                return n.cancelable = !1,
                this.notifyPlugins("afterEvent", n, o),
                (r || n.changed) && this.render(),
                this
            }
            _handleEvent(t, e, n) {
                const {_active: r=[], options: c} = this
                  , l = e
                  , h = this._getActiveElements(t, r, n, l)
                  , d = Object(o.lb)(t)
                  , f = function(t, e, n, o) {
                    return n && "mouseout" !== t.type ? o ? e : t : null
                }(t, this._lastEvent, n, d);
                n && (this._lastEvent = null,
                Object(o.d)(c.onHover, [t, h, this], this),
                d && Object(o.d)(c.onClick, [t, h, this], this));
                const m = !Object(o.kb)(h, r);
                return (m || e) && (this._active = h,
                this._updateHoverStyles(h, r, e)),
                this._lastEvent = f,
                m
            }
            _getActiveElements(t, e, n, o) {
                if ("mouseout" === t.type)
                    return [];
                if (!n)
                    return e;
                const r = this.options.hover;
                return this.getElementsAtEventForMode(t, r.mode, r, o)
            }
        }
        const ye = ()=>Object(o.r)(xe.instances, (t=>t._plugins.invalidate()))
          , _e = !0;
        function ve(t, element, e) {
            const {startAngle: n, pixelMargin: r, x: c, y: l, outerRadius: h, innerRadius: d} = element;
            let f = r / h;
            t.beginPath(),
            t.arc(c, l, h, n - f, e + f),
            d > r ? (f = r / d,
            t.arc(c, l, d, e + f, n - f, !0)) : t.arc(c, l, r, e + o.i, n - o.i),
            t.closePath(),
            t.clip()
        }
        function Oe(t, e, n, r) {
            const c = (l = t.options.borderRadius,
            Object(o.nb)(l, ["outerStart", "outerEnd", "innerStart", "innerEnd"]));
            var l;
            const h = (n - e) / 2
              , d = Math.min(h, r * e / 2)
              , f = t=>{
                const e = (n - Math.min(h, t)) * r / 2;
                return Object(o.f)(t, 0, Math.min(h, e))
            }
            ;
            return {
                outerStart: f(c.outerStart),
                outerEnd: f(c.outerEnd),
                innerStart: Object(o.f)(c.innerStart, 0, d),
                innerEnd: Object(o.f)(c.innerEnd, 0, d)
            }
        }
        function we(t, e, n, o) {
            return {
                x: n + t * Math.cos(e),
                y: o + t * Math.sin(e)
            }
        }
        function Me(t, element, e, n, r, c) {
            const {x: l, y: h, startAngle: d, pixelMargin: f, innerRadius: m} = element
              , x = Math.max(element.outerRadius + n + e - f, 0)
              , y = m > 0 ? m + n + e + f : 0;
            let _ = 0;
            const v = r - d;
            if (n) {
                const t = ((m > 0 ? m - n : 0) + (x > 0 ? x - n : 0)) / 2;
                _ = (v - (0 !== t ? v * t / (t + n) : v)) / 2
            }
            const O = (v - Math.max(.001, v * x - e / o.q) / x) / 2
              , w = d + O + _
              , M = r - O - _
              , {outerStart: j, outerEnd: k, innerStart: S, innerEnd: P} = Oe(element, y, x, M - w)
              , C = x - j
              , D = x - k
              , A = w + j / C
              , T = M - k / D
              , L = y + S
              , E = y + P
              , R = w + S / L
              , I = M - P / E;
            if (t.beginPath(),
            c) {
                if (t.arc(l, h, x, A, T),
                k > 0) {
                    const e = we(D, T, l, h);
                    t.arc(e.x, e.y, k, T, M + o.i)
                }
                const e = we(E, M, l, h);
                if (t.lineTo(e.x, e.y),
                P > 0) {
                    const e = we(E, I, l, h);
                    t.arc(e.x, e.y, P, M + o.i, I + Math.PI)
                }
                if (t.arc(l, h, y, M - P / y, w + S / y, !0),
                S > 0) {
                    const e = we(L, R, l, h);
                    t.arc(e.x, e.y, S, R + Math.PI, w - o.i)
                }
                const n = we(C, w, l, h);
                if (t.lineTo(n.x, n.y),
                j > 0) {
                    const e = we(C, A, l, h);
                    t.arc(e.x, e.y, j, w - o.i, A)
                }
            } else {
                t.moveTo(l, h);
                const e = Math.cos(A) * x + l
                  , n = Math.sin(A) * x + h;
                t.lineTo(e, n);
                const o = Math.cos(T) * x + l
                  , r = Math.sin(T) * x + h;
                t.lineTo(o, r)
            }
            t.closePath()
        }
        function je(t, element, e, n, r, c) {
            const {options: l} = element
              , {borderWidth: h, borderJoinStyle: d} = l
              , f = "inner" === l.borderAlign;
            h && (f ? (t.lineWidth = 2 * h,
            t.lineJoin = d || "round") : (t.lineWidth = h,
            t.lineJoin = d || "bevel"),
            element.fullCircles && function(t, element, e) {
                const {x: n, y: r, startAngle: c, pixelMargin: l, fullCircles: h} = element
                  , d = Math.max(element.outerRadius - l, 0)
                  , f = element.innerRadius + l;
                let i;
                for (e && ve(t, element, c + o.u),
                t.beginPath(),
                t.arc(n, r, f, c + o.u, c, !0),
                i = 0; i < h; ++i)
                    t.stroke();
                for (t.beginPath(),
                t.arc(n, r, d, c, c + o.u),
                i = 0; i < h; ++i)
                    t.stroke()
            }(t, element, f),
            f && ve(t, element, r),
            Me(t, element, e, n, r, c),
            t.stroke())
        }
        Object.defineProperties(xe, {
            defaults: {
                enumerable: _e,
                value: o.Hb
            },
            instances: {
                enumerable: _e,
                value: ge
            },
            overrides: {
                enumerable: _e,
                value: o.v
            },
            registry: {
                enumerable: _e,
                value: st
            },
            version: {
                enumerable: _e,
                value: "3.9.1"
            },
            getChart: {
                enumerable: _e,
                value: pe
            },
            register: {
                enumerable: _e,
                value: (...t)=>{
                    st.add(...t),
                    ye()
                }
            },
            unregister: {
                enumerable: _e,
                value: (...t)=>{
                    st.remove(...t),
                    ye()
                }
            }
        });
        class ke extends Y {
            constructor(t) {
                super(),
                this.options = void 0,
                this.circumference = void 0,
                this.startAngle = void 0,
                this.endAngle = void 0,
                this.innerRadius = void 0,
                this.outerRadius = void 0,
                this.pixelMargin = 0,
                this.fullCircles = 0,
                t && Object.assign(this, t)
            }
            inRange(t, e, n) {
                const r = this.getProps(["x", "y"], n)
                  , {angle: c, distance: l} = Object(o.D)(r, {
                    x: t,
                    y: e
                })
                  , {startAngle: h, endAngle: d, innerRadius: f, outerRadius: m, circumference: x} = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], n)
                  , y = this.options.spacing / 2
                  , _ = Object(o.Zb)(x, d - h) >= o.u || Object(o.Tb)(c, h, d)
                  , v = Object(o.mb)(l, f + y, m + y);
                return _ && v
            }
            getCenterPoint(t) {
                const {x: e, y: n, startAngle: o, endAngle: r, innerRadius: c, outerRadius: l} = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t)
                  , {offset: h, spacing: d} = this.options
                  , f = (o + r) / 2
                  , m = (c + l + d + h) / 2;
                return {
                    x: e + Math.cos(f) * m,
                    y: n + Math.sin(f) * m
                }
            }
            tooltipPosition(t) {
                return this.getCenterPoint(t)
            }
            draw(t) {
                const {options: e, circumference: n} = this
                  , r = (e.offset || 0) / 2
                  , c = (e.spacing || 0) / 2
                  , l = e.circular;
                if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0,
                this.fullCircles = n > o.u ? Math.floor(n / o.u) : 0,
                0 === n || this.innerRadius < 0 || this.outerRadius < 0)
                    return;
                t.save();
                let h = 0;
                if (r) {
                    h = r / 2;
                    const e = (this.startAngle + this.endAngle) / 2;
                    t.translate(Math.cos(e) * h, Math.sin(e) * h),
                    this.circumference >= o.q && (h = r)
                }
                t.fillStyle = e.backgroundColor,
                t.strokeStyle = e.borderColor;
                const d = function(t, element, e, n, r) {
                    const {fullCircles: c, startAngle: l, circumference: h} = element;
                    let d = element.endAngle;
                    if (c) {
                        Me(t, element, e, n, l + o.u, r);
                        for (let i = 0; i < c; ++i)
                            t.fill();
                        isNaN(h) || (d = l + h % o.u,
                        h % o.u == 0 && (d += o.u))
                    }
                    return Me(t, element, e, n, d, r),
                    t.fill(),
                    d
                }(t, this, h, c, l);
                je(t, this, h, c, d, l),
                t.restore()
            }
        }
        function Se(t, e, style=e) {
            t.lineCap = Object(o.Zb)(style.borderCapStyle, e.borderCapStyle),
            t.setLineDash(Object(o.Zb)(style.borderDash, e.borderDash)),
            t.lineDashOffset = Object(o.Zb)(style.borderDashOffset, e.borderDashOffset),
            t.lineJoin = Object(o.Zb)(style.borderJoinStyle, e.borderJoinStyle),
            t.lineWidth = Object(o.Zb)(style.borderWidth, e.borderWidth),
            t.strokeStyle = Object(o.Zb)(style.borderColor, e.borderColor)
        }
        function Pe(t, e, n) {
            t.lineTo(n.x, n.y)
        }
        function Ce(t, e, n={}) {
            const o = t.length
              , {start: r=0, end: c=o - 1} = n
              , {start: l, end: h} = e
              , d = Math.max(r, l)
              , f = Math.min(c, h)
              , m = r < l && c < l || r > h && c > h;
            return {
                count: o,
                start: d,
                loop: e.loop,
                ilen: f < d && !m ? o + f - d : f - d
            }
        }
        function De(t, line, e, n) {
            const {points: r, options: c} = line
              , {count: l, start: h, loop: d, ilen: f} = Ce(r, e, n)
              , m = function(t) {
                return t.stepped ? o.ub : t.tension || "monotone" === t.cubicInterpolationMode ? o.vb : Pe
            }(c);
            let i, x, y, {move: _=!0, reverse: v} = n || {};
            for (i = 0; i <= f; ++i)
                x = r[(h + (v ? f - i : i)) % l],
                x.skip || (_ ? (t.moveTo(x.x, x.y),
                _ = !1) : m(t, y, x, v, c.stepped),
                y = x);
            return d && (x = r[(h + (v ? f : 0)) % l],
            m(t, y, x, v, c.stepped)),
            !!d
        }
        function Ae(t, line, e, n) {
            const o = line.points
              , {count: r, start: c, ilen: l} = Ce(o, e, n)
              , {move: h=!0, reverse: d} = n || {};
            let i, f, m, x, y, _, v = 0, O = 0;
            const w = t=>(c + (d ? l - t : t)) % r
              , M = ()=>{
                x !== y && (t.lineTo(v, y),
                t.lineTo(v, x),
                t.lineTo(v, _))
            }
            ;
            for (h && (f = o[w(0)],
            t.moveTo(f.x, f.y)),
            i = 0; i <= l; ++i) {
                if (f = o[w(i)],
                f.skip)
                    continue;
                const e = f.x
                  , n = f.y
                  , r = 0 | e;
                r === m ? (n < x ? x = n : n > y && (y = n),
                v = (O * v + e) / ++O) : (M(),
                t.lineTo(e, n),
                m = r,
                O = 0,
                x = y = n),
                _ = n
            }
            M()
        }
        function Te(line) {
            const t = line.options
              , e = t.borderDash && t.borderDash.length;
            return !(line._decimated || line._loop || t.tension || "monotone" === t.cubicInterpolationMode || t.stepped || e) ? Ae : De
        }
        ke.id = "arc",
        ke.defaults = {
            borderAlign: "center",
            borderColor: "#fff",
            borderJoinStyle: void 0,
            borderRadius: 0,
            borderWidth: 2,
            offset: 0,
            spacing: 0,
            angle: void 0,
            circular: !0
        },
        ke.defaultRoutes = {
            backgroundColor: "backgroundColor"
        };
        const Le = "function" == typeof Path2D;
        function Ee(t, line, e, n) {
            Le && !line.options.segment ? function(t, line, e, n) {
                let path = line._path;
                path || (path = line._path = new Path2D,
                line.path(path, e, n) && path.closePath()),
                Se(t, line.options),
                t.stroke(path)
            }(t, line, e, n) : function(t, line, e, n) {
                const {segments: o, options: r} = line
                  , c = Te(line);
                for (const l of o)
                    Se(t, r, l.style),
                    t.beginPath(),
                    c(t, line, l, {
                        start: e,
                        end: e + n - 1
                    }) && t.closePath(),
                    t.stroke()
            }(t, line, e, n)
        }
        class Re extends Y {
            constructor(t) {
                super(),
                this.animated = !0,
                this.options = void 0,
                this._chart = void 0,
                this._loop = void 0,
                this._fullLoop = void 0,
                this._path = void 0,
                this._points = void 0,
                this._segments = void 0,
                this._decimated = !1,
                this._pointsUpdated = !1,
                this._datasetIndex = void 0,
                t && Object.assign(this, t)
            }
            updateControlPoints(t, e) {
                const n = this.options;
                if ((n.tension || "monotone" === n.cubicInterpolationMode) && !n.stepped && !this._pointsUpdated) {
                    const r = n.spanGaps ? this._loop : this._fullLoop;
                    Object(o.ob)(this._points, n, t, r, e),
                    this._pointsUpdated = !0
                }
            }
            set points(t) {
                this._points = t,
                delete this._segments,
                delete this._path,
                this._pointsUpdated = !1
            }
            get points() {
                return this._points
            }
            get segments() {
                return this._segments || (this._segments = Object(o.pb)(this, this.options.segment))
            }
            first() {
                const t = this.segments
                  , e = this.points;
                return t.length && e[t[0].start]
            }
            last() {
                const t = this.segments
                  , e = this.points
                  , n = t.length;
                return n && e[t[n - 1].end]
            }
            interpolate(t, e) {
                const n = this.options
                  , r = t[e]
                  , c = this.points
                  , l = Object(o.qb)(this, {
                    property: e,
                    start: r,
                    end: r
                });
                if (!l.length)
                    return;
                const h = []
                  , d = function(t) {
                    return t.stepped ? o.rb : t.tension || "monotone" === t.cubicInterpolationMode ? o.sb : o.tb
                }(n);
                let i, f;
                for (i = 0,
                f = l.length; i < f; ++i) {
                    const {start: o, end: f} = l[i]
                      , m = c[o]
                      , x = c[f];
                    if (m === x) {
                        h.push(m);
                        continue
                    }
                    const y = d(m, x, Math.abs((r - m[e]) / (x[e] - m[e])), n.stepped);
                    y[e] = t[e],
                    h.push(y)
                }
                return 1 === h.length ? h[0] : h
            }
            pathSegment(t, e, n) {
                return Te(this)(t, this, e, n)
            }
            path(t, e, n) {
                const o = this.segments
                  , r = Te(this);
                let c = this._loop;
                e = e || 0,
                n = n || this.points.length - e;
                for (const l of o)
                    c &= r(t, this, l, {
                        start: e,
                        end: e + n - 1
                    });
                return !!c
            }
            draw(t, e, n, o) {
                const r = this.options || {};
                (this.points || []).length && r.borderWidth && (t.save(),
                Ee(t, this, n, o),
                t.restore()),
                this.animated && (this._pointsUpdated = !1,
                this._path = void 0)
            }
        }
        function Ie(t, e, n, o) {
            const r = t.options
              , {[n]: c} = t.getProps([n], o);
            return Math.abs(e - c) < r.radius + r.hitRadius
        }
        Re.id = "line",
        Re.defaults = {
            borderCapStyle: "butt",
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: "miter",
            borderWidth: 3,
            capBezierPoints: !0,
            cubicInterpolationMode: "default",
            fill: !1,
            spanGaps: !1,
            stepped: !1,
            tension: 0
        },
        Re.defaultRoutes = {
            backgroundColor: "backgroundColor",
            borderColor: "borderColor"
        },
        Re.descriptors = {
            _scriptable: !0,
            _indexable: t=>"borderDash" !== t && "fill" !== t
        };
        class ze extends Y {
            constructor(t) {
                super(),
                this.options = void 0,
                this.parsed = void 0,
                this.skip = void 0,
                this.stop = void 0,
                t && Object.assign(this, t)
            }
            inRange(t, e, n) {
                const o = this.options
                  , {x: r, y: c} = this.getProps(["x", "y"], n);
                return Math.pow(t - r, 2) + Math.pow(e - c, 2) < Math.pow(o.hitRadius + o.radius, 2)
            }
            inXRange(t, e) {
                return Ie(this, t, "x", e)
            }
            inYRange(t, e) {
                return Ie(this, t, "y", e)
            }
            getCenterPoint(t) {
                const {x: e, y: n} = this.getProps(["x", "y"], t);
                return {
                    x: e,
                    y: n
                }
            }
            size(t) {
                let e = (t = t || this.options || {}).radius || 0;
                e = Math.max(e, e && t.hoverRadius || 0);
                return 2 * (e + (e && t.borderWidth || 0))
            }
            draw(t, area) {
                const e = this.options;
                this.skip || e.radius < .1 || !Object(o.a)(this, area, this.size(e) / 2) || (t.strokeStyle = e.borderColor,
                t.lineWidth = e.borderWidth,
                t.fillStyle = e.backgroundColor,
                Object(o.wb)(t, e, this.x, this.y))
            }
            getRange() {
                const t = this.options || {};
                return t.radius + t.hitRadius
            }
        }
        function Fe(t, e) {
            const {x: n, y: o, base: base, width: r, height: c} = t.getProps(["x", "y", "base", "width", "height"], e);
            let l, h, d, f, m;
            return t.horizontal ? (m = c / 2,
            l = Math.min(n, base),
            h = Math.max(n, base),
            d = o - m,
            f = o + m) : (m = r / 2,
            l = n - m,
            h = n + m,
            d = Math.min(o, base),
            f = Math.max(o, base)),
            {
                left: l,
                top: d,
                right: h,
                bottom: f
            }
        }
        function We(t, e, n, r) {
            return t ? 0 : Object(o.f)(e, n, r)
        }
        function Ve(t) {
            const e = Fe(t)
              , n = e.right - e.left
              , r = e.bottom - e.top
              , c = function(t, e, n) {
                const r = t.options.borderWidth
                  , c = t.borderSkipped
                  , l = Object(o.yb)(r);
                return {
                    t: We(c.top, l.top, 0, n),
                    r: We(c.right, l.right, 0, e),
                    b: We(c.bottom, l.bottom, 0, n),
                    l: We(c.left, l.left, 0, e)
                }
            }(t, n / 2, r / 2)
              , l = function(t, e, n) {
                const {enableBorderRadius: r} = t.getProps(["enableBorderRadius"])
                  , c = t.options.borderRadius
                  , l = Object(o.zb)(c)
                  , h = Math.min(e, n)
                  , d = t.borderSkipped
                  , f = r || Object(o.Mb)(c);
                return {
                    topLeft: We(!f || d.top || d.left, l.topLeft, 0, h),
                    topRight: We(!f || d.top || d.right, l.topRight, 0, h),
                    bottomLeft: We(!f || d.bottom || d.left, l.bottomLeft, 0, h),
                    bottomRight: We(!f || d.bottom || d.right, l.bottomRight, 0, h)
                }
            }(t, n / 2, r / 2);
            return {
                outer: {
                    x: e.left,
                    y: e.top,
                    w: n,
                    h: r,
                    radius: l
                },
                inner: {
                    x: e.left + c.l,
                    y: e.top + c.t,
                    w: n - c.l - c.r,
                    h: r - c.t - c.b,
                    radius: {
                        topLeft: Math.max(0, l.topLeft - Math.max(c.t, c.l)),
                        topRight: Math.max(0, l.topRight - Math.max(c.t, c.r)),
                        bottomLeft: Math.max(0, l.bottomLeft - Math.max(c.b, c.l)),
                        bottomRight: Math.max(0, l.bottomRight - Math.max(c.b, c.r))
                    }
                }
            }
        }
        function Ne(t, e, n, r) {
            const c = null === e
              , l = null === n
              , h = t && !(c && l) && Fe(t, r);
            return h && (c || Object(o.mb)(e, h.left, h.right)) && (l || Object(o.mb)(n, h.top, h.bottom))
        }
        function Be(t, rect) {
            t.rect(rect.x, rect.y, rect.w, rect.h)
        }
        function He(rect, t, e={}) {
            const n = rect.x !== e.x ? -t : 0
              , o = rect.y !== e.y ? -t : 0
              , r = (rect.x + rect.w !== e.x + e.w ? t : 0) - n
              , c = (rect.y + rect.h !== e.y + e.h ? t : 0) - o;
            return {
                x: rect.x + n,
                y: rect.y + o,
                w: rect.w + r,
                h: rect.h + c,
                radius: rect.radius
            }
        }
        ze.id = "point",
        ze.defaults = {
            borderWidth: 1,
            hitRadius: 1,
            hoverBorderWidth: 1,
            hoverRadius: 4,
            pointStyle: "circle",
            radius: 3,
            rotation: 0
        },
        ze.defaultRoutes = {
            backgroundColor: "backgroundColor",
            borderColor: "borderColor"
        };
        class Ye extends Y {
            constructor(t) {
                super(),
                this.options = void 0,
                this.horizontal = void 0,
                this.base = void 0,
                this.width = void 0,
                this.height = void 0,
                this.inflateAmount = void 0,
                t && Object.assign(this, t)
            }
            draw(t) {
                const {inflateAmount: e, options: {borderColor: n, backgroundColor: r}} = this
                  , {inner: c, outer: l} = Ve(this)
                  , h = (d = l.radius).topLeft || d.topRight || d.bottomLeft || d.bottomRight ? o.xb : Be;
                var d;
                t.save(),
                l.w === c.w && l.h === c.h || (t.beginPath(),
                h(t, He(l, e, c)),
                t.clip(),
                h(t, He(c, -e, l)),
                t.fillStyle = n,
                t.fill("evenodd")),
                t.beginPath(),
                h(t, He(c, e)),
                t.fillStyle = r,
                t.fill(),
                t.restore()
            }
            inRange(t, e, n) {
                return Ne(this, t, e, n)
            }
            inXRange(t, e) {
                return Ne(this, t, null, e)
            }
            inYRange(t, e) {
                return Ne(this, null, t, e)
            }
            getCenterPoint(t) {
                const {x: e, y: n, base: base, horizontal: o} = this.getProps(["x", "y", "base", "horizontal"], t);
                return {
                    x: o ? (e + base) / 2 : e,
                    y: o ? n : (n + base) / 2
                }
            }
            getRange(t) {
                return "x" === t ? this.width / 2 : this.height / 2
            }
        }
        Ye.id = "bar",
        Ye.defaults = {
            borderSkipped: "start",
            borderWidth: 0,
            borderRadius: 0,
            inflateAmount: "auto",
            pointStyle: void 0
        },
        Ye.defaultRoutes = {
            backgroundColor: "backgroundColor",
            borderColor: "borderColor"
        };
        var Xe = Object.freeze({
            __proto__: null,
            ArcElement: ke,
            LineElement: Re,
            PointElement: ze,
            BarElement: Ye
        });
        function $e(t) {
            if (t._decimated) {
                const data = t._data;
                delete t._decimated,
                delete t._data,
                Object.defineProperty(t, "data", {
                    value: data
                })
            }
        }
        function Ue(t) {
            t.data.datasets.forEach((t=>{
                $e(t)
            }
            ))
        }
        var Ze = {
            id: "decimation",
            defaults: {
                algorithm: "min-max",
                enabled: !1
            },
            beforeElementsUpdate: (t,e,n)=>{
                if (!n.enabled)
                    return void Ue(t);
                const r = t.width;
                t.data.datasets.forEach(((e,c)=>{
                    const {_data: l, indexAxis: h} = e
                      , meta = t.getDatasetMeta(c)
                      , data = l || e.data;
                    if ("y" === Object(o.C)([h, t.options.indexAxis]))
                        return;
                    if (!meta.controller.supportsDecimation)
                        return;
                    const d = t.scales[meta.xAxisID];
                    if ("linear" !== d.type && "time" !== d.type)
                        return;
                    if (t.options.parsing)
                        return;
                    let {start: f, count: m} = function(meta, t) {
                        const e = t.length;
                        let n, r = 0;
                        const {iScale: c} = meta
                          , {min: l, max: h, minDefined: d, maxDefined: f} = c.getUserBounds();
                        return d && (r = Object(o.f)(Object(o.A)(t, c.axis, l).lo, 0, e - 1)),
                        n = f ? Object(o.f)(Object(o.A)(t, c.axis, h).hi + 1, r, e) - r : e - r,
                        {
                            start: r,
                            count: n
                        }
                    }(meta, data);
                    if (m <= (n.threshold || 4 * r))
                        return void $e(e);
                    let x;
                    switch (Object(o.Ob)(l) && (e._data = data,
                    delete e.data,
                    Object.defineProperty(e, "data", {
                        configurable: !0,
                        enumerable: !0,
                        get: function() {
                            return this._decimated
                        },
                        set: function(t) {
                            this._data = t
                        }
                    })),
                    n.algorithm) {
                    case "lttb":
                        x = function(data, t, e, n, o) {
                            const r = o.samples || n;
                            if (r >= e)
                                return data.slice(t, t + e);
                            const c = []
                              , l = (e - 2) / (r - 2);
                            let h = 0;
                            const d = t + e - 1;
                            let i, f, m, area, x, a = t;
                            for (c[h++] = data[a],
                            i = 0; i < r - 2; i++) {
                                let n, o = 0, r = 0;
                                const d = Math.floor((i + 1) * l) + 1 + t
                                  , y = Math.min(Math.floor((i + 2) * l) + 1, e) + t
                                  , _ = y - d;
                                for (n = d; n < y; n++)
                                    o += data[n].x,
                                    r += data[n].y;
                                o /= _,
                                r /= _;
                                const v = Math.floor(i * l) + 1 + t
                                  , O = Math.min(Math.floor((i + 1) * l) + 1, e) + t
                                  , {x: w, y: M} = data[a];
                                for (m = area = -1,
                                n = v; n < O; n++)
                                    area = .5 * Math.abs((w - o) * (data[n].y - M) - (w - data[n].x) * (r - M)),
                                    area > m && (m = area,
                                    f = data[n],
                                    x = n);
                                c[h++] = f,
                                a = x
                            }
                            return c[h++] = data[d],
                            c
                        }(data, f, m, r, n);
                        break;
                    case "min-max":
                        x = function(data, t, e, n) {
                            let i, r, c, l, h, d, f, m, x, y, _ = 0, v = 0;
                            const O = []
                              , w = t + e - 1
                              , M = data[t].x
                              , j = data[w].x - M;
                            for (i = t; i < t + e; ++i) {
                                r = data[i],
                                c = (r.x - M) / j * n,
                                l = r.y;
                                const t = 0 | c;
                                if (t === h)
                                    l < x ? (x = l,
                                    d = i) : l > y && (y = l,
                                    f = i),
                                    _ = (v * _ + r.x) / ++v;
                                else {
                                    const e = i - 1;
                                    if (!Object(o.Ob)(d) && !Object(o.Ob)(f)) {
                                        const t = Math.min(d, f)
                                          , n = Math.max(d, f);
                                        t !== m && t !== e && O.push({
                                            ...data[t],
                                            x: _
                                        }),
                                        n !== m && n !== e && O.push({
                                            ...data[n],
                                            x: _
                                        })
                                    }
                                    i > 0 && e !== m && O.push(data[e]),
                                    O.push(r),
                                    h = t,
                                    v = 0,
                                    x = y = l,
                                    d = f = m = i
                                }
                            }
                            return O
                        }(data, f, m, r);
                        break;
                    default:
                        throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`)
                    }
                    e._decimated = x
                }
                ))
            }
            ,
            destroy(t) {
                Ue(t)
            }
        };
        function qe(t, e, n, r) {
            if (r)
                return;
            let c = e[t]
              , l = n[t];
            return "angle" === t && (c = Object(o.Bb)(c),
            l = Object(o.Bb)(l)),
            {
                property: t,
                start: c,
                end: l
            }
        }
        function Ke(t, e, n) {
            for (; e > t; e--) {
                const t = n[e];
                if (!isNaN(t.x) && !isNaN(t.y))
                    break
            }
            return e
        }
        function Je(a, b, t, e) {
            return a && b ? e(a[t], b[t]) : a ? a[t] : b ? b[t] : 0
        }
        function Ge(t, line) {
            let e = []
              , n = !1;
            return Object(o.Cb)(t) ? (n = !0,
            e = t) : e = function(t, line) {
                const {x: e=null, y: n=null} = t || {}
                  , o = line.points
                  , r = [];
                return line.segments.forEach((({start: t, end: c})=>{
                    c = Ke(t, c, o);
                    const l = o[t]
                      , h = o[c];
                    null !== n ? (r.push({
                        x: l.x,
                        y: n
                    }),
                    r.push({
                        x: h.x,
                        y: n
                    })) : null !== e && (r.push({
                        x: e,
                        y: l.y
                    }),
                    r.push({
                        x: e,
                        y: h.y
                    }))
                }
                )),
                r
            }(t, line),
            e.length ? new Re({
                points: e,
                options: {
                    tension: 0
                },
                _loop: n,
                _fullLoop: n
            }) : null
        }
        function Qe(source) {
            return source && !1 !== source.fill
        }
        function ti(t, e, n) {
            let r = t[e].fill;
            const c = [e];
            let l;
            if (!n)
                return r;
            for (; !1 !== r && -1 === c.indexOf(r); ) {
                if (!Object(o.Kb)(r))
                    return r;
                if (l = t[r],
                !l)
                    return !1;
                if (l.visible)
                    return r;
                c.push(r),
                r = l.fill
            }
            return !1
        }
        function ei(line, t, e) {
            const n = function(line) {
                const t = line.options
                  , e = t.fill;
                let n = Object(o.Zb)(e && e.target, e);
                void 0 === n && (n = !!t.backgroundColor);
                if (!1 === n || null === n)
                    return !1;
                if (!0 === n)
                    return "origin";
                return n
            }(line);
            if (Object(o.Mb)(n))
                return !isNaN(n.value) && n;
            let r = parseFloat(n);
            return Object(o.Kb)(r) && Math.floor(r) === r ? function(t, e, n, o) {
                "-" !== t && "+" !== t || (n = e + n);
                if (n === e || n < 0 || n >= o)
                    return !1;
                return n
            }(n[0], t, r, e) : ["origin", "start", "end", "stack", "shape"].indexOf(n) >= 0 && n
        }
        function ii(t, e, n) {
            const o = [];
            for (let r = 0; r < n.length; r++) {
                const line = n[r]
                  , {first: c, last: l, point: h} = ni(line, e, "x");
                if (!(!h || c && l))
                    if (c)
                        o.unshift(h);
                    else if (t.push(h),
                    !l)
                        break
            }
            t.push(...o)
        }
        function ni(line, t, e) {
            const n = line.interpolate(t, e);
            if (!n)
                return {};
            const r = n[e]
              , c = line.segments
              , l = line.points;
            let h = !1
              , d = !1;
            for (let i = 0; i < c.length; i++) {
                const t = c[i]
                  , n = l[t.start][e]
                  , f = l[t.end][e];
                if (Object(o.mb)(r, n, f)) {
                    h = r === n,
                    d = r === f;
                    break
                }
            }
            return {
                first: h,
                last: d,
                point: n
            }
        }
        class si {
            constructor(t) {
                this.x = t.x,
                this.y = t.y,
                this.radius = t.radius
            }
            pathSegment(t, e, n) {
                const {x: r, y: c, radius: l} = this;
                return e = e || {
                    start: 0,
                    end: o.u
                },
                t.arc(r, c, l, e.end, e.start, !0),
                !n.bounds
            }
            interpolate(t) {
                const {x: e, y: n, radius: o} = this
                  , r = t.angle;
                return {
                    x: e + Math.cos(r) * o,
                    y: n + Math.sin(r) * o,
                    angle: r
                }
            }
        }
        function oi(source) {
            const {chart: t, fill: e, line: line} = source;
            if (Object(o.Kb)(e))
                return function(t, e) {
                    const meta = t.getDatasetMeta(e)
                      , n = meta && t.isDatasetVisible(e);
                    return n ? meta.dataset : null
                }(t, e);
            if ("stack" === e)
                return function(source) {
                    const {scale: t, index: e, line: line} = source
                      , n = []
                      , o = line.segments
                      , r = line.points
                      , c = function(t, e) {
                        const n = []
                          , o = t.getMatchingVisibleMetas("line");
                        for (let i = 0; i < o.length; i++) {
                            const meta = o[i];
                            if (meta.index === e)
                                break;
                            meta.hidden || n.unshift(meta.dataset)
                        }
                        return n
                    }(t, e);
                    c.push(Ge({
                        x: null,
                        y: t.bottom
                    }, line));
                    for (let i = 0; i < o.length; i++) {
                        const t = o[i];
                        for (let e = t.start; e <= t.end; e++)
                            ii(n, r[e], c)
                    }
                    return new Re({
                        points: n,
                        options: {}
                    })
                }(source);
            if ("shape" === e)
                return !0;
            const n = function(source) {
                const t = source.scale || {};
                if (t.getPointPositionForValue)
                    return function(source) {
                        const {scale: t, fill: e} = source
                          , n = t.options
                          , r = t.getLabels().length
                          , c = n.reverse ? t.max : t.min
                          , l = function(t, e, n) {
                            let r;
                            return r = "start" === t ? n : "end" === t ? e.options.reverse ? e.min : e.max : Object(o.Mb)(t) ? t.value : e.getBaseValue(),
                            r
                        }(e, t, c)
                          , h = [];
                        if (n.grid.circular) {
                            const e = t.getPointPositionForValue(0, c);
                            return new si({
                                x: e.x,
                                y: e.y,
                                radius: t.getDistanceFromCenterForValue(l)
                            })
                        }
                        for (let i = 0; i < r; ++i)
                            h.push(t.getPointPositionForValue(i, l));
                        return h
                    }(source);
                return function(source) {
                    const {scale: t={}, fill: e} = source
                      , n = function(t, e) {
                        let n = null;
                        return "start" === t ? n = e.bottom : "end" === t ? n = e.top : Object(o.Mb)(t) ? n = e.getPixelForValue(t.value) : e.getBasePixel && (n = e.getBasePixel()),
                        n
                    }(e, t);
                    if (Object(o.Kb)(n)) {
                        const e = t.isHorizontal();
                        return {
                            x: e ? n : null,
                            y: e ? null : n
                        }
                    }
                    return null
                }(source)
            }(source);
            return n instanceof si ? n : Ge(n, line)
        }
        function ri(t, source, area) {
            const e = oi(source)
              , {line: line, scale: n, axis: r} = source
              , c = line.options
              , l = c.fill
              , h = c.backgroundColor
              , {above: d=h, below: f=h} = l || {};
            e && line.points.length && (Object(o.m)(t, area),
            function(t, e) {
                const {line: line, target: n, above: o, below: r, area: area, scale: c} = e
                  , l = line._loop ? "angle" : e.axis;
                t.save(),
                "x" === l && r !== o && (ai(t, n, area.top),
                ci(t, {
                    line: line,
                    target: n,
                    color: o,
                    scale: c,
                    property: l
                }),
                t.restore(),
                t.save(),
                ai(t, n, area.bottom));
                ci(t, {
                    line: line,
                    target: n,
                    color: r,
                    scale: c,
                    property: l
                }),
                t.restore()
            }(t, {
                line: line,
                target: e,
                above: d,
                below: f,
                area: area,
                scale: n,
                axis: r
            }),
            Object(o.o)(t))
        }
        function ai(t, e, n) {
            const {segments: o, points: r} = e;
            let c = !0
              , l = !1;
            t.beginPath();
            for (const h of o) {
                const {start: o, end: d} = h
                  , f = r[o]
                  , m = r[Ke(o, d, r)];
                c ? (t.moveTo(f.x, f.y),
                c = !1) : (t.lineTo(f.x, n),
                t.lineTo(f.x, f.y)),
                l = !!e.pathSegment(t, h, {
                    move: l
                }),
                l ? t.closePath() : t.lineTo(m.x, n)
            }
            t.lineTo(e.first().x, n),
            t.closePath(),
            t.clip()
        }
        function ci(t, e) {
            const {line: line, target: n, property: r, color: c, scale: l} = e
              , h = function(line, t, e) {
                const n = line.segments
                  , r = line.points
                  , c = t.points
                  , l = [];
                for (const h of n) {
                    let {start: n, end: d} = h;
                    d = Ke(n, d, r);
                    const f = qe(e, r[n], r[d], h.loop);
                    if (!t.segments) {
                        l.push({
                            source: h,
                            target: f,
                            start: r[n],
                            end: r[d]
                        });
                        continue
                    }
                    const m = Object(o.qb)(t, f);
                    for (const t of m) {
                        const n = qe(e, c[t.start], c[t.end], t.loop)
                          , d = Object(o.Ab)(h, r, n);
                        for (const o of d)
                            l.push({
                                source: o,
                                target: t,
                                start: {
                                    [e]: Je(f, n, "start", Math.max)
                                },
                                end: {
                                    [e]: Je(f, n, "end", Math.min)
                                }
                            })
                    }
                }
                return l
            }(line, n, r);
            for (const {source: e, target: o, start: d, end: f} of h) {
                const {style: {backgroundColor: h=c}={}} = e
                  , m = !0 !== n;
                t.save(),
                t.fillStyle = h,
                hi(t, l, m && qe(r, d, f)),
                t.beginPath();
                const x = !!line.pathSegment(t, e);
                let y;
                if (m) {
                    x ? t.closePath() : di(t, n, f, r);
                    const e = !!n.pathSegment(t, o, {
                        move: x,
                        reverse: !0
                    });
                    y = x && e,
                    y || di(t, n, d, r)
                }
                t.closePath(),
                t.fill(y ? "evenodd" : "nonzero"),
                t.restore()
            }
        }
        function hi(t, e, n) {
            const {top: o, bottom: r} = e.chart.chartArea
              , {property: c, start: l, end: h} = n || {};
            "x" === c && (t.beginPath(),
            t.rect(l, o, h - l, r - o),
            t.clip())
        }
        function di(t, e, n, o) {
            const r = e.interpolate(n, o);
            r && t.lineTo(r.x, r.y)
        }
        var ui = {
            id: "filler",
            afterDatasetsUpdate(t, e, n) {
                const o = (t.data.datasets || []).length
                  , r = [];
                let meta, i, line, source;
                for (i = 0; i < o; ++i)
                    meta = t.getDatasetMeta(i),
                    line = meta.dataset,
                    source = null,
                    line && line.options && line instanceof Re && (source = {
                        visible: t.isDatasetVisible(i),
                        index: i,
                        fill: ei(line, i, o),
                        chart: t,
                        axis: meta.controller.options.indexAxis,
                        scale: meta.vScale,
                        line: line
                    }),
                    meta.$filler = source,
                    r.push(source);
                for (i = 0; i < o; ++i)
                    source = r[i],
                    source && !1 !== source.fill && (source.fill = ti(r, i, n.propagate))
            },
            beforeDraw(t, e, n) {
                const o = "beforeDraw" === n.drawTime
                  , r = t.getSortedVisibleDatasetMetas()
                  , area = t.chartArea;
                for (let i = r.length - 1; i >= 0; --i) {
                    const source = r[i].$filler;
                    source && (source.line.updateControlPoints(area, source.axis),
                    o && source.fill && ri(t.ctx, source, area))
                }
            },
            beforeDatasetsDraw(t, e, n) {
                if ("beforeDatasetsDraw" !== n.drawTime)
                    return;
                const o = t.getSortedVisibleDatasetMetas();
                for (let i = o.length - 1; i >= 0; --i) {
                    const source = o[i].$filler;
                    Qe(source) && ri(t.ctx, source, t.chartArea)
                }
            },
            beforeDatasetDraw(t, e, n) {
                const source = e.meta.$filler;
                Qe(source) && "beforeDatasetDraw" === n.drawTime && ri(t.ctx, source, t.chartArea)
            },
            defaults: {
                propagate: !0,
                drawTime: "beforeDatasetDraw"
            }
        };
        const fi = (t,e)=>{
            let {boxHeight: n=e, boxWidth: o=e} = t;
            return t.usePointStyle && (n = Math.min(n, e),
            o = t.pointStyleWidth || Math.min(o, e)),
            {
                boxWidth: o,
                boxHeight: n,
                itemHeight: Math.max(e, n)
            }
        }
        ;
        class bi extends Y {
            constructor(t) {
                super(),
                this._added = !1,
                this.legendHitBoxes = [],
                this._hoveredItem = null,
                this.doughnutMode = !1,
                this.chart = t.chart,
                this.options = t.options,
                this.ctx = t.ctx,
                this.legendItems = void 0,
                this.columnSizes = void 0,
                this.lineWidths = void 0,
                this.maxHeight = void 0,
                this.maxWidth = void 0,
                this.top = void 0,
                this.bottom = void 0,
                this.left = void 0,
                this.right = void 0,
                this.height = void 0,
                this.width = void 0,
                this._margins = void 0,
                this.position = void 0,
                this.weight = void 0,
                this.fullSize = void 0
            }
            update(t, e, n) {
                this.maxWidth = t,
                this.maxHeight = e,
                this._margins = n,
                this.setDimensions(),
                this.buildLabels(),
                this.fit()
            }
            setDimensions() {
                this.isHorizontal() ? (this.width = this.maxWidth,
                this.left = this._margins.left,
                this.right = this.width) : (this.height = this.maxHeight,
                this.top = this._margins.top,
                this.bottom = this.height)
            }
            buildLabels() {
                const t = this.options.labels || {};
                let e = Object(o.d)(t.generateLabels, [this.chart], this) || [];
                t.filter && (e = e.filter((e=>t.filter(e, this.chart.data)))),
                t.sort && (e = e.sort(((a,b)=>t.sort(a, b, this.chart.data)))),
                this.options.reverse && e.reverse(),
                this.legendItems = e
            }
            fit() {
                const {options: t, ctx: e} = this;
                if (!t.display)
                    return void (this.width = this.height = 0);
                const n = t.labels
                  , r = Object(o.p)(n.font)
                  , c = r.size
                  , l = this._computeTitleHeight()
                  , {boxWidth: h, itemHeight: d} = fi(n, c);
                let f, m;
                e.font = r.string,
                this.isHorizontal() ? (f = this.maxWidth,
                m = this._fitRows(l, c, h, d) + 10) : (m = this.maxHeight,
                f = this._fitCols(l, c, h, d) + 10),
                this.width = Math.min(f, t.maxWidth || this.maxWidth),
                this.height = Math.min(m, t.maxHeight || this.maxHeight)
            }
            _fitRows(t, e, n, o) {
                const {ctx: r, maxWidth: c, options: {labels: {padding: l}}} = this
                  , h = this.legendHitBoxes = []
                  , d = this.lineWidths = [0]
                  , f = o + l;
                let m = t;
                r.textAlign = "left",
                r.textBaseline = "middle";
                let x = -1
                  , y = -f;
                return this.legendItems.forEach(((t,i)=>{
                    const _ = n + e / 2 + r.measureText(t.text).width;
                    (0 === i || d[d.length - 1] + _ + 2 * l > c) && (m += f,
                    d[d.length - (i > 0 ? 0 : 1)] = 0,
                    y += f,
                    x++),
                    h[i] = {
                        left: 0,
                        top: y,
                        row: x,
                        width: _,
                        height: o
                    },
                    d[d.length - 1] += _ + l
                }
                )),
                m
            }
            _fitCols(t, e, n, o) {
                const {ctx: r, maxHeight: c, options: {labels: {padding: l}}} = this
                  , h = this.legendHitBoxes = []
                  , d = this.columnSizes = []
                  , f = c - t;
                let m = l
                  , x = 0
                  , y = 0
                  , _ = 0
                  , col = 0;
                return this.legendItems.forEach(((t,i)=>{
                    const c = n + e / 2 + r.measureText(t.text).width;
                    i > 0 && y + o + 2 * l > f && (m += x + l,
                    d.push({
                        width: x,
                        height: y
                    }),
                    _ += x + l,
                    col++,
                    x = y = 0),
                    h[i] = {
                        left: _,
                        top: y,
                        col: col,
                        width: c,
                        height: o
                    },
                    x = Math.max(x, c),
                    y += o + l
                }
                )),
                m += x,
                d.push({
                    width: x,
                    height: y
                }),
                m
            }
            adjustHitBoxes() {
                if (!this.options.display)
                    return;
                const t = this._computeTitleHeight()
                  , {legendHitBoxes: e, options: {align: n, labels: {padding: r}, rtl: c}} = this
                  , l = Object(o.N)(c, this.left, this.width);
                if (this.isHorizontal()) {
                    let c = 0
                      , h = Object(o.t)(n, this.left + r, this.right - this.lineWidths[c]);
                    for (const d of e)
                        c !== d.row && (c = d.row,
                        h = Object(o.t)(n, this.left + r, this.right - this.lineWidths[c])),
                        d.top += this.top + t + r,
                        d.left = l.leftForLtr(l.x(h), d.width),
                        h += d.width + r
                } else {
                    let col = 0
                      , c = Object(o.t)(n, this.top + t + r, this.bottom - this.columnSizes[col].height);
                    for (const h of e)
                        h.col !== col && (col = h.col,
                        c = Object(o.t)(n, this.top + t + r, this.bottom - this.columnSizes[col].height)),
                        h.top = c,
                        h.left += this.left + r,
                        h.left = l.leftForLtr(l.x(h.left), h.width),
                        c += h.height + r
                }
            }
            isHorizontal() {
                return "top" === this.options.position || "bottom" === this.options.position
            }
            draw() {
                if (this.options.display) {
                    const t = this.ctx;
                    Object(o.m)(t, this),
                    this._draw(),
                    Object(o.o)(t)
                }
            }
            _draw() {
                const {options: t, columnSizes: e, lineWidths: n, ctx: r} = this
                  , {align: c, labels: l} = t
                  , h = o.Hb.color
                  , d = Object(o.N)(t.rtl, this.left, this.width)
                  , f = Object(o.p)(l.font)
                  , {color: m, padding: x} = l
                  , y = f.size
                  , _ = y / 2;
                let cursor;
                this.drawTitle(),
                r.textAlign = d.textAlign("left"),
                r.textBaseline = "middle",
                r.lineWidth = .5,
                r.font = f.string;
                const {boxWidth: v, boxHeight: O, itemHeight: w} = fi(l, y)
                  , M = this.isHorizontal()
                  , j = this._computeTitleHeight();
                cursor = M ? {
                    x: Object(o.t)(c, this.left + x, this.right - n[0]),
                    y: this.top + x + j,
                    line: 0
                } : {
                    x: this.left + x,
                    y: Object(o.t)(c, this.top + j + x, this.bottom - e[0].height),
                    line: 0
                },
                Object(o.O)(this.ctx, t.textDirection);
                const k = w + x;
                this.legendItems.forEach(((S,i)=>{
                    r.strokeStyle = S.fontColor || m,
                    r.fillStyle = S.fontColor || m;
                    const P = r.measureText(S.text).width
                      , C = d.textAlign(S.textAlign || (S.textAlign = l.textAlign))
                      , D = v + _ + P;
                    let A = cursor.x
                      , T = cursor.y;
                    d.setWidth(this.width),
                    M ? i > 0 && A + D + x > this.right && (T = cursor.y += k,
                    cursor.line++,
                    A = cursor.x = Object(o.t)(c, this.left + x, this.right - n[cursor.line])) : i > 0 && T + k > this.bottom && (A = cursor.x = A + e[cursor.line].width + x,
                    cursor.line++,
                    T = cursor.y = Object(o.t)(c, this.top + j + x, this.bottom - e[cursor.line].height));
                    !function(t, e, n) {
                        if (isNaN(v) || v <= 0 || isNaN(O) || O < 0)
                            return;
                        r.save();
                        const c = Object(o.Zb)(n.lineWidth, 1);
                        if (r.fillStyle = Object(o.Zb)(n.fillStyle, h),
                        r.lineCap = Object(o.Zb)(n.lineCap, "butt"),
                        r.lineDashOffset = Object(o.Zb)(n.lineDashOffset, 0),
                        r.lineJoin = Object(o.Zb)(n.lineJoin, "miter"),
                        r.lineWidth = c,
                        r.strokeStyle = Object(o.Zb)(n.strokeStyle, h),
                        r.setLineDash(Object(o.Zb)(n.lineDash, [])),
                        l.usePointStyle) {
                            const h = {
                                radius: O * Math.SQRT2 / 2,
                                pointStyle: n.pointStyle,
                                rotation: n.rotation,
                                borderWidth: c
                            }
                              , f = d.xPlus(t, v / 2)
                              , m = e + _;
                            Object(o.R)(r, h, f, m, l.pointStyleWidth && v)
                        } else {
                            const l = e + Math.max((y - O) / 2, 0)
                              , h = d.leftForLtr(t, v)
                              , f = Object(o.zb)(n.borderRadius);
                            r.beginPath(),
                            Object.values(f).some((t=>0 !== t)) ? Object(o.xb)(r, {
                                x: h,
                                y: l,
                                w: v,
                                h: O,
                                radius: f
                            }) : r.rect(h, l, v, O),
                            r.fill(),
                            0 !== c && r.stroke()
                        }
                        r.restore()
                    }(d.x(A), T, S),
                    A = Object(o.P)(C, A + v + _, M ? A + D : this.right, t.rtl),
                    function(t, e, n) {
                        Object(o.n)(r, n.text, t, e + w / 2, f, {
                            strikethrough: n.hidden,
                            textAlign: d.textAlign(n.textAlign)
                        })
                    }(d.x(A), T, S),
                    M ? cursor.x += D + x : cursor.y += k
                }
                )),
                Object(o.Q)(this.ctx, t.textDirection)
            }
            drawTitle() {
                const t = this.options
                  , e = t.title
                  , n = Object(o.p)(e.font)
                  , r = Object(o.l)(e.padding);
                if (!e.display)
                    return;
                const c = Object(o.N)(t.rtl, this.left, this.width)
                  , l = this.ctx
                  , h = e.position
                  , d = n.size / 2
                  , f = r.top + d;
                let m, x = this.left, y = this.width;
                if (this.isHorizontal())
                    y = Math.max(...this.lineWidths),
                    m = this.top + f,
                    x = Object(o.t)(t.align, x, this.right - y);
                else {
                    const e = this.columnSizes.reduce(((t,e)=>Math.max(t, e.height)), 0);
                    m = f + Object(o.t)(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight())
                }
                const _ = Object(o.t)(h, x, x + y);
                l.textAlign = c.textAlign(Object(o.s)(h)),
                l.textBaseline = "middle",
                l.strokeStyle = e.color,
                l.fillStyle = e.color,
                l.font = n.string,
                Object(o.n)(l, e.text, _, m, n)
            }
            _computeTitleHeight() {
                const t = this.options.title
                  , e = Object(o.p)(t.font)
                  , n = Object(o.l)(t.padding);
                return t.display ? e.lineHeight + n.height : 0
            }
            _getLegendItemAt(t, e) {
                let i, n, r;
                if (Object(o.mb)(t, this.left, this.right) && Object(o.mb)(e, this.top, this.bottom))
                    for (r = this.legendHitBoxes,
                    i = 0; i < r.length; ++i)
                        if (n = r[i],
                        Object(o.mb)(t, n.left, n.left + n.width) && Object(o.mb)(e, n.top, n.top + n.height))
                            return this.legendItems[i];
                return null
            }
            handleEvent(t) {
                const e = this.options;
                if (!function(t, e) {
                    if (("mousemove" === t || "mouseout" === t) && (e.onHover || e.onLeave))
                        return !0;
                    if (e.onClick && ("click" === t || "mouseup" === t))
                        return !0;
                    return !1
                }(t.type, e))
                    return;
                const n = this._getLegendItemAt(t.x, t.y);
                if ("mousemove" === t.type || "mouseout" === t.type) {
                    const r = this._hoveredItem
                      , c = (b = n,
                    null !== (a = r) && null !== b && a.datasetIndex === b.datasetIndex && a.index === b.index);
                    r && !c && Object(o.d)(e.onLeave, [t, r, this], this),
                    this._hoveredItem = n,
                    n && !c && Object(o.d)(e.onHover, [t, n, this], this)
                } else
                    n && Object(o.d)(e.onClick, [t, n, this], this);
                var a, b
            }
        }
        var gi = {
            id: "legend",
            _element: bi,
            start(t, e, n) {
                const legend = t.legend = new bi({
                    ctx: t.ctx,
                    options: n,
                    chart: t
                });
                At.configure(t, legend, n),
                At.addBox(t, legend)
            },
            stop(t) {
                At.removeBox(t, t.legend),
                delete t.legend
            },
            beforeUpdate(t, e, n) {
                const legend = t.legend;
                At.configure(t, legend, n),
                legend.options = n
            },
            afterUpdate(t) {
                const legend = t.legend;
                legend.buildLabels(),
                legend.adjustHitBoxes()
            },
            afterEvent(t, e) {
                e.replay || t.legend.handleEvent(e.event)
            },
            defaults: {
                display: !0,
                position: "top",
                align: "center",
                fullSize: !0,
                reverse: !1,
                weight: 1e3,
                onClick(t, e, legend) {
                    const n = e.datasetIndex
                      , o = legend.chart;
                    o.isDatasetVisible(n) ? (o.hide(n),
                    e.hidden = !0) : (o.show(n),
                    e.hidden = !1)
                },
                onHover: null,
                onLeave: null,
                labels: {
                    color: t=>t.chart.options.color,
                    boxWidth: 40,
                    padding: 10,
                    generateLabels(t) {
                        const e = t.data.datasets
                          , {labels: {usePointStyle: n, pointStyle: r, textAlign: c, color: l}} = t.legend.options;
                        return t._getSortedDatasetMetas().map((meta=>{
                            const style = meta.controller.getStyle(n ? 0 : void 0)
                              , t = Object(o.l)(style.borderWidth);
                            return {
                                text: e[meta.index].label,
                                fillStyle: style.backgroundColor,
                                fontColor: l,
                                hidden: !meta.visible,
                                lineCap: style.borderCapStyle,
                                lineDash: style.borderDash,
                                lineDashOffset: style.borderDashOffset,
                                lineJoin: style.borderJoinStyle,
                                lineWidth: (t.width + t.height) / 4,
                                strokeStyle: style.borderColor,
                                pointStyle: r || style.pointStyle,
                                rotation: style.rotation,
                                textAlign: c || style.textAlign,
                                borderRadius: 0,
                                datasetIndex: meta.index
                            }
                        }
                        ), this)
                    }
                },
                title: {
                    color: t=>t.chart.options.color,
                    display: !1,
                    position: "center",
                    text: ""
                }
            },
            descriptors: {
                _scriptable: t=>!t.startsWith("on"),
                labels: {
                    _scriptable: t=>!["generateLabels", "filter", "sort"].includes(t)
                }
            }
        };
        class pi extends Y {
            constructor(t) {
                super(),
                this.chart = t.chart,
                this.options = t.options,
                this.ctx = t.ctx,
                this._padding = void 0,
                this.top = void 0,
                this.bottom = void 0,
                this.left = void 0,
                this.right = void 0,
                this.width = void 0,
                this.height = void 0,
                this.position = void 0,
                this.weight = void 0,
                this.fullSize = void 0
            }
            update(t, e) {
                const n = this.options;
                if (this.left = 0,
                this.top = 0,
                !n.display)
                    return void (this.width = this.height = this.right = this.bottom = 0);
                this.width = this.right = t,
                this.height = this.bottom = e;
                const r = Object(o.Cb)(n.text) ? n.text.length : 1;
                this._padding = Object(o.l)(n.padding);
                const c = r * Object(o.p)(n.font).lineHeight + this._padding.height;
                this.isHorizontal() ? this.height = c : this.width = c
            }
            isHorizontal() {
                const t = this.options.position;
                return "top" === t || "bottom" === t
            }
            _drawArgs(t) {
                const {top: e, left: n, bottom: r, right: c, options: l} = this
                  , h = l.align;
                let d, f, m, x = 0;
                return this.isHorizontal() ? (f = Object(o.t)(h, n, c),
                m = e + t,
                d = c - n) : ("left" === l.position ? (f = n + t,
                m = Object(o.t)(h, r, e),
                x = -.5 * o.q) : (f = c - t,
                m = Object(o.t)(h, e, r),
                x = .5 * o.q),
                d = r - e),
                {
                    titleX: f,
                    titleY: m,
                    maxWidth: d,
                    rotation: x
                }
            }
            draw() {
                const t = this.ctx
                  , e = this.options;
                if (!e.display)
                    return;
                const n = Object(o.p)(e.font)
                  , r = n.lineHeight / 2 + this._padding.top
                  , {titleX: c, titleY: l, maxWidth: h, rotation: d} = this._drawArgs(r);
                Object(o.n)(t, e.text, 0, 0, n, {
                    color: e.color,
                    maxWidth: h,
                    rotation: d,
                    textAlign: Object(o.s)(e.align),
                    textBaseline: "middle",
                    translation: [c, l]
                })
            }
        }
        var mi = {
            id: "title",
            _element: pi,
            start(t, e, n) {
                !function(t, e) {
                    const title = new pi({
                        ctx: t.ctx,
                        options: e,
                        chart: t
                    });
                    At.configure(t, title, e),
                    At.addBox(t, title),
                    t.titleBlock = title
                }(t, n)
            },
            stop(t) {
                const e = t.titleBlock;
                At.removeBox(t, e),
                delete t.titleBlock
            },
            beforeUpdate(t, e, n) {
                const title = t.titleBlock;
                At.configure(t, title, n),
                title.options = n
            },
            defaults: {
                align: "center",
                display: !1,
                font: {
                    weight: "bold"
                },
                fullSize: !0,
                padding: 10,
                position: "top",
                text: "",
                weight: 2e3
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: !0,
                _indexable: !1
            }
        };
        const map = new WeakMap;
        var xi = {
            id: "subtitle",
            start(t, e, n) {
                const title = new pi({
                    ctx: t.ctx,
                    options: n,
                    chart: t
                });
                At.configure(t, title, n),
                At.addBox(t, title),
                map.set(t, title)
            },
            stop(t) {
                At.removeBox(t, map.get(t)),
                map.delete(t)
            },
            beforeUpdate(t, e, n) {
                const title = map.get(t);
                At.configure(t, title, n),
                title.options = n
            },
            defaults: {
                align: "center",
                display: !1,
                font: {
                    weight: "normal"
                },
                fullSize: !0,
                padding: 0,
                position: "top",
                text: "",
                weight: 1500
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: !0,
                _indexable: !1
            }
        };
        const yi = {
            average(t) {
                if (!t.length)
                    return !1;
                let i, e, n = 0, o = 0, r = 0;
                for (i = 0,
                e = t.length; i < e; ++i) {
                    const e = t[i].element;
                    if (e && e.hasValue()) {
                        const t = e.tooltipPosition();
                        n += t.x,
                        o += t.y,
                        ++r
                    }
                }
                return {
                    x: n / r,
                    y: o / r
                }
            },
            nearest(t, e) {
                if (!t.length)
                    return !1;
                let i, n, r, c = e.x, l = e.y, h = Number.POSITIVE_INFINITY;
                for (i = 0,
                n = t.length; i < n; ++i) {
                    const n = t[i].element;
                    if (n && n.hasValue()) {
                        const t = n.getCenterPoint()
                          , c = Object(o.T)(e, t);
                        c < h && (h = c,
                        r = n)
                    }
                }
                if (r) {
                    const t = r.tooltipPosition();
                    c = t.x,
                    l = t.y
                }
                return {
                    x: c,
                    y: l
                }
            }
        };
        function _i(base, t) {
            return t && (Object(o.Cb)(t) ? Array.prototype.push.apply(base, t) : base.push(t)),
            base
        }
        function vi(t) {
            return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t
        }
        function Oi(t, e) {
            const {element: element, datasetIndex: n, index: o} = e
              , r = t.getDatasetMeta(n).controller
              , {label: label, value: c} = r.getLabelAndValue(o);
            return {
                chart: t,
                label: label,
                parsed: r.getParsed(o),
                raw: t.data.datasets[n].data[o],
                formattedValue: c,
                dataset: r.getDataset(),
                dataIndex: o,
                datasetIndex: n,
                element: element
            }
        }
        function wi(t, e) {
            const n = t.chart.ctx
              , {body: body, footer: footer, title: title} = t
              , {boxWidth: r, boxHeight: c} = e
              , l = Object(o.p)(e.bodyFont)
              , h = Object(o.p)(e.titleFont)
              , d = Object(o.p)(e.footerFont)
              , f = title.length
              , m = footer.length
              , x = body.length
              , y = Object(o.l)(e.padding);
            let _ = y.height
              , v = 0
              , O = body.reduce(((t,e)=>t + e.before.length + e.lines.length + e.after.length), 0);
            if (O += t.beforeBody.length + t.afterBody.length,
            f && (_ += f * h.lineHeight + (f - 1) * e.titleSpacing + e.titleMarginBottom),
            O) {
                _ += x * (e.displayColors ? Math.max(c, l.lineHeight) : l.lineHeight) + (O - x) * l.lineHeight + (O - 1) * e.bodySpacing
            }
            m && (_ += e.footerMarginTop + m * d.lineHeight + (m - 1) * e.footerSpacing);
            let w = 0;
            const M = function(line) {
                v = Math.max(v, n.measureText(line).width + w)
            };
            return n.save(),
            n.font = h.string,
            Object(o.r)(t.title, M),
            n.font = l.string,
            Object(o.r)(t.beforeBody.concat(t.afterBody), M),
            w = e.displayColors ? r + 2 + e.boxPadding : 0,
            Object(o.r)(body, (t=>{
                Object(o.r)(t.before, M),
                Object(o.r)(t.lines, M),
                Object(o.r)(t.after, M)
            }
            )),
            w = 0,
            n.font = d.string,
            Object(o.r)(t.footer, M),
            n.restore(),
            v += y.width,
            {
                width: v,
                height: _
            }
        }
        function Mi(t, e, n, o) {
            const {x: r, width: c} = n
              , {width: l, chartArea: {left: h, right: d}} = t;
            let f = "center";
            return "center" === o ? f = r <= (h + d) / 2 ? "left" : "right" : r <= c / 2 ? f = "left" : r >= l - c / 2 && (f = "right"),
            function(t, e, n, o) {
                const {x: r, width: c} = o
                  , l = n.caretSize + n.caretPadding;
                return "left" === t && r + c + l > e.width || "right" === t && r - c - l < 0 || void 0
            }(f, t, e, n) && (f = "center"),
            f
        }
        function ji(t, e, n) {
            const o = n.yAlign || e.yAlign || function(t, e) {
                const {y: n, height: o} = e;
                return n < o / 2 ? "top" : n > t.height - o / 2 ? "bottom" : "center"
            }(t, n);
            return {
                xAlign: n.xAlign || e.xAlign || Mi(t, e, n, o),
                yAlign: o
            }
        }
        function ki(t, e, n, r) {
            const {caretSize: c, caretPadding: l, cornerRadius: h} = t
              , {xAlign: d, yAlign: f} = n
              , m = c + l
              , {topLeft: x, topRight: y, bottomLeft: _, bottomRight: v} = Object(o.zb)(h);
            let O = function(t, e) {
                let {x: n, width: o} = t;
                return "right" === e ? n -= o : "center" === e && (n -= o / 2),
                n
            }(e, d);
            const w = function(t, e, n) {
                let {y: o, height: r} = t;
                return "top" === e ? o += n : o -= "bottom" === e ? r + n : r / 2,
                o
            }(e, f, m);
            return "center" === f ? "left" === d ? O += m : "right" === d && (O -= m) : "left" === d ? O -= Math.max(x, _) + c : "right" === d && (O += Math.max(y, v) + c),
            {
                x: Object(o.f)(O, 0, r.width - e.width),
                y: Object(o.f)(w, 0, r.height - e.height)
            }
        }
        function Si(t, e, n) {
            const r = Object(o.l)(n.padding);
            return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - r.right : t.x + r.left
        }
        function Pi(t) {
            return _i([], vi(t))
        }
        function Ci(t, e) {
            const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
            return n ? t.override(n) : t
        }
        class Di extends Y {
            constructor(t) {
                super(),
                this.opacity = 0,
                this._active = [],
                this._eventPosition = void 0,
                this._size = void 0,
                this._cachedAnimations = void 0,
                this._tooltipItems = [],
                this.$animations = void 0,
                this.$context = void 0,
                this.chart = t.chart || t._chart,
                this._chart = this.chart,
                this.options = t.options,
                this.dataPoints = void 0,
                this.title = void 0,
                this.beforeBody = void 0,
                this.body = void 0,
                this.afterBody = void 0,
                this.footer = void 0,
                this.xAlign = void 0,
                this.yAlign = void 0,
                this.x = void 0,
                this.y = void 0,
                this.height = void 0,
                this.width = void 0,
                this.caretX = void 0,
                this.caretY = void 0,
                this.labelColors = void 0,
                this.labelPointStyles = void 0,
                this.labelTextColors = void 0
            }
            initialize(t) {
                this.options = t,
                this._cachedAnimations = void 0,
                this.$context = void 0
            }
            _resolveAnimations() {
                const t = this._cachedAnimations;
                if (t)
                    return t;
                const e = this.chart
                  , n = this.options.setContext(this.getContext())
                  , o = n.enabled && e.options.animation && n.animations
                  , r = new f(this.chart,o);
                return o._cacheable && (this._cachedAnimations = Object.freeze(r)),
                r
            }
            getContext() {
                return this.$context || (this.$context = (t = this.chart.getContext(),
                e = this,
                n = this._tooltipItems,
                Object(o.Lb)(t, {
                    tooltip: e,
                    tooltipItems: n,
                    type: "tooltip"
                })));
                var t, e, n
            }
            getTitle(t, e) {
                const {callbacks: n} = e
                  , o = n.beforeTitle.apply(this, [t])
                  , title = n.title.apply(this, [t])
                  , r = n.afterTitle.apply(this, [t]);
                let c = [];
                return c = _i(c, vi(o)),
                c = _i(c, vi(title)),
                c = _i(c, vi(r)),
                c
            }
            getBeforeBody(t, e) {
                return Pi(e.callbacks.beforeBody.apply(this, [t]))
            }
            getBody(t, e) {
                const {callbacks: n} = e
                  , r = [];
                return Object(o.r)(t, (t=>{
                    const e = {
                        before: [],
                        lines: [],
                        after: []
                    }
                      , o = Ci(n, t);
                    _i(e.before, vi(o.beforeLabel.call(this, t))),
                    _i(e.lines, o.label.call(this, t)),
                    _i(e.after, vi(o.afterLabel.call(this, t))),
                    r.push(e)
                }
                )),
                r
            }
            getAfterBody(t, e) {
                return Pi(e.callbacks.afterBody.apply(this, [t]))
            }
            getFooter(t, e) {
                const {callbacks: n} = e
                  , o = n.beforeFooter.apply(this, [t])
                  , footer = n.footer.apply(this, [t])
                  , r = n.afterFooter.apply(this, [t]);
                let c = [];
                return c = _i(c, vi(o)),
                c = _i(c, vi(footer)),
                c = _i(c, vi(r)),
                c
            }
            _createItems(t) {
                const e = this._active
                  , data = this.chart.data
                  , n = []
                  , r = []
                  , c = [];
                let i, l, h = [];
                for (i = 0,
                l = e.length; i < l; ++i)
                    h.push(Oi(this.chart, e[i]));
                return t.filter && (h = h.filter(((element,e,n)=>t.filter(element, e, n, data)))),
                t.itemSort && (h = h.sort(((a,b)=>t.itemSort(a, b, data)))),
                Object(o.r)(h, (e=>{
                    const o = Ci(t.callbacks, e);
                    n.push(o.labelColor.call(this, e)),
                    r.push(o.labelPointStyle.call(this, e)),
                    c.push(o.labelTextColor.call(this, e))
                }
                )),
                this.labelColors = n,
                this.labelPointStyles = r,
                this.labelTextColors = c,
                this.dataPoints = h,
                h
            }
            update(t, e) {
                const n = this.options.setContext(this.getContext())
                  , o = this._active;
                let r, c = [];
                if (o.length) {
                    const t = yi[n.position].call(this, o, this._eventPosition);
                    c = this._createItems(n),
                    this.title = this.getTitle(c, n),
                    this.beforeBody = this.getBeforeBody(c, n),
                    this.body = this.getBody(c, n),
                    this.afterBody = this.getAfterBody(c, n),
                    this.footer = this.getFooter(c, n);
                    const e = this._size = wi(this, n)
                      , l = Object.assign({}, t, e)
                      , h = ji(this.chart, n, l)
                      , d = ki(n, l, h, this.chart);
                    this.xAlign = h.xAlign,
                    this.yAlign = h.yAlign,
                    r = {
                        opacity: 1,
                        x: d.x,
                        y: d.y,
                        width: e.width,
                        height: e.height,
                        caretX: t.x,
                        caretY: t.y
                    }
                } else
                    0 !== this.opacity && (r = {
                        opacity: 0
                    });
                this._tooltipItems = c,
                this.$context = void 0,
                r && this._resolveAnimations().update(this, r),
                t && n.external && n.external.call(this, {
                    chart: this.chart,
                    tooltip: this,
                    replay: e
                })
            }
            drawCaret(t, e, n, o) {
                const r = this.getCaretPosition(t, n, o);
                e.lineTo(r.x1, r.y1),
                e.lineTo(r.x2, r.y2),
                e.lineTo(r.x3, r.y3)
            }
            getCaretPosition(t, e, n) {
                const {xAlign: r, yAlign: c} = this
                  , {caretSize: l, cornerRadius: h} = n
                  , {topLeft: d, topRight: f, bottomLeft: m, bottomRight: x} = Object(o.zb)(h)
                  , {x: y, y: _} = t
                  , {width: v, height: O} = e;
                let w, M, j, k, S, P;
                return "center" === c ? (S = _ + O / 2,
                "left" === r ? (w = y,
                M = w - l,
                k = S + l,
                P = S - l) : (w = y + v,
                M = w + l,
                k = S - l,
                P = S + l),
                j = w) : (M = "left" === r ? y + Math.max(d, m) + l : "right" === r ? y + v - Math.max(f, x) - l : this.caretX,
                "top" === c ? (k = _,
                S = k - l,
                w = M - l,
                j = M + l) : (k = _ + O,
                S = k + l,
                w = M + l,
                j = M - l),
                P = k),
                {
                    x1: w,
                    x2: M,
                    x3: j,
                    y1: k,
                    y2: S,
                    y3: P
                }
            }
            drawTitle(t, e, n) {
                const title = this.title
                  , r = title.length;
                let c, l, i;
                if (r) {
                    const h = Object(o.N)(n.rtl, this.x, this.width);
                    for (t.x = Si(this, n.titleAlign, n),
                    e.textAlign = h.textAlign(n.titleAlign),
                    e.textBaseline = "middle",
                    c = Object(o.p)(n.titleFont),
                    l = n.titleSpacing,
                    e.fillStyle = n.titleColor,
                    e.font = c.string,
                    i = 0; i < r; ++i)
                        e.fillText(title[i], h.x(t.x), t.y + c.lineHeight / 2),
                        t.y += c.lineHeight + l,
                        i + 1 === r && (t.y += n.titleMarginBottom - l)
                }
            }
            _drawColorBox(t, e, i, n, r) {
                const c = this.labelColors[i]
                  , l = this.labelPointStyles[i]
                  , {boxHeight: h, boxWidth: d, boxPadding: f} = r
                  , m = Object(o.p)(r.bodyFont)
                  , x = Si(this, "left", r)
                  , y = n.x(x)
                  , _ = h < m.lineHeight ? (m.lineHeight - h) / 2 : 0
                  , v = e.y + _;
                if (r.usePointStyle) {
                    const e = {
                        radius: Math.min(d, h) / 2,
                        pointStyle: l.pointStyle,
                        rotation: l.rotation,
                        borderWidth: 1
                    }
                      , f = n.leftForLtr(y, d) + d / 2
                      , m = v + h / 2;
                    t.strokeStyle = r.multiKeyBackground,
                    t.fillStyle = r.multiKeyBackground,
                    Object(o.wb)(t, e, f, m),
                    t.strokeStyle = c.borderColor,
                    t.fillStyle = c.backgroundColor,
                    Object(o.wb)(t, e, f, m)
                } else {
                    t.lineWidth = Object(o.Mb)(c.borderWidth) ? Math.max(...Object.values(c.borderWidth)) : c.borderWidth || 1,
                    t.strokeStyle = c.borderColor,
                    t.setLineDash(c.borderDash || []),
                    t.lineDashOffset = c.borderDashOffset || 0;
                    const e = n.leftForLtr(y, d - f)
                      , l = n.leftForLtr(n.xPlus(y, 1), d - f - 2)
                      , m = Object(o.zb)(c.borderRadius);
                    Object.values(m).some((t=>0 !== t)) ? (t.beginPath(),
                    t.fillStyle = r.multiKeyBackground,
                    Object(o.xb)(t, {
                        x: e,
                        y: v,
                        w: d,
                        h: h,
                        radius: m
                    }),
                    t.fill(),
                    t.stroke(),
                    t.fillStyle = c.backgroundColor,
                    t.beginPath(),
                    Object(o.xb)(t, {
                        x: l,
                        y: v + 1,
                        w: d - 2,
                        h: h - 2,
                        radius: m
                    }),
                    t.fill()) : (t.fillStyle = r.multiKeyBackground,
                    t.fillRect(e, v, d, h),
                    t.strokeRect(e, v, d, h),
                    t.fillStyle = c.backgroundColor,
                    t.fillRect(l, v + 1, d - 2, h - 2))
                }
                t.fillStyle = this.labelTextColors[i]
            }
            drawBody(t, e, n) {
                const {body: body} = this
                  , {bodySpacing: r, bodyAlign: c, displayColors: l, boxHeight: h, boxWidth: d, boxPadding: f} = n
                  , m = Object(o.p)(n.bodyFont);
                let x = m.lineHeight
                  , y = 0;
                const _ = Object(o.N)(n.rtl, this.x, this.width)
                  , v = function(line) {
                    e.fillText(line, _.x(t.x + y), t.y + x / 2),
                    t.y += x + r
                }
                  , O = _.textAlign(c);
                let w, M, j, i, k, S, P;
                for (e.textAlign = c,
                e.textBaseline = "middle",
                e.font = m.string,
                t.x = Si(this, O, n),
                e.fillStyle = n.bodyColor,
                Object(o.r)(this.beforeBody, v),
                y = l && "right" !== O ? "center" === c ? d / 2 + f : d + 2 + f : 0,
                i = 0,
                S = body.length; i < S; ++i) {
                    for (w = body[i],
                    M = this.labelTextColors[i],
                    e.fillStyle = M,
                    Object(o.r)(w.before, v),
                    j = w.lines,
                    l && j.length && (this._drawColorBox(e, t, i, _, n),
                    x = Math.max(m.lineHeight, h)),
                    k = 0,
                    P = j.length; k < P; ++k)
                        v(j[k]),
                        x = m.lineHeight;
                    Object(o.r)(w.after, v)
                }
                y = 0,
                x = m.lineHeight,
                Object(o.r)(this.afterBody, v),
                t.y -= r
            }
            drawFooter(t, e, n) {
                const footer = this.footer
                  , r = footer.length;
                let c, i;
                if (r) {
                    const l = Object(o.N)(n.rtl, this.x, this.width);
                    for (t.x = Si(this, n.footerAlign, n),
                    t.y += n.footerMarginTop,
                    e.textAlign = l.textAlign(n.footerAlign),
                    e.textBaseline = "middle",
                    c = Object(o.p)(n.footerFont),
                    e.fillStyle = n.footerColor,
                    e.font = c.string,
                    i = 0; i < r; ++i)
                        e.fillText(footer[i], l.x(t.x), t.y + c.lineHeight / 2),
                        t.y += c.lineHeight + n.footerSpacing
                }
            }
            drawBackground(t, e, n, r) {
                const {xAlign: c, yAlign: l} = this
                  , {x: h, y: d} = t
                  , {width: f, height: m} = n
                  , {topLeft: x, topRight: y, bottomLeft: _, bottomRight: v} = Object(o.zb)(r.cornerRadius);
                e.fillStyle = r.backgroundColor,
                e.strokeStyle = r.borderColor,
                e.lineWidth = r.borderWidth,
                e.beginPath(),
                e.moveTo(h + x, d),
                "top" === l && this.drawCaret(t, e, n, r),
                e.lineTo(h + f - y, d),
                e.quadraticCurveTo(h + f, d, h + f, d + y),
                "center" === l && "right" === c && this.drawCaret(t, e, n, r),
                e.lineTo(h + f, d + m - v),
                e.quadraticCurveTo(h + f, d + m, h + f - v, d + m),
                "bottom" === l && this.drawCaret(t, e, n, r),
                e.lineTo(h + _, d + m),
                e.quadraticCurveTo(h, d + m, h, d + m - _),
                "center" === l && "left" === c && this.drawCaret(t, e, n, r),
                e.lineTo(h, d + x),
                e.quadraticCurveTo(h, d, h + x, d),
                e.closePath(),
                e.fill(),
                r.borderWidth > 0 && e.stroke()
            }
            _updateAnimationTarget(t) {
                const e = this.chart
                  , n = this.$animations
                  , o = n && n.x
                  , r = n && n.y;
                if (o || r) {
                    const n = yi[t.position].call(this, this._active, this._eventPosition);
                    if (!n)
                        return;
                    const c = this._size = wi(this, t)
                      , l = Object.assign({}, n, this._size)
                      , h = ji(e, t, l)
                      , d = ki(t, l, h, e);
                    o._to === d.x && r._to === d.y || (this.xAlign = h.xAlign,
                    this.yAlign = h.yAlign,
                    this.width = c.width,
                    this.height = c.height,
                    this.caretX = n.x,
                    this.caretY = n.y,
                    this._resolveAnimations().update(this, d))
                }
            }
            _willRender() {
                return !!this.opacity
            }
            draw(t) {
                const e = this.options.setContext(this.getContext());
                let n = this.opacity;
                if (!n)
                    return;
                this._updateAnimationTarget(e);
                const r = {
                    width: this.width,
                    height: this.height
                }
                  , c = {
                    x: this.x,
                    y: this.y
                };
                n = Math.abs(n) < .001 ? 0 : n;
                const l = Object(o.l)(e.padding)
                  , h = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
                e.enabled && h && (t.save(),
                t.globalAlpha = n,
                this.drawBackground(c, t, r, e),
                Object(o.O)(t, e.textDirection),
                c.y += l.top,
                this.drawTitle(c, t, e),
                this.drawBody(c, t, e),
                this.drawFooter(c, t, e),
                Object(o.Q)(t, e.textDirection),
                t.restore())
            }
            getActiveElements() {
                return this._active || []
            }
            setActiveElements(t, e) {
                const n = this._active
                  , r = t.map((({datasetIndex: t, index: e})=>{
                    const meta = this.chart.getDatasetMeta(t);
                    if (!meta)
                        throw new Error("Cannot find a dataset at index " + t);
                    return {
                        datasetIndex: t,
                        element: meta.data[e],
                        index: e
                    }
                }
                ))
                  , c = !Object(o.kb)(n, r)
                  , l = this._positionChanged(r, e);
                (c || l) && (this._active = r,
                this._eventPosition = e,
                this._ignoreReplayEvents = !0,
                this.update(!0))
            }
            handleEvent(t, e, n=!0) {
                if (e && this._ignoreReplayEvents)
                    return !1;
                this._ignoreReplayEvents = !1;
                const r = this.options
                  , c = this._active || []
                  , l = this._getActiveElements(t, c, e, n)
                  , h = this._positionChanged(l, t)
                  , d = e || !Object(o.kb)(l, c) || h;
                return d && (this._active = l,
                (r.enabled || r.external) && (this._eventPosition = {
                    x: t.x,
                    y: t.y
                },
                this.update(!0, e))),
                d
            }
            _getActiveElements(t, e, n, o) {
                const r = this.options;
                if ("mouseout" === t.type)
                    return [];
                if (!o)
                    return e;
                const c = this.chart.getElementsAtEventForMode(t, r.mode, r, n);
                return r.reverse && c.reverse(),
                c
            }
            _positionChanged(t, e) {
                const {caretX: n, caretY: o, options: r} = this
                  , c = yi[r.position].call(this, t, e);
                return !1 !== c && (n !== c.x || o !== c.y)
            }
        }
        Di.positioners = yi;
        var Ai = {
            id: "tooltip",
            _element: Di,
            positioners: yi,
            afterInit(t, e, n) {
                n && (t.tooltip = new Di({
                    chart: t,
                    options: n
                }))
            },
            beforeUpdate(t, e, n) {
                t.tooltip && t.tooltip.initialize(n)
            },
            reset(t, e, n) {
                t.tooltip && t.tooltip.initialize(n)
            },
            afterDraw(t) {
                const e = t.tooltip;
                if (e && e._willRender()) {
                    const n = {
                        tooltip: e
                    };
                    if (!1 === t.notifyPlugins("beforeTooltipDraw", n))
                        return;
                    e.draw(t.ctx),
                    t.notifyPlugins("afterTooltipDraw", n)
                }
            },
            afterEvent(t, e) {
                if (t.tooltip) {
                    const n = e.replay;
                    t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0)
                }
            },
            defaults: {
                enabled: !0,
                external: null,
                position: "average",
                backgroundColor: "rgba(0,0,0,0.8)",
                titleColor: "#fff",
                titleFont: {
                    weight: "bold"
                },
                titleSpacing: 2,
                titleMarginBottom: 6,
                titleAlign: "left",
                bodyColor: "#fff",
                bodySpacing: 2,
                bodyFont: {},
                bodyAlign: "left",
                footerColor: "#fff",
                footerSpacing: 2,
                footerMarginTop: 6,
                footerFont: {
                    weight: "bold"
                },
                footerAlign: "left",
                padding: 6,
                caretPadding: 2,
                caretSize: 5,
                cornerRadius: 6,
                boxHeight: (t,e)=>e.bodyFont.size,
                boxWidth: (t,e)=>e.bodyFont.size,
                multiKeyBackground: "#fff",
                displayColors: !0,
                boxPadding: 0,
                borderColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                animation: {
                    duration: 400,
                    easing: "easeOutQuart"
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: ["x", "y", "width", "height", "caretX", "caretY"]
                    },
                    opacity: {
                        easing: "linear",
                        duration: 200
                    }
                },
                callbacks: {
                    beforeTitle: o.S,
                    title(t) {
                        if (t.length > 0) {
                            const e = t[0]
                              , n = e.chart.data.labels
                              , o = n ? n.length : 0;
                            if (this && this.options && "dataset" === this.options.mode)
                                return e.dataset.label || "";
                            if (e.label)
                                return e.label;
                            if (o > 0 && e.dataIndex < o)
                                return n[e.dataIndex]
                        }
                        return ""
                    },
                    afterTitle: o.S,
                    beforeBody: o.S,
                    beforeLabel: o.S,
                    label(t) {
                        if (this && this.options && "dataset" === this.options.mode)
                            return t.label + ": " + t.formattedValue || t.formattedValue;
                        let label = t.dataset.label || "";
                        label && (label += ": ");
                        const e = t.formattedValue;
                        return Object(o.Ob)(e) || (label += e),
                        label
                    },
                    labelColor(t) {
                        const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
                        return {
                            borderColor: e.borderColor,
                            backgroundColor: e.backgroundColor,
                            borderWidth: e.borderWidth,
                            borderDash: e.borderDash,
                            borderDashOffset: e.borderDashOffset,
                            borderRadius: 0
                        }
                    },
                    labelTextColor() {
                        return this.options.bodyColor
                    },
                    labelPointStyle(t) {
                        const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
                        return {
                            pointStyle: e.pointStyle,
                            rotation: e.rotation
                        }
                    },
                    afterLabel: o.S,
                    afterBody: o.S,
                    beforeFooter: o.S,
                    footer: o.S,
                    afterFooter: o.S
                }
            },
            defaultRoutes: {
                bodyFont: "font",
                footerFont: "font",
                titleFont: "font"
            },
            descriptors: {
                _scriptable: t=>"filter" !== t && "itemSort" !== t && "external" !== t,
                _indexable: !1,
                callbacks: {
                    _scriptable: !1,
                    _indexable: !1
                },
                animation: {
                    _fallback: !1
                },
                animations: {
                    _fallback: "animation"
                }
            },
            additionalOptionScopes: ["interaction"]
        }
          , Ti = Object.freeze({
            __proto__: null,
            Decimation: Ze,
            Filler: ui,
            Legend: gi,
            SubTitle: xi,
            Title: mi,
            Tooltip: Ai
        });
        function Li(t, e, n, o) {
            const r = t.indexOf(e);
            if (-1 === r)
                return ((t,e,n,o)=>("string" == typeof e ? (n = t.push(e) - 1,
                o.unshift({
                    index: n,
                    label: e
                })) : isNaN(e) && (n = null),
                n))(t, e, n, o);
            return r !== t.lastIndexOf(e) ? n : r
        }
        class Ei extends it {
            constructor(t) {
                super(t),
                this._startValue = void 0,
                this._valueRange = 0,
                this._addedLabels = []
            }
            init(t) {
                const e = this._addedLabels;
                if (e.length) {
                    const t = this.getLabels();
                    for (const {index: n, label: label} of e)
                        t[n] === label && t.splice(n, 1);
                    this._addedLabels = []
                }
                super.init(t)
            }
            parse(t, e) {
                if (Object(o.Ob)(t))
                    return null;
                const n = this.getLabels();
                return ((t,e)=>null === t ? null : Object(o.f)(Math.round(t), 0, e))(e = isFinite(e) && n[e] === t ? e : Li(n, t, Object(o.Zb)(e, t), this._addedLabels), n.length - 1)
            }
            determineDataLimits() {
                const {minDefined: t, maxDefined: e} = this.getUserBounds();
                let {min: n, max: o} = this.getMinMax(!0);
                "ticks" === this.options.bounds && (t || (n = 0),
                e || (o = this.getLabels().length - 1)),
                this.min = n,
                this.max = o
            }
            buildTicks() {
                const t = this.min
                  , e = this.max
                  , n = this.options.offset
                  , o = [];
                let r = this.getLabels();
                r = 0 === t && e === r.length - 1 ? r : r.slice(t, e + 1),
                this._valueRange = Math.max(r.length - (n ? 0 : 1), 1),
                this._startValue = this.min - (n ? .5 : 0);
                for (let n = t; n <= e; n++)
                    o.push({
                        value: n
                    });
                return o
            }
            getLabelForValue(t) {
                const e = this.getLabels();
                return t >= 0 && t < e.length ? e[t] : t
            }
            configure() {
                super.configure(),
                this.isHorizontal() || (this._reversePixels = !this._reversePixels)
            }
            getPixelForValue(t) {
                return "number" != typeof t && (t = this.parse(t)),
                null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
            }
            getPixelForTick(t) {
                const e = this.ticks;
                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
            }
            getValueForPixel(t) {
                return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
            }
            getBasePixel() {
                return this.bottom
            }
        }
        function Ri(t, e, {horizontal: n, minRotation: r}) {
            const c = Object(o.Xb)(r)
              , l = (n ? Math.sin(c) : Math.cos(c)) || .001
              , h = .75 * e * ("" + t).length;
            return Math.min(e / l, h)
        }
        Ei.id = "category",
        Ei.defaults = {
            ticks: {
                callback: Ei.prototype.getLabelForValue
            }
        };
        class Ii extends it {
            constructor(t) {
                super(t),
                this.start = void 0,
                this.end = void 0,
                this._startValue = void 0,
                this._endValue = void 0,
                this._valueRange = 0
            }
            parse(t, e) {
                return Object(o.Ob)(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t
            }
            handleTickRangeOptions() {
                const {beginAtZero: t} = this.options
                  , {minDefined: e, maxDefined: n} = this.getUserBounds();
                let {min: r, max: c} = this;
                const l = t=>r = e ? r : t
                  , h = t=>c = n ? c : t;
                if (t) {
                    const t = Object(o.Wb)(r)
                      , e = Object(o.Wb)(c);
                    t < 0 && e < 0 ? h(0) : t > 0 && e > 0 && l(0)
                }
                if (r === c) {
                    let e = 1;
                    (c >= Number.MAX_SAFE_INTEGER || r <= Number.MIN_SAFE_INTEGER) && (e = Math.abs(.05 * c)),
                    h(c + e),
                    t || l(r - e)
                }
                this.min = r,
                this.max = c
            }
            getTickLimit() {
                const t = this.options.ticks;
                let e, {maxTicksLimit: n, stepSize: o} = t;
                return o ? (e = Math.ceil(this.max / o) - Math.floor(this.min / o) + 1,
                e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${o} would result generating up to ${e} ticks. Limiting to 1000.`),
                e = 1e3)) : (e = this.computeTickLimit(),
                n = n || 11),
                n && (e = Math.min(n, e)),
                e
            }
            computeTickLimit() {
                return Number.POSITIVE_INFINITY
            }
            buildTicks() {
                const t = this.options
                  , e = t.ticks;
                let n = this.getTickLimit();
                n = Math.max(2, n);
                const r = function(t, e) {
                    const n = []
                      , {bounds: r, step: c, min: l, max: h, precision: d, count: f, maxTicks: m, maxDigits: x, includeBounds: y} = t
                      , _ = c || 1
                      , v = m - 1
                      , {min: O, max: w} = e
                      , M = !Object(o.Ob)(l)
                      , j = !Object(o.Ob)(h)
                      , k = !Object(o.Ob)(f)
                      , S = (w - O) / (x + 1);
                    let P, C, D, A, T = Object(o.V)((w - O) / v / _) * _;
                    if (T < 1e-14 && !M && !j)
                        return [{
                            value: O
                        }, {
                            value: w
                        }];
                    A = Math.ceil(w / T) - Math.floor(O / T),
                    A > v && (T = Object(o.V)(A * T / v / _) * _),
                    Object(o.Ob)(d) || (P = Math.pow(10, d),
                    T = Math.ceil(T * P) / P),
                    "ticks" === r ? (C = Math.floor(O / T) * T,
                    D = Math.ceil(w / T) * T) : (C = O,
                    D = w),
                    M && j && c && Object(o.W)((h - l) / c, T / 1e3) ? (A = Math.round(Math.min((h - l) / T, m)),
                    T = (h - l) / A,
                    C = l,
                    D = h) : k ? (C = M ? l : C,
                    D = j ? h : D,
                    A = f - 1,
                    T = (D - C) / A) : (A = (D - C) / T,
                    A = Object(o.X)(A, Math.round(A), T / 1e3) ? Math.round(A) : Math.ceil(A));
                    const L = Math.max(Object(o.Y)(T), Object(o.Y)(C));
                    P = Math.pow(10, Object(o.Ob)(d) ? L : d),
                    C = Math.round(C * P) / P,
                    D = Math.round(D * P) / P;
                    let E = 0;
                    for (M && (y && C !== l ? (n.push({
                        value: l
                    }),
                    C < l && E++,
                    Object(o.X)(Math.round((C + E * T) * P) / P, l, Ri(l, S, t)) && E++) : C < l && E++); E < A; ++E)
                        n.push({
                            value: Math.round((C + E * T) * P) / P
                        });
                    return j && y && D !== h ? n.length && Object(o.X)(n[n.length - 1].value, h, Ri(h, S, t)) ? n[n.length - 1].value = h : n.push({
                        value: h
                    }) : j && D !== h || n.push({
                        value: D
                    }),
                    n
                }({
                    maxTicks: n,
                    bounds: t.bounds,
                    min: t.min,
                    max: t.max,
                    precision: e.precision,
                    step: e.stepSize,
                    count: e.count,
                    maxDigits: this._maxDigits(),
                    horizontal: this.isHorizontal(),
                    minRotation: e.minRotation || 0,
                    includeBounds: !1 !== e.includeBounds
                }, this._range || this);
                return "ticks" === t.bounds && Object(o.U)(r, this, "value"),
                t.reverse ? (r.reverse(),
                this.start = this.max,
                this.end = this.min) : (this.start = this.min,
                this.end = this.max),
                r
            }
            configure() {
                const t = this.ticks;
                let e = this.min
                  , n = this.max;
                if (super.configure(),
                this.options.offset && t.length) {
                    const o = (n - e) / Math.max(t.length - 1, 1) / 2;
                    e -= o,
                    n += o
                }
                this._startValue = e,
                this._endValue = n,
                this._valueRange = n - e
            }
            getLabelForValue(t) {
                return Object(o.Sb)(t, this.chart.options.locale, this.options.ticks.format)
            }
        }
        class zi extends Ii {
            determineDataLimits() {
                const {min: t, max: e} = this.getMinMax(!0);
                this.min = Object(o.Kb)(t) ? t : 0,
                this.max = Object(o.Kb)(e) ? e : 1,
                this.handleTickRangeOptions()
            }
            computeTickLimit() {
                const t = this.isHorizontal()
                  , e = t ? this.width : this.height
                  , n = Object(o.Xb)(this.options.ticks.minRotation)
                  , r = (t ? Math.sin(n) : Math.cos(n)) || .001
                  , c = this._resolveTickFontOptions(0);
                return Math.ceil(e / Math.min(40, c.lineHeight / r))
            }
            getPixelForValue(t) {
                return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
            }
            getValueForPixel(t) {
                return this._startValue + this.getDecimalForPixel(t) * this._valueRange
            }
        }
        function Fi(t) {
            return 1 === t / Math.pow(10, Math.floor(Object(o.dc)(t)))
        }
        zi.id = "linear",
        zi.defaults = {
            ticks: {
                callback: $.formatters.numeric
            }
        };
        class Wi extends it {
            constructor(t) {
                super(t),
                this.start = void 0,
                this.end = void 0,
                this._startValue = void 0,
                this._valueRange = 0
            }
            parse(t, e) {
                const n = Ii.prototype.parse.apply(this, [t, e]);
                if (0 !== n)
                    return Object(o.Kb)(n) && n > 0 ? n : null;
                this._zero = !0
            }
            determineDataLimits() {
                const {min: t, max: e} = this.getMinMax(!0);
                this.min = Object(o.Kb)(t) ? Math.max(0, t) : null,
                this.max = Object(o.Kb)(e) ? Math.max(0, e) : null,
                this.options.beginAtZero && (this._zero = !0),
                this.handleTickRangeOptions()
            }
            handleTickRangeOptions() {
                const {minDefined: t, maxDefined: e} = this.getUserBounds();
                let n = this.min
                  , r = this.max;
                const c = e=>n = t ? n : e
                  , l = t=>r = e ? r : t
                  , h = (t,e)=>Math.pow(10, Math.floor(Object(o.dc)(t)) + e);
                n === r && (n <= 0 ? (c(1),
                l(10)) : (c(h(n, -1)),
                l(h(r, 1)))),
                n <= 0 && c(h(r, -1)),
                r <= 0 && l(h(n, 1)),
                this._zero && this.min !== this._suggestedMin && n === h(this.min, 0) && c(h(n, -1)),
                this.min = n,
                this.max = r
            }
            buildTicks() {
                const t = this.options
                  , e = function(t, e) {
                    const n = Math.floor(Object(o.dc)(e.max))
                      , r = Math.ceil(e.max / Math.pow(10, n))
                      , c = [];
                    let l = Object(o.c)(t.min, Math.pow(10, Math.floor(Object(o.dc)(e.min))))
                      , h = Math.floor(Object(o.dc)(l))
                      , d = Math.floor(l / Math.pow(10, h))
                      , f = h < 0 ? Math.pow(10, Math.abs(h)) : 1;
                    do {
                        c.push({
                            value: l,
                            major: Fi(l)
                        }),
                        ++d,
                        10 === d && (d = 1,
                        ++h,
                        f = h >= 0 ? 1 : f),
                        l = Math.round(d * Math.pow(10, h) * f) / f
                    } while (h < n || h === n && d < r);
                    const m = Object(o.c)(t.max, l);
                    return c.push({
                        value: m,
                        major: Fi(l)
                    }),
                    c
                }({
                    min: this._userMin,
                    max: this._userMax
                }, this);
                return "ticks" === t.bounds && Object(o.U)(e, this, "value"),
                t.reverse ? (e.reverse(),
                this.start = this.max,
                this.end = this.min) : (this.start = this.min,
                this.end = this.max),
                e
            }
            getLabelForValue(t) {
                return void 0 === t ? "0" : Object(o.Sb)(t, this.chart.options.locale, this.options.ticks.format)
            }
            configure() {
                const t = this.min;
                super.configure(),
                this._startValue = Object(o.dc)(t),
                this._valueRange = Object(o.dc)(this.max) - Object(o.dc)(t)
            }
            getPixelForValue(t) {
                return void 0 !== t && 0 !== t || (t = this.min),
                null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Object(o.dc)(t) - this._startValue) / this._valueRange)
            }
            getValueForPixel(t) {
                const e = this.getDecimalForPixel(t);
                return Math.pow(10, this._startValue + e * this._valueRange)
            }
        }
        function Vi(t) {
            const e = t.ticks;
            if (e.display && t.display) {
                const t = Object(o.l)(e.backdropPadding);
                return Object(o.Zb)(e.font && e.font.size, o.Hb.font.size) + t.height
            }
            return 0
        }
        function Ni(t, e, n, o, r) {
            return t === o || t === r ? {
                start: e - n / 2,
                end: e + n / 2
            } : t < o || t > r ? {
                start: e - n,
                end: e
            } : {
                start: e,
                end: e + n
            }
        }
        function Bi(t) {
            const e = {
                l: t.left + t._padding.left,
                r: t.right - t._padding.right,
                t: t.top + t._padding.top,
                b: t.bottom - t._padding.bottom
            }
              , n = Object.assign({}, e)
              , r = []
              , c = []
              , l = t._pointLabels.length
              , h = t.options.pointLabels
              , d = h.centerPointLabels ? o.q / l : 0;
            for (let i = 0; i < l; i++) {
                const l = h.setContext(t.getPointLabelContext(i));
                c[i] = l.padding;
                const x = t.getPointPosition(i, t.drawingArea + c[i], d)
                  , y = Object(o.p)(l.font)
                  , _ = (f = t.ctx,
                m = y,
                label = t._pointLabels[i],
                label = Object(o.Cb)(label) ? label : [label],
                {
                    w: Object(o.Z)(f, m.string, label),
                    h: label.length * m.lineHeight
                });
                r[i] = _;
                const v = Object(o.Bb)(t.getIndexAngle(i) + d)
                  , O = Math.round(Object(o.g)(v));
                Hi(n, e, v, Ni(O, x.x, _.w, 0, 180), Ni(O, x.y, _.h, 90, 270))
            }
            var f, m, label;
            t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b),
            t._pointLabelItems = function(t, e, n) {
                const r = []
                  , c = t._pointLabels.length
                  , l = t.options
                  , h = Vi(l) / 2
                  , d = t.drawingArea
                  , f = l.pointLabels.centerPointLabels ? o.q / c : 0;
                for (let i = 0; i < c; i++) {
                    const c = t.getPointPosition(i, d + h + n[i], f)
                      , l = Math.round(Object(o.g)(Object(o.Bb)(c.angle + o.i)))
                      , m = e[i]
                      , x = $i(c.y, m.h, l)
                      , y = Yi(l)
                      , _ = Xi(c.x, m.w, y);
                    r.push({
                        x: c.x,
                        y: x,
                        textAlign: y,
                        left: _,
                        top: x,
                        right: _ + m.w,
                        bottom: x + m.h
                    })
                }
                return r
            }(t, r, c)
        }
        function Hi(t, e, n, o, r) {
            const c = Math.abs(Math.sin(n))
              , l = Math.abs(Math.cos(n));
            let h = 0
              , d = 0;
            o.start < e.l ? (h = (e.l - o.start) / c,
            t.l = Math.min(t.l, e.l - h)) : o.end > e.r && (h = (o.end - e.r) / c,
            t.r = Math.max(t.r, e.r + h)),
            r.start < e.t ? (d = (e.t - r.start) / l,
            t.t = Math.min(t.t, e.t - d)) : r.end > e.b && (d = (r.end - e.b) / l,
            t.b = Math.max(t.b, e.b + d))
        }
        function Yi(t) {
            return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right"
        }
        function Xi(t, e, n) {
            return "right" === n ? t -= e : "center" === n && (t -= e / 2),
            t
        }
        function $i(t, e, n) {
            return 90 === n || 270 === n ? t -= e / 2 : (n > 270 || n < 90) && (t -= e),
            t
        }
        function Ui(t, e, n, r) {
            const {ctx: c} = t;
            if (n)
                c.arc(t.xCenter, t.yCenter, e, 0, o.u);
            else {
                let n = t.getPointPosition(0, e);
                c.moveTo(n.x, n.y);
                for (let i = 1; i < r; i++)
                    n = t.getPointPosition(i, e),
                    c.lineTo(n.x, n.y)
            }
        }
        Wi.id = "logarithmic",
        Wi.defaults = {
            ticks: {
                callback: $.formatters.logarithmic,
                major: {
                    enabled: !0
                }
            }
        };
        class Zi extends Ii {
            constructor(t) {
                super(t),
                this.xCenter = void 0,
                this.yCenter = void 0,
                this.drawingArea = void 0,
                this._pointLabels = [],
                this._pointLabelItems = []
            }
            setDimensions() {
                const t = this._padding = Object(o.l)(Vi(this.options) / 2)
                  , e = this.width = this.maxWidth - t.width
                  , n = this.height = this.maxHeight - t.height;
                this.xCenter = Math.floor(this.left + e / 2 + t.left),
                this.yCenter = Math.floor(this.top + n / 2 + t.top),
                this.drawingArea = Math.floor(Math.min(e, n) / 2)
            }
            determineDataLimits() {
                const {min: t, max: e} = this.getMinMax(!1);
                this.min = Object(o.Kb)(t) && !isNaN(t) ? t : 0,
                this.max = Object(o.Kb)(e) && !isNaN(e) ? e : 0,
                this.handleTickRangeOptions()
            }
            computeTickLimit() {
                return Math.ceil(this.drawingArea / Vi(this.options))
            }
            generateTickLabels(t) {
                Ii.prototype.generateTickLabels.call(this, t),
                this._pointLabels = this.getLabels().map(((t,e)=>{
                    const label = Object(o.d)(this.options.pointLabels.callback, [t, e], this);
                    return label || 0 === label ? label : ""
                }
                )).filter(((t,i)=>this.chart.getDataVisibility(i)))
            }
            fit() {
                const t = this.options;
                t.display && t.pointLabels.display ? Bi(this) : this.setCenterPoint(0, 0, 0, 0)
            }
            setCenterPoint(t, e, n, o) {
                this.xCenter += Math.floor((t - e) / 2),
                this.yCenter += Math.floor((n - o) / 2),
                this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, n, o))
            }
            getIndexAngle(t) {
                const e = o.u / (this._pointLabels.length || 1)
                  , n = this.options.startAngle || 0;
                return Object(o.Bb)(t * e + Object(o.Xb)(n))
            }
            getDistanceFromCenterForValue(t) {
                if (Object(o.Ob)(t))
                    return NaN;
                const e = this.drawingArea / (this.max - this.min);
                return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
            }
            getValueForDistanceFromCenter(t) {
                if (Object(o.Ob)(t))
                    return NaN;
                const e = t / (this.drawingArea / (this.max - this.min));
                return this.options.reverse ? this.max - e : this.min + e
            }
            getPointLabelContext(t) {
                const e = this._pointLabels || [];
                if (t >= 0 && t < e.length) {
                    const n = e[t];
                    return function(t, e, label) {
                        return Object(o.Lb)(t, {
                            label: label,
                            index: e,
                            type: "pointLabel"
                        })
                    }(this.getContext(), t, n)
                }
            }
            getPointPosition(t, e, n=0) {
                const r = this.getIndexAngle(t) - o.i + n;
                return {
                    x: Math.cos(r) * e + this.xCenter,
                    y: Math.sin(r) * e + this.yCenter,
                    angle: r
                }
            }
            getPointPositionForValue(t, e) {
                return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
            }
            getBasePosition(t) {
                return this.getPointPositionForValue(t || 0, this.getBaseValue())
            }
            getPointLabelPosition(t) {
                const {left: e, top: n, right: o, bottom: r} = this._pointLabelItems[t];
                return {
                    left: e,
                    top: n,
                    right: o,
                    bottom: r
                }
            }
            drawBackground() {
                const {backgroundColor: t, grid: {circular: e}} = this.options;
                if (t) {
                    const n = this.ctx;
                    n.save(),
                    n.beginPath(),
                    Ui(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length),
                    n.closePath(),
                    n.fillStyle = t,
                    n.fill(),
                    n.restore()
                }
            }
            drawGrid() {
                const t = this.ctx
                  , e = this.options
                  , {angleLines: n, grid: r} = e
                  , c = this._pointLabels.length;
                let i, l, h;
                if (e.pointLabels.display && function(t, e) {
                    const {ctx: n, options: {pointLabels: r}} = t;
                    for (let i = e - 1; i >= 0; i--) {
                        const e = r.setContext(t.getPointLabelContext(i))
                          , c = Object(o.p)(e.font)
                          , {x: l, y: h, textAlign: d, left: f, top: m, right: x, bottom: y} = t._pointLabelItems[i]
                          , {backdropColor: _} = e;
                        if (!Object(o.Ob)(_)) {
                            const t = Object(o.zb)(e.borderRadius)
                              , r = Object(o.l)(e.backdropPadding);
                            n.fillStyle = _;
                            const c = f - r.left
                              , l = m - r.top
                              , h = x - f + r.width
                              , d = y - m + r.height;
                            Object.values(t).some((t=>0 !== t)) ? (n.beginPath(),
                            Object(o.xb)(n, {
                                x: c,
                                y: l,
                                w: h,
                                h: d,
                                radius: t
                            }),
                            n.fill()) : n.fillRect(c, l, h, d)
                        }
                        Object(o.n)(n, t._pointLabels[i], l, h + c.lineHeight / 2, c, {
                            color: e.color,
                            textAlign: d,
                            textBaseline: "middle"
                        })
                    }
                }(this, c),
                r.display && this.ticks.forEach(((t,e)=>{
                    if (0 !== e) {
                        l = this.getDistanceFromCenterForValue(t.value);
                        !function(t, e, n, o) {
                            const r = t.ctx
                              , c = e.circular
                              , {color: l, lineWidth: h} = e;
                            !c && !o || !l || !h || n < 0 || (r.save(),
                            r.strokeStyle = l,
                            r.lineWidth = h,
                            r.setLineDash(e.borderDash),
                            r.lineDashOffset = e.borderDashOffset,
                            r.beginPath(),
                            Ui(t, n, c, o),
                            r.closePath(),
                            r.stroke(),
                            r.restore())
                        }(this, r.setContext(this.getContext(e - 1)), l, c)
                    }
                }
                )),
                n.display) {
                    for (t.save(),
                    i = c - 1; i >= 0; i--) {
                        const o = n.setContext(this.getPointLabelContext(i))
                          , {color: r, lineWidth: c} = o;
                        c && r && (t.lineWidth = c,
                        t.strokeStyle = r,
                        t.setLineDash(o.borderDash),
                        t.lineDashOffset = o.borderDashOffset,
                        l = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max),
                        h = this.getPointPosition(i, l),
                        t.beginPath(),
                        t.moveTo(this.xCenter, this.yCenter),
                        t.lineTo(h.x, h.y),
                        t.stroke())
                    }
                    t.restore()
                }
            }
            drawBorder() {}
            drawLabels() {
                const t = this.ctx
                  , e = this.options
                  , n = e.ticks;
                if (!n.display)
                    return;
                const r = this.getIndexAngle(0);
                let c, l;
                t.save(),
                t.translate(this.xCenter, this.yCenter),
                t.rotate(r),
                t.textAlign = "center",
                t.textBaseline = "middle",
                this.ticks.forEach(((r,h)=>{
                    if (0 === h && !e.reverse)
                        return;
                    const d = n.setContext(this.getContext(h))
                      , f = Object(o.p)(d.font);
                    if (c = this.getDistanceFromCenterForValue(this.ticks[h].value),
                    d.showLabelBackdrop) {
                        t.font = f.string,
                        l = t.measureText(r.label).width,
                        t.fillStyle = d.backdropColor;
                        const e = Object(o.l)(d.backdropPadding);
                        t.fillRect(-l / 2 - e.left, -c - f.size / 2 - e.top, l + e.width, f.size + e.height)
                    }
                    Object(o.n)(t, r.label, 0, -c, f, {
                        color: d.color
                    })
                }
                )),
                t.restore()
            }
            drawTitle() {}
        }
        Zi.id = "radialLinear",
        Zi.defaults = {
            display: !0,
            animate: !0,
            position: "chartArea",
            angleLines: {
                display: !0,
                lineWidth: 1,
                borderDash: [],
                borderDashOffset: 0
            },
            grid: {
                circular: !1
            },
            startAngle: 0,
            ticks: {
                showLabelBackdrop: !0,
                callback: $.formatters.numeric
            },
            pointLabels: {
                backdropColor: void 0,
                backdropPadding: 2,
                display: !0,
                font: {
                    size: 10
                },
                callback: label=>label,
                padding: 5,
                centerPointLabels: !1
            }
        },
        Zi.defaultRoutes = {
            "angleLines.color": "borderColor",
            "pointLabels.color": "color",
            "ticks.color": "color"
        },
        Zi.descriptors = {
            angleLines: {
                _fallback: "grid"
            }
        };
        const qi = {
            millisecond: {
                common: !0,
                size: 1,
                steps: 1e3
            },
            second: {
                common: !0,
                size: 1e3,
                steps: 60
            },
            minute: {
                common: !0,
                size: 6e4,
                steps: 60
            },
            hour: {
                common: !0,
                size: 36e5,
                steps: 24
            },
            day: {
                common: !0,
                size: 864e5,
                steps: 30
            },
            week: {
                common: !1,
                size: 6048e5,
                steps: 4
            },
            month: {
                common: !0,
                size: 2628e6,
                steps: 12
            },
            quarter: {
                common: !1,
                size: 7884e6,
                steps: 4
            },
            year: {
                common: !0,
                size: 3154e7
            }
        }
          , Ki = Object.keys(qi);
        function Ji(a, b) {
            return a - b
        }
        function Gi(t, input) {
            if (Object(o.Ob)(input))
                return null;
            const e = t._adapter
              , {parser: n, round: r, isoWeekday: c} = t._parseOpts;
            let l = input;
            return "function" == typeof n && (l = n(l)),
            Object(o.Kb)(l) || (l = "string" == typeof n ? e.parse(l, n) : e.parse(l)),
            null === l ? null : (r && (l = "week" !== r || !Object(o.bc)(c) && !0 !== c ? e.startOf(l, r) : e.startOf(l, "isoWeek", c)),
            +l)
        }
        function Qi(t, e, n, o) {
            const r = Ki.length;
            for (let i = Ki.indexOf(t); i < r - 1; ++i) {
                const t = qi[Ki[i]]
                  , r = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;
                if (t.common && Math.ceil((n - e) / (r * t.size)) <= o)
                    return Ki[i]
            }
            return Ki[r - 1]
        }
        function tn(t, time, e) {
            if (e) {
                if (e.length) {
                    const {lo: n, hi: r} = Object(o.bb)(e, time);
                    t[e[n] >= time ? e[n] : e[r]] = !0
                }
            } else
                t[time] = !0
        }
        function en(t, e, n) {
            const o = []
              , map = {}
              , r = e.length;
            let i, c;
            for (i = 0; i < r; ++i)
                c = e[i],
                map[c] = i,
                o.push({
                    value: c,
                    major: !1
                });
            return 0 !== r && n ? function(t, e, map, n) {
                const o = t._adapter
                  , r = +o.startOf(e[0].value, n)
                  , c = e[e.length - 1].value;
                let l, h;
                for (l = r; l <= c; l = +o.add(l, 1, n))
                    h = map[l],
                    h >= 0 && (e[h].major = !0);
                return e
            }(t, o, map, n) : o
        }
        class nn extends it {
            constructor(t) {
                super(t),
                this._cache = {
                    data: [],
                    labels: [],
                    all: []
                },
                this._unit = "day",
                this._majorUnit = void 0,
                this._offsets = {},
                this._normalized = !1,
                this._parseOpts = void 0
            }
            init(t, e) {
                const time = t.time || (t.time = {})
                  , n = this._adapter = new ht._date(t.adapters.date);
                n.init(e),
                Object(o.eb)(time.displayFormats, n.formats()),
                this._parseOpts = {
                    parser: time.parser,
                    round: time.round,
                    isoWeekday: time.isoWeekday
                },
                super.init(t),
                this._normalized = e.normalized
            }
            parse(t, e) {
                return void 0 === t ? null : Gi(this, t)
            }
            beforeLayout() {
                super.beforeLayout(),
                this._cache = {
                    data: [],
                    labels: [],
                    all: []
                }
            }
            determineDataLimits() {
                const t = this.options
                  , e = this._adapter
                  , n = t.time.unit || "day";
                let {min: r, max: c, minDefined: l, maxDefined: h} = this.getUserBounds();
                function d(t) {
                    l || isNaN(t.min) || (r = Math.min(r, t.min)),
                    h || isNaN(t.max) || (c = Math.max(c, t.max))
                }
                l && h || (d(this._getLabelBounds()),
                "ticks" === t.bounds && "labels" === t.ticks.source || d(this.getMinMax(!1))),
                r = Object(o.Kb)(r) && !isNaN(r) ? r : +e.startOf(Date.now(), n),
                c = Object(o.Kb)(c) && !isNaN(c) ? c : +e.endOf(Date.now(), n) + 1,
                this.min = Math.min(r, c - 1),
                this.max = Math.max(r + 1, c)
            }
            _getLabelBounds() {
                const t = this.getLabelTimestamps();
                let e = Number.POSITIVE_INFINITY
                  , n = Number.NEGATIVE_INFINITY;
                return t.length && (e = t[0],
                n = t[t.length - 1]),
                {
                    min: e,
                    max: n
                }
            }
            buildTicks() {
                const t = this.options
                  , e = t.time
                  , n = t.ticks
                  , r = "labels" === n.source ? this.getLabelTimestamps() : this._generate();
                "ticks" === t.bounds && r.length && (this.min = this._userMin || r[0],
                this.max = this._userMax || r[r.length - 1]);
                const c = this.min
                  , l = this.max
                  , h = Object(o.ab)(r, c, l);
                return this._unit = e.unit || (n.autoSkip ? Qi(e.minUnit, this.min, this.max, this._getLabelCapacity(c)) : function(t, e, n, o, r) {
                    for (let i = Ki.length - 1; i >= Ki.indexOf(n); i--) {
                        const n = Ki[i];
                        if (qi[n].common && t._adapter.diff(r, o, n) >= e - 1)
                            return n
                    }
                    return Ki[n ? Ki.indexOf(n) : 0]
                }(this, h.length, e.minUnit, this.min, this.max)),
                this._majorUnit = n.major.enabled && "year" !== this._unit ? function(t) {
                    for (let i = Ki.indexOf(t) + 1, e = Ki.length; i < e; ++i)
                        if (qi[Ki[i]].common)
                            return Ki[i]
                }(this._unit) : void 0,
                this.initOffsets(r),
                t.reverse && h.reverse(),
                en(this, h, this._majorUnit)
            }
            afterAutoSkip() {
                this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t=>+t.value)))
            }
            initOffsets(t) {
                let e, n, r = 0, c = 0;
                this.options.offset && t.length && (e = this.getDecimalForValue(t[0]),
                r = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2,
                n = this.getDecimalForValue(t[t.length - 1]),
                c = 1 === t.length ? n : (n - this.getDecimalForValue(t[t.length - 2])) / 2);
                const l = t.length < 3 ? .5 : .25;
                r = Object(o.f)(r, 0, l),
                c = Object(o.f)(c, 0, l),
                this._offsets = {
                    start: r,
                    end: c,
                    factor: 1 / (r + 1 + c)
                }
            }
            _generate() {
                const t = this._adapter
                  , e = this.min
                  , n = this.max
                  , r = this.options
                  , c = r.time
                  , l = c.unit || Qi(c.minUnit, e, n, this._getLabelCapacity(e))
                  , h = Object(o.Zb)(c.stepSize, 1)
                  , d = "week" === l && c.isoWeekday
                  , f = Object(o.bc)(d) || !0 === d
                  , m = {};
                let time, x, y = e;
                if (f && (y = +t.startOf(y, "isoWeek", d)),
                y = +t.startOf(y, f ? "day" : l),
                t.diff(n, e, l) > 1e5 * h)
                    throw new Error(e + " and " + n + " are too far apart with stepSize of " + h + " " + l);
                const _ = "data" === r.ticks.source && this.getDataTimestamps();
                for (time = y,
                x = 0; time < n; time = +t.add(time, h, l),
                x++)
                    tn(m, time, _);
                return time !== n && "ticks" !== r.bounds && 1 !== x || tn(m, time, _),
                Object.keys(m).sort(((a,b)=>a - b)).map((t=>+t))
            }
            getLabelForValue(t) {
                const e = this._adapter
                  , n = this.options.time;
                return n.tooltipFormat ? e.format(t, n.tooltipFormat) : e.format(t, n.displayFormats.datetime)
            }
            _tickFormatFunction(time, t, e, n) {
                const r = this.options
                  , c = r.time.displayFormats
                  , l = this._unit
                  , h = this._majorUnit
                  , d = l && c[l]
                  , f = h && c[h]
                  , m = e[t]
                  , x = h && f && m && m.major
                  , label = this._adapter.format(time, n || (x ? f : d))
                  , y = r.ticks.callback;
                return y ? Object(o.d)(y, [label, t, e], this) : label
            }
            generateTickLabels(t) {
                let i, e, n;
                for (i = 0,
                e = t.length; i < e; ++i)
                    n = t[i],
                    n.label = this._tickFormatFunction(n.value, i, t)
            }
            getDecimalForValue(t) {
                return null === t ? NaN : (t - this.min) / (this.max - this.min)
            }
            getPixelForValue(t) {
                const e = this._offsets
                  , n = this.getDecimalForValue(t);
                return this.getPixelForDecimal((e.start + n) * e.factor)
            }
            getValueForPixel(t) {
                const e = this._offsets
                  , n = this.getDecimalForPixel(t) / e.factor - e.end;
                return this.min + n * (this.max - this.min)
            }
            _getLabelSize(label) {
                const t = this.options.ticks
                  , e = this.ctx.measureText(label).width
                  , n = Object(o.Xb)(this.isHorizontal() ? t.maxRotation : t.minRotation)
                  , r = Math.cos(n)
                  , c = Math.sin(n)
                  , l = this._resolveTickFontOptions(0).size;
                return {
                    w: e * r + l * c,
                    h: e * c + l * r
                }
            }
            _getLabelCapacity(t) {
                const e = this.options.time
                  , n = e.displayFormats
                  , o = n[e.unit] || n.millisecond
                  , r = this._tickFormatFunction(t, 0, en(this, [t], this._majorUnit), o)
                  , c = this._getLabelSize(r)
                  , l = Math.floor(this.isHorizontal() ? this.width / c.w : this.height / c.h) - 1;
                return l > 0 ? l : 1
            }
            getDataTimestamps() {
                let i, t, e = this._cache.data || [];
                if (e.length)
                    return e;
                const n = this.getMatchingVisibleMetas();
                if (this._normalized && n.length)
                    return this._cache.data = n[0].controller.getAllParsedValues(this);
                for (i = 0,
                t = n.length; i < t; ++i)
                    e = e.concat(n[i].controller.getAllParsedValues(this));
                return this._cache.data = this.normalize(e)
            }
            getLabelTimestamps() {
                const t = this._cache.labels || [];
                let i, e;
                if (t.length)
                    return t;
                const n = this.getLabels();
                for (i = 0,
                e = n.length; i < e; ++i)
                    t.push(Gi(this, n[i]));
                return this._cache.labels = this._normalized ? t : this.normalize(t)
            }
            normalize(t) {
                return Object(o.B)(t.sort(Ji))
            }
        }
        function sn(table, t, e) {
            let n, r, c, l, h = 0, d = table.length - 1;
            e ? (t >= table[h].pos && t <= table[d].pos && ({lo: h, hi: d} = Object(o.A)(table, "pos", t)),
            ({pos: n, time: c} = table[h]),
            ({pos: r, time: l} = table[d])) : (t >= table[h].time && t <= table[d].time && ({lo: h, hi: d} = Object(o.A)(table, "time", t)),
            ({time: n, pos: c} = table[h]),
            ({time: r, pos: l} = table[d]));
            const span = r - n;
            return span ? c + (l - c) * (t - n) / span : c
        }
        nn.id = "time",
        nn.defaults = {
            bounds: "data",
            adapters: {},
            time: {
                parser: !1,
                unit: !1,
                round: !1,
                isoWeekday: !1,
                minUnit: "millisecond",
                displayFormats: {}
            },
            ticks: {
                source: "auto",
                major: {
                    enabled: !1
                }
            }
        };
        class on extends nn {
            constructor(t) {
                super(t),
                this._table = [],
                this._minPos = void 0,
                this._tableRange = void 0
            }
            initOffsets() {
                const t = this._getTimestampsForTable()
                  , table = this._table = this.buildLookupTable(t);
                this._minPos = sn(table, this.min),
                this._tableRange = sn(table, this.max) - this._minPos,
                super.initOffsets(t)
            }
            buildLookupTable(t) {
                const {min: e, max: n} = this
                  , o = []
                  , table = [];
                let i, r, c, l, h;
                for (i = 0,
                r = t.length; i < r; ++i)
                    l = t[i],
                    l >= e && l <= n && o.push(l);
                if (o.length < 2)
                    return [{
                        time: e,
                        pos: 0
                    }, {
                        time: n,
                        pos: 1
                    }];
                for (i = 0,
                r = o.length; i < r; ++i)
                    h = o[i + 1],
                    c = o[i - 1],
                    l = o[i],
                    Math.round((h + c) / 2) !== l && table.push({
                        time: l,
                        pos: i / (r - 1)
                    });
                return table
            }
            _getTimestampsForTable() {
                let t = this._cache.all || [];
                if (t.length)
                    return t;
                const data = this.getDataTimestamps()
                  , label = this.getLabelTimestamps();
                return t = data.length && label.length ? this.normalize(data.concat(label)) : data.length ? data : label,
                t = this._cache.all = t,
                t
            }
            getDecimalForValue(t) {
                return (sn(this._table, t) - this._minPos) / this._tableRange
            }
            getValueForPixel(t) {
                const e = this._offsets
                  , n = this.getDecimalForPixel(t) / e.factor - e.end;
                return sn(this._table, n * this._tableRange + this._minPos, !0)
            }
        }
        on.id = "timeseries",
        on.defaults = nn.defaults;
        const rn = [at, Xe, Ti, Object.freeze({
            __proto__: null,
            CategoryScale: Ei,
            LinearScale: zi,
            LogarithmicScale: Wi,
            RadialLinearScale: Zi,
            TimeScale: nn,
            TimeSeriesScale: on
        })]
    },
    626: function(t, e, n) {
        "use strict";
        var o = n(612);
        o.b.register(...o.e),
        e.a = o.b
    },
    629: function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return ie
        }
        ));
        var o = n(612)
          , r = n(459);
        const c = {
            modes: {
                point: (t,e)=>h(t, e, {
                    intersect: !0
                }),
                nearest: (t,e,n)=>function(t, e, n) {
                    let o = Number.POSITIVE_INFINITY;
                    return h(t, e, n).reduce(((t,element)=>{
                        const c = element.getCenterPoint()
                          , l = function(t, e, n) {
                            if ("x" === n)
                                return {
                                    x: t.x,
                                    y: e.y
                                };
                            if ("y" === n)
                                return {
                                    x: e.x,
                                    y: t.y
                                };
                            return e
                        }(e, c, n.axis)
                          , h = Object(r.T)(e, l);
                        return h < o ? (t = [element],
                        o = h) : h === o && t.push(element),
                        t
                    }
                    ), []).sort(((a,b)=>a._index - b._index)).slice(0, 1)
                }(t, e, n),
                x: (t,e,n)=>h(t, e, {
                    intersect: n.intersect,
                    axis: "x"
                }),
                y: (t,e,n)=>h(t, e, {
                    intersect: n.intersect,
                    axis: "y"
                })
            }
        };
        function l(t, e, n) {
            return (c.modes[n.mode] || c.modes.nearest)(t, e, n)
        }
        function h(t, e, n) {
            return t.visibleElements.filter((element=>n.intersect ? element.inRange(e.x, e.y) : function(element, t, e) {
                return "x" !== e && "y" !== e ? element.inRange(t.x, t.y, "x", !0) || element.inRange(t.x, t.y, "y", !0) : element.inRange(t.x, t.y, e, !0)
            }(element, e, n.axis)))
        }
        const d = (t,e)=>e > t || t.length > e.length && t.slice(0, e.length) === e
          , f = .001
          , m = (t,e,n)=>Math.min(n, Math.max(e, t));
        function x(t, e, n) {
            for (const o of Object.keys(t))
                t[o] = m(t[o], e, n);
            return t
        }
        function y(t, {x: e, y: n, x2: o, y2: r}, c, l) {
            const h = l / 2
              , d = t.x >= e - h - f && t.x <= o + h + f
              , m = t.y >= n - h - f && t.y <= r + h + f;
            return "x" === c ? d : ("y" === c || d) && m
        }
        function _(element, t) {
            const {centerX: e, centerY: n} = element.getProps(["centerX", "centerY"], t);
            return {
                x: e,
                y: n
            }
        }
        const v = s=>"string" == typeof s && s.endsWith("%")
          , O = s=>parseFloat(s) / 100
          , w = s=>m(O(s), 0, 1);
        function M(t, e) {
            return "start" === e ? 0 : "end" === e ? t : v(e) ? w(e) * t : t / 2
        }
        function j(t, e, n=!0) {
            return "number" == typeof e ? e : v(e) ? (n ? w(e) : O(e)) * t : t
        }
        function k(t, e="center") {
            return Object(r.Mb)(t) ? {
                x: Object(r.Zb)(t.x, e),
                y: Object(r.Zb)(t.y, e)
            } : {
                x: t = Object(r.Zb)(t, e),
                y: t
            }
        }
        function S(t) {
            return t && (Object(r.Nb)(t.xValue) || Object(r.Nb)(t.yValue))
        }
        function P(t, e, n, o=!1) {
            const c = n.init;
            if (c)
                return !0 === c ? D(e, o) : function(t, e, n) {
                    if (!0 === n)
                        return D(t, e);
                    if (Object(r.Mb)(n))
                        return n
                }(e, o, Object(r.d)(c, [{
                    chart: t,
                    properties: e,
                    options: n
                }]))
        }
        function C(t, e, n) {
            let o = !1;
            return e.forEach((e=>{
                Object(r.L)(t[e]) ? (o = !0,
                n[e] = t[e]) : Object(r.Nb)(n[e]) && delete n[e]
            }
            )),
            o
        }
        function D({centerX: t, centerY: e}, n) {
            return n ? {
                centerX: t,
                centerY: e,
                radius: 0,
                width: 0,
                height: 0
            } : {
                x: t,
                y: e,
                x2: t,
                y2: e,
                width: 0,
                height: 0
            }
        }
        const A = new Map
          , T = t=>t.reduce((function(t, e) {
            return t += e.string
        }
        ), "");
        function L(content) {
            if (content && "object" == typeof content) {
                const t = content.toString();
                return "[object HTMLImageElement]" === t || "[object HTMLCanvasElement]" === t
            }
        }
        function E(t, {x: e, y: n}, o) {
            o && (t.translate(e, n),
            t.rotate(Object(r.Xb)(o)),
            t.translate(-e, -n))
        }
        function R(t, e) {
            if (e && e.borderWidth)
                return t.lineCap = e.borderCapStyle,
                t.setLineDash(e.borderDash),
                t.lineDashOffset = e.borderDashOffset,
                t.lineJoin = e.borderJoinStyle,
                t.lineWidth = e.borderWidth,
                t.strokeStyle = e.borderColor,
                !0
        }
        function I(t, e) {
            t.shadowColor = e.backgroundShadowColor,
            t.shadowBlur = e.shadowBlur,
            t.shadowOffsetX = e.shadowOffsetX,
            t.shadowOffsetY = e.shadowOffsetY
        }
        function z(t, e) {
            const content = e.content;
            if (L(content))
                return {
                    width: j(content.width, e.width),
                    height: j(content.height, e.height)
                };
            const n = e.font
              , o = Object(r.Cb)(n) ? n.map((t=>Object(r.p)(t))) : [Object(r.p)(n)]
              , c = e.textStrokeWidth
              , l = Object(r.Cb)(content) ? content : [content]
              , h = l.join() + T(o) + c + (t._measureText ? "-spriting" : "");
            return A.has(h) || A.set(h, function(t, e, n, o) {
                t.save();
                const r = e.length;
                let c = 0
                  , l = o;
                for (let i = 0; i < r; i++) {
                    const r = n[Math.min(i, n.length - 1)];
                    t.font = r.string;
                    const text = e[i];
                    c = Math.max(c, t.measureText(text).width + o),
                    l += r.lineHeight
                }
                return t.restore(),
                {
                    width: c,
                    height: l
                }
            }(t, l, o, c)),
            A.get(h)
        }
        function F(t, rect, e) {
            const {x: n, y: o, width: c, height: l} = rect;
            t.save(),
            I(t, e);
            const h = R(t, e);
            t.fillStyle = e.backgroundColor,
            t.beginPath(),
            Object(r.xb)(t, {
                x: n,
                y: o,
                w: c,
                h: l,
                radius: x(Object(r.zb)(e.borderRadius), 0, Math.min(c, l) / 2)
            }),
            t.closePath(),
            t.fill(),
            h && (t.shadowColor = e.borderShadowColor,
            t.stroke()),
            t.restore()
        }
        function W(t, rect, e) {
            const content = e.content;
            if (L(content))
                return t.save(),
                t.globalAlpha = function(t, e) {
                    const n = Object(r.bc)(t) ? t : e;
                    return Object(r.bc)(n) ? m(n, 0, 1) : 1
                }(e.opacity, content.style.opacity),
                t.drawImage(content, rect.x, rect.y, rect.width, rect.height),
                void t.restore();
            const n = Object(r.Cb)(content) ? content : [content]
              , o = e.font
              , c = Object(r.Cb)(o) ? o.map((t=>Object(r.p)(t))) : [Object(r.p)(o)]
              , l = e.color
              , h = Object(r.Cb)(l) ? l : [l]
              , d = function(t, e) {
                const {x: n, width: o} = t
                  , r = e.textAlign;
                return "center" === r ? n + o / 2 : "end" === r || "right" === r ? n + o : n
            }(rect, e)
              , f = rect.y + e.textStrokeWidth / 2;
            t.save(),
            t.textBaseline = "middle",
            t.textAlign = e.textAlign,
            function(t, e) {
                if (e.textStrokeWidth > 0)
                    return t.lineJoin = "round",
                    t.miterLimit = 2,
                    t.lineWidth = e.textStrokeWidth,
                    t.strokeStyle = e.textStrokeColor,
                    !0
            }(t, e) && function(t, {x: e, y: n}, o, r) {
                t.beginPath();
                let c = 0;
                o.forEach((function(o, i) {
                    const l = r[Math.min(i, r.length - 1)]
                      , h = l.lineHeight;
                    t.font = l.string,
                    t.strokeText(o, e, n + h / 2 + c),
                    c += h
                }
                )),
                t.stroke()
            }(t, {
                x: d,
                y: f
            }, n, c),
            function(t, {x: e, y: n}, o, {fonts: r, colors: c}) {
                let l = 0;
                o.forEach((function(o, i) {
                    const h = c[Math.min(i, c.length - 1)]
                      , d = r[Math.min(i, r.length - 1)]
                      , f = d.lineHeight;
                    t.beginPath(),
                    t.font = d.string,
                    t.fillStyle = h,
                    t.fillText(o, e, n + f / 2 + l),
                    l += f,
                    t.fill()
                }
                ))
            }(t, {
                x: d,
                y: f
            }, n, {
                fonts: c,
                colors: h
            }),
            t.restore()
        }
        function V(t, element, e, n) {
            const {radius: o, options: c} = element
              , style = c.pointStyle
              , l = c.rotation;
            let h = (l || 0) * r.Db;
            if (L(style))
                return t.save(),
                t.translate(e, n),
                t.rotate(h),
                t.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height),
                void t.restore();
            (t=>isNaN(t) || t <= 0)(o) || function(t, {x: e, y: n, radius: o, rotation: c, style: style, rad: l}) {
                let h, d, f, m;
                switch (t.beginPath(),
                style) {
                default:
                    t.arc(e, n, o, 0, r.u),
                    t.closePath();
                    break;
                case "triangle":
                    t.moveTo(e + Math.sin(l) * o, n - Math.cos(l) * o),
                    l += r.Fb,
                    t.lineTo(e + Math.sin(l) * o, n - Math.cos(l) * o),
                    l += r.Fb,
                    t.lineTo(e + Math.sin(l) * o, n - Math.cos(l) * o),
                    t.closePath();
                    break;
                case "rectRounded":
                    m = .516 * o,
                    f = o - m,
                    h = Math.cos(l + r.Eb) * f,
                    d = Math.sin(l + r.Eb) * f,
                    t.arc(e - h, n - d, m, l - r.q, l - r.i),
                    t.arc(e + d, n - h, m, l - r.i, l),
                    t.arc(e + h, n + d, m, l, l + r.i),
                    t.arc(e - d, n + h, m, l + r.i, l + r.q),
                    t.closePath();
                    break;
                case "rect":
                    if (!c) {
                        f = Math.SQRT1_2 * o,
                        t.rect(e - f, n - f, 2 * f, 2 * f);
                        break
                    }
                    l += r.Eb;
                case "rectRot":
                    h = Math.cos(l) * o,
                    d = Math.sin(l) * o,
                    t.moveTo(e - h, n - d),
                    t.lineTo(e + d, n - h),
                    t.lineTo(e + h, n + d),
                    t.lineTo(e - d, n + h),
                    t.closePath();
                    break;
                case "crossRot":
                    l += r.Eb;
                case "cross":
                    h = Math.cos(l) * o,
                    d = Math.sin(l) * o,
                    t.moveTo(e - h, n - d),
                    t.lineTo(e + h, n + d),
                    t.moveTo(e + d, n - h),
                    t.lineTo(e - d, n + h);
                    break;
                case "star":
                    h = Math.cos(l) * o,
                    d = Math.sin(l) * o,
                    t.moveTo(e - h, n - d),
                    t.lineTo(e + h, n + d),
                    t.moveTo(e + d, n - h),
                    t.lineTo(e - d, n + h),
                    l += r.Eb,
                    h = Math.cos(l) * o,
                    d = Math.sin(l) * o,
                    t.moveTo(e - h, n - d),
                    t.lineTo(e + h, n + d),
                    t.moveTo(e + d, n - h),
                    t.lineTo(e - d, n + h);
                    break;
                case "line":
                    h = Math.cos(l) * o,
                    d = Math.sin(l) * o,
                    t.moveTo(e - h, n - d),
                    t.lineTo(e + h, n + d);
                    break;
                case "dash":
                    t.moveTo(e, n),
                    t.lineTo(e + Math.cos(l) * o, n + Math.sin(l) * o)
                }
                t.fill()
            }(t, {
                x: e,
                y: n,
                radius: o,
                rotation: l,
                style: style,
                rad: h
            })
        }
        const N = {
            xScaleID: {
                min: "xMin",
                max: "xMax",
                start: "left",
                end: "right",
                startProp: "x",
                endProp: "x2"
            },
            yScaleID: {
                min: "yMin",
                max: "yMax",
                start: "bottom",
                end: "top",
                startProp: "y",
                endProp: "y2"
            }
        };
        function B(t, e, n) {
            return e = "number" == typeof e ? e : t.parse(e),
            Object(r.Kb)(e) ? t.getPixelForValue(e) : n
        }
        function H(t, e, n) {
            const o = e[n];
            if (o || "scaleID" === n)
                return o;
            const r = n.charAt(0)
              , c = Object.values(t).filter((t=>t.axis && t.axis === r));
            return c.length ? c[0].id : r
        }
        function Y(t, e) {
            if (t) {
                const n = t.options.reverse;
                return {
                    start: B(t, e.min, n ? e.end : e.start),
                    end: B(t, e.max, n ? e.start : e.end)
                }
            }
        }
        function X(t, e) {
            const {chartArea: n, scales: o} = t
              , r = o[H(o, e, "xScaleID")]
              , c = o[H(o, e, "yScaleID")];
            let l = n.width / 2
              , h = n.height / 2;
            return r && (l = B(r, e.xValue, r.left + r.width / 2)),
            c && (h = B(c, e.yValue, c.top + c.height / 2)),
            {
                x: l,
                y: h
            }
        }
        function $(t, e) {
            const n = t.scales
              , o = n[H(n, e, "xScaleID")]
              , r = n[H(n, e, "yScaleID")];
            if (!o && !r)
                return {};
            let {left: c, right: l} = o || t.chartArea
              , {top: h, bottom: d} = r || t.chartArea;
            const f = J(o, {
                min: e.xMin,
                max: e.xMax,
                start: c,
                end: l
            });
            c = f.start,
            l = f.end;
            const m = J(r, {
                min: e.yMin,
                max: e.yMax,
                start: d,
                end: h
            });
            return h = m.start,
            d = m.end,
            {
                x: c,
                y: h,
                x2: l,
                y2: d,
                width: l - c,
                height: d - h,
                centerX: c + (l - c) / 2,
                centerY: h + (d - h) / 2
            }
        }
        function U(t, e) {
            if (!S(e)) {
                const n = $(t, e);
                let o = e.radius;
                o && !isNaN(o) || (o = Math.min(n.width, n.height) / 2,
                e.radius = o);
                const r = 2 * o
                  , c = n.centerX + e.xAdjust
                  , l = n.centerY + e.yAdjust;
                return {
                    x: c - o,
                    y: l - o,
                    x2: c + o,
                    y2: l + o,
                    centerX: c,
                    centerY: l,
                    width: r,
                    height: r,
                    radius: o
                }
            }
            return function(t, e) {
                const n = X(t, e)
                  , o = 2 * e.radius;
                return {
                    x: n.x - e.radius + e.xAdjust,
                    y: n.y - e.radius + e.yAdjust,
                    x2: n.x + e.radius + e.xAdjust,
                    y2: n.y + e.radius + e.yAdjust,
                    centerX: n.x + e.xAdjust,
                    centerY: n.y + e.yAdjust,
                    radius: e.radius,
                    width: o,
                    height: o
                }
            }(t, e)
        }
        function Z(t, e) {
            const {scales: n, chartArea: o} = t
              , r = n[e.scaleID]
              , area = {
                x: o.left,
                y: o.top,
                x2: o.right,
                y2: o.bottom
            };
            return r ? function(t, area, e) {
                const n = B(t, e.value, NaN)
                  , o = B(t, e.endValue, n);
                t.isHorizontal() ? (area.x = n,
                area.x2 = o) : (area.y = n,
                area.y2 = o)
            }(r, area, e) : function(t, area, e) {
                for (const n of Object.keys(N)) {
                    const o = t[H(t, e, n)];
                    if (o) {
                        const {min: t, max: r, start: c, end: l, startProp: h, endProp: d} = N[n]
                          , f = Y(o, {
                            min: e[t],
                            max: e[r],
                            start: o[c],
                            end: o[l]
                        });
                        area[h] = f.start,
                        area[d] = f.end
                    }
                }
            }(n, area, e),
            area
        }
        function K(t, e, n) {
            const o = $(t, e);
            return o.initProperties = P(t, o, e, n),
            o.elements = [{
                type: "label",
                optionScope: "label",
                properties: Q(t, o, e),
                initProperties: o.initProperties
            }],
            o
        }
        function J(t, e) {
            const n = Y(t, e) || e;
            return {
                start: Math.min(n.start, n.end),
                end: Math.max(n.start, n.end)
            }
        }
        function G(t, e) {
            const {start: n, end: o, borderWidth: r} = t
              , {position: c, padding: {start: l, end: h}, adjust: d} = e;
            return n + r / 2 + d + M(o - r - n - l - h - e.size, c)
        }
        function Q(t, e, n) {
            const label = n.label;
            label.backgroundColor = "transparent",
            label.callout.display = !1;
            const o = k(label.position)
              , c = Object(r.l)(label.padding)
              , l = z(t.ctx, label)
              , h = function({properties: t, options: e}, n, o, r) {
                const {x: c, x2: l, width: h} = t;
                return G({
                    start: c,
                    end: l,
                    size: h,
                    borderWidth: e.borderWidth
                }, {
                    position: o.x,
                    padding: {
                        start: r.left,
                        end: r.right
                    },
                    adjust: e.label.xAdjust,
                    size: n.width
                })
            }({
                properties: e,
                options: n
            }, l, o, c)
              , d = function({properties: t, options: e}, n, o, r) {
                const {y: c, y2: l, height: h} = t;
                return G({
                    start: c,
                    end: l,
                    size: h,
                    borderWidth: e.borderWidth
                }, {
                    position: o.y,
                    padding: {
                        start: r.top,
                        end: r.bottom
                    },
                    adjust: e.label.yAdjust,
                    size: n.height
                })
            }({
                properties: e,
                options: n
            }, l, o, c)
              , f = l.width + c.width
              , m = l.height + c.height;
            return {
                x: h,
                y: d,
                x2: h + f,
                y2: d + m,
                width: f,
                height: m,
                centerX: h + f / 2,
                centerY: d + m / 2,
                rotation: label.rotation
            }
        }
        function tt(t, e, n) {
            const o = Math.cos(n)
              , r = Math.sin(n)
              , c = e.x
              , l = e.y;
            return {
                x: c + o * (t.x - c) - r * (t.y - l),
                y: l + r * (t.x - c) + o * (t.y - l)
            }
        }
        const et = ["enter", "leave"]
          , it = et.concat("click");
        function nt(t, e, n) {
            if (t.listened)
                switch (e.type) {
                case "mousemove":
                case "mouseout":
                    return function(t, e, n) {
                        if (!t.moveListened)
                            return;
                        let o;
                        o = "mousemove" === e.type ? l(t, e, n.interaction) : [];
                        const r = t.hovered;
                        t.hovered = o;
                        const c = {
                            state: t,
                            event: e
                        };
                        let h = st(c, "leave", r, o);
                        return st(c, "enter", o, r) || h
                    }(t, e, n);
                case "click":
                    return function(t, e, n) {
                        const o = t.listeners
                          , r = l(t, e, n.interaction);
                        let c;
                        for (const element of r)
                            c = ot(element.options.click || o.click, element, e) || c;
                        return c
                    }(t, e, n)
                }
        }
        function st({state: t, event: e}, n, o, r) {
            let c;
            for (const element of o)
                r.indexOf(element) < 0 && (c = ot(element.options[n] || t.listeners[n], element, e) || c);
            return c
        }
        function ot(t, element, e) {
            return !0 === Object(r.d)(t, [element.$context, e])
        }
        const at = ["afterDraw", "beforeDraw"];
        function ct(t, element, e) {
            if (t.hooked) {
                const n = element.options[e] || t.hooks[e];
                return Object(r.d)(n, [element.$context])
            }
        }
        function lt(t, e, n) {
            const o = function(t, e, n) {
                const o = e.axis
                  , c = e.id
                  , l = o + "ScaleID"
                  , h = {
                    min: Object(r.Zb)(e.min, Number.NEGATIVE_INFINITY),
                    max: Object(r.Zb)(e.max, Number.POSITIVE_INFINITY)
                };
                for (const r of n)
                    r.scaleID === c ? bt(r, e, ["value", "endValue"], h) : H(t, r, l) === c && bt(r, e, [o + "Min", o + "Max", o + "Value"], h);
                return h
            }(t.scales, e, n);
            let c = ht(e, o, "min", "suggestedMin");
            c = ht(e, o, "max", "suggestedMax") || c,
            c && Object(r.L)(e.handleTickRangeOptions) && e.handleTickRangeOptions()
        }
        function ht(t, e, n, o) {
            if (Object(r.Kb)(e[n]) && !function(t, e, n) {
                return Object(r.Nb)(t[e]) || Object(r.Nb)(t[n])
            }(t.options, n, o)) {
                const o = t[n] !== e[n];
                return t[n] = e[n],
                o
            }
        }
        function ut(t, e) {
            for (const n of ["scaleID", "xScaleID", "yScaleID"]) {
                const o = H(e, t, n);
                o && !e[o] && ft(t, n) && console.warn(`No scale found with id '${o}' for annotation '${t.id}'`)
            }
        }
        function ft(t, e) {
            if ("scaleID" === e)
                return !0;
            const n = e.charAt(0);
            for (const e of ["Min", "Max", "Value"])
                if (Object(r.Nb)(t[n + e]))
                    return !0;
            return !1
        }
        function bt(t, e, n, o) {
            for (const c of n) {
                const n = t[c];
                if (Object(r.Nb)(n)) {
                    const t = e.parse(n);
                    o.min = Math.min(o.min, t),
                    o.max = Math.max(o.max, t)
                }
            }
        }
        class gt extends o.c {
            inRange(t, e, n, o) {
                const {x: c, y: l} = tt({
                    x: t,
                    y: e
                }, this.getCenterPoint(o), Object(r.Xb)(-this.options.rotation));
                return y({
                    x: c,
                    y: l
                }, this.getProps(["x", "y", "x2", "y2"], o), n, this.options.borderWidth)
            }
            getCenterPoint(t) {
                return _(this, t)
            }
            draw(t) {
                t.save(),
                E(t, this.getCenterPoint(), this.options.rotation),
                F(t, this, this.options),
                t.restore()
            }
            get label() {
                return this.elements && this.elements[0]
            }
            resolveElementProperties(t, e) {
                return K(t, e)
            }
        }
        gt.id = "boxAnnotation",
        gt.defaults = {
            adjustScaleRange: !0,
            backgroundShadowColor: "transparent",
            borderCapStyle: "butt",
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: "miter",
            borderRadius: 0,
            borderShadowColor: "transparent",
            borderWidth: 1,
            display: !0,
            init: void 0,
            label: {
                backgroundColor: "transparent",
                borderWidth: 0,
                callout: {
                    display: !1
                },
                color: "black",
                content: null,
                display: !1,
                drawTime: void 0,
                font: {
                    family: void 0,
                    lineHeight: void 0,
                    size: void 0,
                    style: void 0,
                    weight: "bold"
                },
                height: void 0,
                opacity: void 0,
                padding: 6,
                position: "center",
                rotation: void 0,
                textAlign: "start",
                textStrokeColor: void 0,
                textStrokeWidth: 0,
                width: void 0,
                xAdjust: 0,
                yAdjust: 0,
                z: void 0
            },
            rotation: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            xMax: void 0,
            xMin: void 0,
            xScaleID: void 0,
            yMax: void 0,
            yMin: void 0,
            yScaleID: void 0,
            z: 0
        },
        gt.defaultRoutes = {
            borderColor: "color",
            backgroundColor: "color"
        },
        gt.descriptors = {
            label: {
                _fallback: !0
            }
        };
        const pt = ["left", "bottom", "top", "right"];
        class mt extends o.c {
            inRange(t, e, n, o) {
                const {x: c, y: l} = tt({
                    x: t,
                    y: e
                }, this.getCenterPoint(o), Object(r.Xb)(-this.rotation));
                return y({
                    x: c,
                    y: l
                }, this.getProps(["x", "y", "x2", "y2"], o), n, this.options.borderWidth)
            }
            getCenterPoint(t) {
                return _(this, t)
            }
            draw(t) {
                const e = this.options
                  , n = !Object(r.Nb)(this._visible) || this._visible;
                e.display && e.content && n && (t.save(),
                E(t, this.getCenterPoint(), this.rotation),
                function(t, element) {
                    const {pointX: e, pointY: n, options: o} = element
                      , c = o.callout
                      , l = c && c.display && function(element, t) {
                        const e = t.position;
                        if (pt.includes(e))
                            return e;
                        return function(element, t) {
                            const {x: e, y: n, x2: o, y2: c, width: l, height: h, pointX: d, pointY: f, centerX: m, centerY: x, rotation: y} = element
                              , _ = {
                                x: m,
                                y: x
                            }
                              , v = t.start
                              , O = j(l, v)
                              , w = j(h, v)
                              , M = [e, e + O, e + O, o]
                              , k = [n + w, c, n, c]
                              , S = [];
                            for (let t = 0; t < 4; t++) {
                                const e = tt({
                                    x: M[t],
                                    y: k[t]
                                }, _, Object(r.Xb)(y));
                                S.push({
                                    position: pt[t],
                                    distance: Object(r.T)(e, {
                                        x: d,
                                        y: f
                                    })
                                })
                            }
                            return S.sort(((a,b)=>a.distance - b.distance))[0].position
                        }(element, t)
                    }(element, c);
                    if (!l || function(element, t, e) {
                        const {pointX: n, pointY: o} = element
                          , r = t.margin;
                        let c = n
                          , l = o;
                        "left" === e ? c += r : "right" === e ? c -= r : "top" === e ? l += r : "bottom" === e && (l -= r);
                        return element.inRange(c, l)
                    }(element, c, l))
                        return;
                    t.save(),
                    t.beginPath();
                    const h = R(t, c);
                    if (!h)
                        return t.restore();
                    const {separatorStart: d, separatorEnd: f} = function(element, t) {
                        const {x: e, y: n, x2: o, y2: r} = element
                          , c = function(element, t) {
                            const {width: e, height: n, options: o} = element
                              , r = o.callout.margin + o.borderWidth / 2;
                            if ("right" === t)
                                return e + r;
                            if ("bottom" === t)
                                return n + r;
                            return -r
                        }(element, t);
                        let l, h;
                        "left" === t || "right" === t ? (l = {
                            x: e + c,
                            y: n
                        },
                        h = {
                            x: l.x,
                            y: r
                        }) : (l = {
                            x: e,
                            y: n + c
                        },
                        h = {
                            x: o,
                            y: l.y
                        });
                        return {
                            separatorStart: l,
                            separatorEnd: h
                        }
                    }(element, l)
                      , {sideStart: m, sideEnd: x} = function(element, t, e) {
                        const {y: n, width: o, height: r, options: c} = element
                          , l = c.callout.start
                          , h = function(t, e) {
                            const n = e.side;
                            if ("left" === t || "top" === t)
                                return -n;
                            return n
                        }(t, c.callout);
                        let d, f;
                        "left" === t || "right" === t ? (d = {
                            x: e.x,
                            y: n + j(r, l)
                        },
                        f = {
                            x: d.x + h,
                            y: d.y
                        }) : (d = {
                            x: e.x + j(o, l),
                            y: e.y
                        },
                        f = {
                            x: d.x,
                            y: d.y + h
                        });
                        return {
                            sideStart: d,
                            sideEnd: f
                        }
                    }(element, l, d);
                    (c.margin > 0 || 0 === o.borderWidth) && (t.moveTo(d.x, d.y),
                    t.lineTo(f.x, f.y));
                    t.moveTo(m.x, m.y),
                    t.lineTo(x.x, x.y);
                    const y = tt({
                        x: e,
                        y: n
                    }, element.getCenterPoint(), Object(r.Xb)(-element.rotation));
                    t.lineTo(y.x, y.y),
                    t.stroke(),
                    t.restore()
                }(t, this),
                F(t, this, e),
                W(t, function({x: t, y: e, width: n, height: o, options: c}) {
                    const l = c.borderWidth / 2
                      , h = Object(r.l)(c.padding);
                    return {
                        x: t + h.left + l,
                        y: e + h.top + l,
                        width: n - h.left - h.right - c.borderWidth,
                        height: o - h.top - h.bottom - c.borderWidth
                    }
                }(this), e),
                t.restore())
            }
            resolveElementProperties(t, e) {
                let n;
                if (S(e))
                    n = X(t, e);
                else {
                    const {centerX: o, centerY: r} = $(t, e);
                    n = {
                        x: o,
                        y: r
                    }
                }
                const o = Object(r.l)(e.padding)
                  , c = function(t, e, n, o) {
                    const r = e.width + o.width + n.borderWidth
                      , c = e.height + o.height + n.borderWidth
                      , l = k(n.position, "center")
                      , h = xt(t.x, r, n.xAdjust, l.x)
                      , d = xt(t.y, c, n.yAdjust, l.y);
                    return {
                        x: h,
                        y: d,
                        x2: h + r,
                        y2: d + c,
                        width: r,
                        height: c,
                        centerX: h + r / 2,
                        centerY: d + c / 2
                    }
                }(n, z(t.ctx, e), e, o);
                return {
                    initProperties: P(t, c, e),
                    pointX: n.x,
                    pointY: n.y,
                    ...c,
                    rotation: e.rotation
                }
            }
        }
        function xt(t, e, n=0, o) {
            return t - M(e, o) + n
        }
        mt.id = "labelAnnotation",
        mt.defaults = {
            adjustScaleRange: !0,
            backgroundColor: "transparent",
            backgroundShadowColor: "transparent",
            borderCapStyle: "butt",
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: "miter",
            borderRadius: 0,
            borderShadowColor: "transparent",
            borderWidth: 0,
            callout: {
                borderCapStyle: "butt",
                borderColor: void 0,
                borderDash: [],
                borderDashOffset: 0,
                borderJoinStyle: "miter",
                borderWidth: 1,
                display: !1,
                margin: 5,
                position: "auto",
                side: 5,
                start: "50%"
            },
            color: "black",
            content: null,
            display: !0,
            font: {
                family: void 0,
                lineHeight: void 0,
                size: void 0,
                style: void 0,
                weight: void 0
            },
            height: void 0,
            init: void 0,
            opacity: void 0,
            padding: 6,
            position: "center",
            rotation: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            textAlign: "center",
            textStrokeColor: void 0,
            textStrokeWidth: 0,
            width: void 0,
            xAdjust: 0,
            xMax: void 0,
            xMin: void 0,
            xScaleID: void 0,
            xValue: void 0,
            yAdjust: 0,
            yMax: void 0,
            yMin: void 0,
            yScaleID: void 0,
            yValue: void 0,
            z: 0
        },
        mt.defaultRoutes = {
            borderColor: "color"
        };
        const yt = (t,e,n)=>({
            x: t.x + n * (e.x - t.x),
            y: t.y + n * (e.y - t.y)
        })
          , _t = (t,e,n)=>yt(e, n, Math.abs((t - e.y) / (n.y - e.y))).x
          , vt = (t,e,n)=>yt(e, n, Math.abs((t - e.x) / (n.x - e.x))).y
          , Ot = t=>t * t
          , wt = (t,e,n,o)=>(1 - o) * (1 - o) * t + 2 * (1 - o) * o * e + o * o * n
          , Mt = (t,e,n,o)=>({
            x: wt(t.x, e.x, n.x, o),
            y: wt(t.y, e.y, n.y, o)
        })
          , jt = (t,e,n,o)=>2 * (1 - o) * (e - t) + 2 * o * (n - e)
          , kt = (t,e,n,o)=>-Math.atan2(jt(t.x, e.x, n.x, o), jt(t.y, e.y, n.y, o)) + .5 * r.q;
        class St extends o.c {
            inRange(t, e, n, o) {
                const r = this.options.borderWidth / 2;
                if ("x" !== n && "y" !== n) {
                    const n = {
                        mouseX: t,
                        mouseY: e
                    }
                      , {path: path, ctx: c} = this;
                    if (path) {
                        R(c, this.options);
                        const {chart: r} = this.$context
                          , l = t * r.currentDevicePixelRatio
                          , h = e * r.currentDevicePixelRatio
                          , d = c.isPointInStroke(path, l, h) || Dt(this, n, o);
                        return c.restore(),
                        d
                    }
                    return function(element, {mouseX: t, mouseY: e}, n=.001, o) {
                        const {x: r, y: c, x2: l, y2: h} = element.getProps(["x", "y", "x2", "y2"], o)
                          , d = l - r
                          , f = h - c
                          , m = Ot(d) + Ot(f)
                          , x = 0 === m ? -1 : ((t - r) * d + (e - c) * f) / m;
                        let y, _;
                        x < 0 ? (y = r,
                        _ = c) : x > 1 ? (y = l,
                        _ = h) : (y = r + x * d,
                        _ = c + x * f);
                        return Ot(t - y) + Ot(e - _) <= n
                    }(this, n, Ot(r), o) || Dt(this, n, o)
                }
                return function(element, {mouseX: t, mouseY: e}, n, {hBorderWidth: o, useFinalPosition: r}) {
                    const c = ((t,e,{x: n, y: o, x2: r, y2: c},l)=>"y" === l ? {
                        start: Math.min(o, c),
                        end: Math.max(o, c),
                        value: e
                    } : {
                        start: Math.min(n, r),
                        end: Math.max(n, r),
                        value: t
                    })(t, e, element.getProps(["x", "y", "x2", "y2"], r), n);
                    return c.value >= c.start - o && c.value <= c.end + o || Dt(element, {
                        mouseX: t,
                        mouseY: e
                    }, r, n)
                }(this, {
                    mouseX: t,
                    mouseY: e
                }, n, {
                    hBorderWidth: r,
                    useFinalPosition: o
                })
            }
            getCenterPoint(t) {
                return _(this, t)
            }
            draw(t) {
                const {x: e, y: n, x2: o, y2: c, cp: l, options: h} = this;
                if (t.save(),
                !R(t, h))
                    return t.restore();
                I(t, h);
                const d = Math.sqrt(Math.pow(o - e, 2) + Math.pow(c - n, 2));
                if (h.curve && l)
                    return function(t, element, e, n) {
                        const {x: o, y: c, x2: l, y2: h, options: d} = element
                          , {startOpts: f, endOpts: m, startAdjust: x, endAdjust: y} = Lt(element)
                          , _ = {
                            x: o,
                            y: c
                        }
                          , v = {
                            x: l,
                            y: h
                        }
                          , O = kt(_, e, v, 0)
                          , w = kt(_, e, v, 1) - r.q
                          , M = Mt(_, e, v, x / n)
                          , j = Mt(_, e, v, 1 - y / n)
                          , path = new Path2D;
                        t.beginPath(),
                        path.moveTo(M.x, M.y),
                        path.quadraticCurveTo(e.x, e.y, j.x, j.y),
                        t.shadowColor = d.borderShadowColor,
                        t.stroke(path),
                        element.path = path,
                        element.ctx = t,
                        It(t, M, {
                            angle: O,
                            adjust: x
                        }, f),
                        It(t, j, {
                            angle: w,
                            adjust: y
                        }, m)
                    }(t, this, l, d),
                    t.restore();
                const {startOpts: f, endOpts: m, startAdjust: x, endAdjust: y} = Lt(this)
                  , _ = Math.atan2(c - n, o - e);
                t.translate(e, n),
                t.rotate(_),
                t.beginPath(),
                t.moveTo(0 + x, 0),
                t.lineTo(d - y, 0),
                t.shadowColor = h.borderShadowColor,
                t.stroke(),
                Rt(t, 0, x, f),
                Rt(t, d, -y, m),
                t.restore()
            }
            get label() {
                return this.elements && this.elements[0]
            }
            resolveElementProperties(t, e) {
                const area = Z(t, e)
                  , {x: n, y: o, x2: c, y2: l} = area
                  , h = function({x: t, y: e, x2: n, y2: o}, {top: r, right: c, bottom: l, left: h}) {
                    return !(t < h && n < h || t > c && n > c || e < r && o < r || e > l && o > l)
                }(area, t.chartArea)
                  , d = h ? function(t, e, area) {
                    const {x: n, y: o} = Ct(t, e, area)
                      , {x: r, y: c} = Ct(e, t, area);
                    return {
                        x: n,
                        y: o,
                        x2: r,
                        y2: c,
                        width: Math.abs(r - n),
                        height: Math.abs(c - o)
                    }
                }({
                    x: n,
                    y: o
                }, {
                    x: c,
                    y: l
                }, t.chartArea) : {
                    x: n,
                    y: o,
                    x2: c,
                    y2: l,
                    width: Math.abs(c - n),
                    height: Math.abs(l - o)
                };
                if (d.centerX = (c + n) / 2,
                d.centerY = (l + o) / 2,
                d.initProperties = P(t, d, e),
                e.curve) {
                    const t = {
                        x: d.x,
                        y: d.y
                    }
                      , n = {
                        x: d.x2,
                        y: d.y2
                    };
                    d.cp = function(t, e, n) {
                        const {x: o, y: r, x2: c, y2: l, centerX: h, centerY: d} = t
                          , f = Math.atan2(l - r, c - o)
                          , m = k(e.controlPoint, 0);
                        return tt({
                            x: h + j(n, m.x, !1),
                            y: d + j(n, m.y, !1)
                        }, {
                            x: h,
                            y: d
                        }, f)
                    }(d, e, Object(r.T)(t, n))
                }
                const f = function(t, e, n) {
                    const o = n.borderWidth
                      , c = Object(r.l)(n.padding)
                      , l = z(t.ctx, n)
                      , h = l.width + c.width + o
                      , d = l.height + c.height + o;
                    return function(t, label, e, n) {
                        const {width: o, height: c, padding: l} = e
                          , {xAdjust: h, yAdjust: d} = label
                          , f = {
                            x: t.x,
                            y: t.y
                        }
                          , m = {
                            x: t.x2,
                            y: t.y2
                        }
                          , x = "auto" === label.rotation ? function(t) {
                            const {x: e, y: n, x2: o, y2: c} = t
                              , l = Math.atan2(c - n, o - e);
                            return l > r.q / 2 ? l - r.q : l < r.q / -2 ? l + r.q : l
                        }(t) : Object(r.Xb)(label.rotation)
                          , y = function(t, e, n) {
                            const o = Math.cos(n)
                              , r = Math.sin(n);
                            return {
                                w: Math.abs(t * o) + Math.abs(e * r),
                                h: Math.abs(t * r) + Math.abs(e * o)
                            }
                        }(o, c, x)
                          , _ = function(t, label, e, n) {
                            let o;
                            const r = function(t, e) {
                                const {x: n, x2: o, y: r, y2: c} = t
                                  , l = Math.min(r, c) - e.top
                                  , h = Math.min(n, o) - e.left
                                  , b = e.bottom - Math.max(r, c)
                                  , d = e.right - Math.max(n, o);
                                return {
                                    x: Math.min(h, d),
                                    y: Math.min(l, b),
                                    dx: h <= d ? 1 : -1,
                                    dy: l <= b ? 1 : -1
                                }
                            }(t, n);
                            o = "start" === label.position ? At({
                                w: t.x2 - t.x,
                                h: t.y2 - t.y
                            }, e, label, r) : "end" === label.position ? 1 - At({
                                w: t.x - t.x2,
                                h: t.y - t.y2
                            }, e, label, r) : M(1, label.position);
                            return o
                        }(t, label, {
                            labelSize: y,
                            padding: l
                        }, n)
                          , v = t.cp ? Mt(f, t.cp, m, _) : yt(f, m, _)
                          , O = {
                            size: y.w,
                            min: n.left,
                            max: n.right,
                            padding: l.left
                        }
                          , w = {
                            size: y.h,
                            min: n.top,
                            max: n.bottom,
                            padding: l.top
                        }
                          , j = Tt(v.x, O) + h
                          , k = Tt(v.y, w) + d;
                        return {
                            x: j - o / 2,
                            y: k - c / 2,
                            x2: j + o / 2,
                            y2: k + c / 2,
                            centerX: j,
                            centerY: k,
                            pointX: v.x,
                            pointY: v.y,
                            width: o,
                            height: c,
                            rotation: Object(r.g)(x)
                        }
                    }(e, n, {
                        width: h,
                        height: d,
                        padding: c
                    }, t.chartArea)
                }(t, d, e.label);
                return f._visible = h,
                d.elements = [{
                    type: "label",
                    optionScope: "label",
                    properties: f,
                    initProperties: d.initProperties
                }],
                d
            }
        }
        St.id = "lineAnnotation";
        const Pt = {
            backgroundColor: void 0,
            backgroundShadowColor: void 0,
            borderColor: void 0,
            borderDash: void 0,
            borderDashOffset: void 0,
            borderShadowColor: void 0,
            borderWidth: void 0,
            display: void 0,
            fill: void 0,
            length: void 0,
            shadowBlur: void 0,
            shadowOffsetX: void 0,
            shadowOffsetY: void 0,
            width: void 0
        };
        function Ct({x: t, y: e}, n, {top: o, right: r, bottom: c, left: l}) {
            return t < l && (e = vt(l, {
                x: t,
                y: e
            }, n),
            t = l),
            t > r && (e = vt(r, {
                x: t,
                y: e
            }, n),
            t = r),
            e < o && (t = _t(o, {
                x: t,
                y: e
            }, n),
            e = o),
            e > c && (t = _t(c, {
                x: t,
                y: e
            }, n),
            e = c),
            {
                x: t,
                y: e
            }
        }
        function Dt(element, {mouseX: t, mouseY: e}, n, o) {
            const label = element.label;
            return label.options.display && label.inRange(t, e, o, n)
        }
        function At(t, e, label, n) {
            const {labelSize: o, padding: r} = e
              , c = t.w * n.dx
              , l = t.h * n.dy
              , h = c > 0 && (o.w / 2 + r.left - n.x) / c
              , d = l > 0 && (o.h / 2 + r.top - n.y) / l;
            return m(Math.max(h, d), 0, .25)
        }
        function Tt(t, e) {
            const {size: n, min: o, max: r, padding: c} = e
              , l = n / 2;
            return n > r - o ? (r + o) / 2 : (o >= t - c - l && (t = o + c + l),
            r <= t + c + l && (t = r - c - l),
            t)
        }
        function Lt(line) {
            const t = line.options
              , e = t.arrowHeads && t.arrowHeads.start
              , n = t.arrowHeads && t.arrowHeads.end;
            return {
                startOpts: e,
                endOpts: n,
                startAdjust: Et(line, e),
                endAdjust: Et(line, n)
            }
        }
        function Et(line, t) {
            if (!t || !t.display)
                return 0;
            const {length: e, width: n} = t
              , o = line.options.borderWidth / 2
              , r = {
                x: e,
                y: n + o
            }
              , c = {
                x: 0,
                y: o
            };
            return Math.abs(_t(0, r, c))
        }
        function Rt(t, e, n, o) {
            if (!o || !o.display)
                return;
            const {length: r, width: c, fill: l, backgroundColor: h, borderColor: d} = o
              , f = Math.abs(e - r) + n;
            t.beginPath(),
            I(t, o),
            R(t, o),
            t.moveTo(f, -c),
            t.lineTo(e + n, 0),
            t.lineTo(f, c),
            !0 === l ? (t.fillStyle = h || d,
            t.closePath(),
            t.fill(),
            t.shadowColor = "transparent") : t.shadowColor = o.borderShadowColor,
            t.stroke()
        }
        function It(t, {x: e, y: n}, {angle: o, adjust: r}, c) {
            c && c.display && (t.save(),
            t.translate(e, n),
            t.rotate(o),
            Rt(t, 0, -r, c),
            t.restore())
        }
        St.defaults = {
            adjustScaleRange: !0,
            arrowHeads: {
                display: !1,
                end: Object.assign({}, Pt),
                fill: !1,
                length: 12,
                start: Object.assign({}, Pt),
                width: 6
            },
            borderDash: [],
            borderDashOffset: 0,
            borderShadowColor: "transparent",
            borderWidth: 2,
            curve: !1,
            controlPoint: {
                y: "-50%"
            },
            display: !0,
            endValue: void 0,
            init: void 0,
            label: {
                backgroundColor: "rgba(0,0,0,0.8)",
                backgroundShadowColor: "transparent",
                borderCapStyle: "butt",
                borderColor: "black",
                borderDash: [],
                borderDashOffset: 0,
                borderJoinStyle: "miter",
                borderRadius: 6,
                borderShadowColor: "transparent",
                borderWidth: 0,
                callout: Object.assign({}, mt.defaults.callout),
                color: "#fff",
                content: null,
                display: !1,
                drawTime: void 0,
                font: {
                    family: void 0,
                    lineHeight: void 0,
                    size: void 0,
                    style: void 0,
                    weight: "bold"
                },
                height: void 0,
                opacity: void 0,
                padding: 6,
                position: "center",
                rotation: 0,
                shadowBlur: 0,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                textAlign: "center",
                textStrokeColor: void 0,
                textStrokeWidth: 0,
                width: void 0,
                xAdjust: 0,
                yAdjust: 0,
                z: void 0
            },
            scaleID: void 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            value: void 0,
            xMax: void 0,
            xMin: void 0,
            xScaleID: void 0,
            yMax: void 0,
            yMin: void 0,
            yScaleID: void 0,
            z: 0
        },
        St.descriptors = {
            arrowHeads: {
                start: {
                    _fallback: !0
                },
                end: {
                    _fallback: !0
                },
                _fallback: !0
            }
        },
        St.defaultRoutes = {
            borderColor: "color"
        };
        class zt extends o.c {
            inRange(t, e, n, o) {
                const c = this.options.rotation
                  , l = this.options.borderWidth;
                if ("x" !== n && "y" !== n)
                    return function(p, ellipse, t, e) {
                        const {width: n, height: o, centerX: c, centerY: l} = ellipse
                          , h = n / 2
                          , d = o / 2;
                        if (h <= 0 || d <= 0)
                            return !1;
                        const f = Object(r.Xb)(t || 0)
                          , m = e / 2 || 0
                          , x = Math.cos(f)
                          , y = Math.sin(f)
                          , a = Math.pow(x * (p.x - c) + y * (p.y - l), 2)
                          , b = Math.pow(y * (p.x - c) - x * (p.y - l), 2);
                        return a / Math.pow(h + m, 2) + b / Math.pow(d + m, 2) <= 1.0001
                    }({
                        x: t,
                        y: e
                    }, this.getProps(["width", "height", "centerX", "centerY"], o), c, l);
                const {x: h, y: d, x2: m, y2: x} = this.getProps(["x", "y", "x2", "y2"], o)
                  , y = l / 2
                  , _ = "y" === n ? {
                    start: d,
                    end: x
                } : {
                    start: h,
                    end: m
                }
                  , v = tt({
                    x: t,
                    y: e
                }, this.getCenterPoint(o), Object(r.Xb)(-c));
                return v[n] >= _.start - y - f && v[n] <= _.end + y + f
            }
            getCenterPoint(t) {
                return _(this, t)
            }
            draw(t) {
                const {width: e, height: n, centerX: o, centerY: c, options: l} = this;
                t.save(),
                E(t, this.getCenterPoint(), l.rotation),
                I(t, this.options),
                t.beginPath(),
                t.fillStyle = l.backgroundColor;
                const h = R(t, l);
                t.ellipse(o, c, n / 2, e / 2, r.q / 2, 0, 2 * r.q),
                t.fill(),
                h && (t.shadowColor = l.borderShadowColor,
                t.stroke()),
                t.restore()
            }
            get label() {
                return this.elements && this.elements[0]
            }
            resolveElementProperties(t, e) {
                return K(t, e, !0)
            }
        }
        zt.id = "ellipseAnnotation",
        zt.defaults = {
            adjustScaleRange: !0,
            backgroundShadowColor: "transparent",
            borderDash: [],
            borderDashOffset: 0,
            borderShadowColor: "transparent",
            borderWidth: 1,
            display: !0,
            init: void 0,
            label: Object.assign({}, gt.defaults.label),
            rotation: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            xMax: void 0,
            xMin: void 0,
            xScaleID: void 0,
            yMax: void 0,
            yMin: void 0,
            yScaleID: void 0,
            z: 0
        },
        zt.defaultRoutes = {
            borderColor: "color",
            backgroundColor: "color"
        },
        zt.descriptors = {
            label: {
                _fallback: !0
            }
        };
        class Ft extends o.c {
            inRange(t, e, n, o) {
                const {x: r, y: c, x2: l, y2: h, width: d} = this.getProps(["x", "y", "x2", "y2", "width"], o)
                  , f = this.options.borderWidth;
                if ("x" !== n && "y" !== n)
                    return function(t, e, n, o) {
                        if (!t || !e || n <= 0)
                            return !1;
                        const r = o / 2;
                        return Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2) <= Math.pow(n + r, 2)
                    }({
                        x: t,
                        y: e
                    }, this.getCenterPoint(o), d / 2, f);
                const m = f / 2
                  , x = "y" === n ? {
                    start: c,
                    end: h,
                    value: e
                } : {
                    start: r,
                    end: l,
                    value: t
                };
                return x.value >= x.start - m && x.value <= x.end + m
            }
            getCenterPoint(t) {
                return _(this, t)
            }
            draw(t) {
                const e = this.options
                  , n = e.borderWidth;
                if (e.radius < .1)
                    return;
                t.save(),
                t.fillStyle = e.backgroundColor,
                I(t, e);
                const o = R(t, e);
                V(t, this, this.centerX, this.centerY),
                o && !L(e.pointStyle) && (t.shadowColor = e.borderShadowColor,
                t.stroke()),
                t.restore(),
                e.borderWidth = n
            }
            resolveElementProperties(t, e) {
                const n = U(t, e);
                return n.initProperties = P(t, n, e, !0),
                n
            }
        }
        Ft.id = "pointAnnotation",
        Ft.defaults = {
            adjustScaleRange: !0,
            backgroundShadowColor: "transparent",
            borderDash: [],
            borderDashOffset: 0,
            borderShadowColor: "transparent",
            borderWidth: 1,
            display: !0,
            init: void 0,
            pointStyle: "circle",
            radius: 10,
            rotation: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            xAdjust: 0,
            xMax: void 0,
            xMin: void 0,
            xScaleID: void 0,
            xValue: void 0,
            yAdjust: 0,
            yMax: void 0,
            yMin: void 0,
            yScaleID: void 0,
            yValue: void 0,
            z: 0
        },
        Ft.defaultRoutes = {
            borderColor: "color",
            backgroundColor: "color"
        };
        class Wt extends o.c {
            inRange(t, e, n, o) {
                if ("x" !== n && "y" !== n)
                    return this.options.radius >= .1 && this.elements.length > 1 && function(t, e, n, o) {
                        let r = !1
                          , c = t[t.length - 1].getProps(["bX", "bY"], o);
                        for (const l of t) {
                            const t = l.getProps(["bX", "bY"], o);
                            t.bY > n != c.bY > n && e < (c.bX - t.bX) * (n - t.bY) / (c.bY - t.bY) + t.bX && (r = !r),
                            c = t
                        }
                        return r
                    }(this.elements, t, e, o);
                const c = tt({
                    x: t,
                    y: e
                }, this.getCenterPoint(o), Object(r.Xb)(-this.options.rotation))
                  , l = this.elements.map((t=>"y" === n ? t.bY : t.bX))
                  , h = Math.min(...l)
                  , d = Math.max(...l);
                return c[n] >= h && c[n] <= d
            }
            getCenterPoint(t) {
                return _(this, t)
            }
            draw(t) {
                const {elements: e, options: n} = this;
                t.save(),
                t.beginPath(),
                t.fillStyle = n.backgroundColor,
                I(t, n);
                const o = R(t, n);
                let r = !0;
                for (const n of e)
                    r ? (t.moveTo(n.x, n.y),
                    r = !1) : t.lineTo(n.x, n.y);
                t.closePath(),
                t.fill(),
                o && (t.shadowColor = n.borderShadowColor,
                t.stroke()),
                t.restore()
            }
            resolveElementProperties(t, e) {
                const n = U(t, e)
                  , {sides: o, rotation: c} = e
                  , l = []
                  , h = 2 * r.q / o;
                let d = c * r.Db;
                for (let i = 0; i < o; i++,
                d += h) {
                    const o = Vt(n, e, d);
                    o.initProperties = P(t, n, e),
                    l.push(o)
                }
                return n.elements = l,
                n
            }
        }
        function Vt({centerX: t, centerY: e}, {radius: n, borderWidth: o}, r) {
            const c = o / 2
              , l = Math.sin(r)
              , h = Math.cos(r)
              , d = {
                x: t + l * n,
                y: e - h * n
            };
            return {
                type: "point",
                optionScope: "point",
                properties: {
                    x: d.x,
                    y: d.y,
                    centerX: d.x,
                    centerY: d.y,
                    bX: t + l * (n + c),
                    bY: e - h * (n + c)
                }
            }
        }
        Wt.id = "polygonAnnotation",
        Wt.defaults = {
            adjustScaleRange: !0,
            backgroundShadowColor: "transparent",
            borderCapStyle: "butt",
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: "miter",
            borderShadowColor: "transparent",
            borderWidth: 1,
            display: !0,
            init: void 0,
            point: {
                radius: 0
            },
            radius: 10,
            rotation: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            sides: 3,
            xAdjust: 0,
            xMax: void 0,
            xMin: void 0,
            xScaleID: void 0,
            xValue: void 0,
            yAdjust: 0,
            yMax: void 0,
            yMin: void 0,
            yScaleID: void 0,
            yValue: void 0,
            z: 0
        },
        Wt.defaultRoutes = {
            borderColor: "color",
            backgroundColor: "color"
        };
        const Nt = {
            box: gt,
            ellipse: zt,
            label: mt,
            line: St,
            point: Ft,
            polygon: Wt
        };
        Object.keys(Nt).forEach((t=>{
            o.d.describe(`elements.${Nt[t].id}`, {
                _fallback: "plugins.annotation.common"
            })
        }
        ));
        const Bt = {
            update: Object.assign
        }
          , Ht = it.concat(at)
          , Yt = (t,e)=>Object(r.Mb)(e) ? Gt(t, e) : t
          , Xt = t=>"color" === t || "font" === t;
        function $t(t="line") {
            return Nt[t] ? t : (console.warn(`Unknown annotation type: '${t}', defaulting to 'line'`),
            "line")
        }
        function Ut(t, e, n, c) {
            const l = function(t, e, n) {
                if ("reset" === n || "none" === n || "resize" === n)
                    return Bt;
                return new o.a(t,e)
            }(t, n.animations, c)
              , h = e.annotations
              , d = function(t, e) {
                const n = e.length
                  , o = t.length;
                if (o < n) {
                    const e = n - o;
                    t.splice(o, 0, ...new Array(e))
                } else
                    o > n && t.splice(n, o - n);
                return t
            }(e.elements, h);
            for (let i = 0; i < h.length; i++) {
                const e = h[i]
                  , element = Kt(d, i, e.type)
                  , n = e.setContext(Qt(t, element, e))
                  , o = element.resolveElementProperties(t, n);
                o.skip = Zt(o),
                "elements"in o && (qt(element, o.elements, n, l),
                delete o.elements),
                Object(r.Nb)(element.x) || Object.assign(element, o),
                Object.assign(element, o.initProperties),
                o.options = Jt(n),
                l.update(element, o)
            }
        }
        function Zt(t) {
            return isNaN(t.x) || isNaN(t.y)
        }
        function qt(t, e, n, o) {
            const r = t.elements || (t.elements = []);
            r.length = e.length;
            for (let i = 0; i < e.length; i++) {
                const t = e[i]
                  , c = t.properties
                  , l = Kt(r, i, t.type, t.initProperties)
                  , h = n[t.optionScope].override(t);
                c.options = Jt(h),
                o.update(l, c)
            }
        }
        function Kt(t, e, n, o) {
            const r = Nt[$t(n)];
            let element = t[e];
            return element && element instanceof r || (element = t[e] = new r,
            Object.assign(element, o)),
            element
        }
        function Jt(t) {
            const e = Nt[$t(t.type)]
              , n = {};
            n.id = t.id,
            n.type = t.type,
            n.drawTime = t.drawTime,
            Object.assign(n, Gt(t, e.defaults), Gt(t, e.defaultRoutes));
            for (const e of Ht)
                n[e] = t[e];
            return n
        }
        function Gt(t, defs) {
            const e = {};
            for (const n of Object.keys(defs)) {
                const o = defs[n]
                  , c = t[n];
                Xt(n) && Object(r.Cb)(c) ? e[n] = c.map((t=>Yt(t, o))) : e[n] = Yt(c, o)
            }
            return e
        }
        function Qt(t, element, e) {
            return element.$context || (element.$context = Object.assign(Object.create(t.getContext()), {
                element: element,
                id: e.id,
                type: "annotation"
            }))
        }
        const te = new Map
          , ee = it.concat(at);
        var ie = {
            id: "annotation",
            version: "2.2.1",
            beforeRegister() {
                !function(t, e, n, o=!0) {
                    const r = n.split(".");
                    let i = 0;
                    for (const c of e.split(".")) {
                        const l = r[i++];
                        if (parseInt(c, 10) < parseInt(l, 10))
                            break;
                        if (d(l, c)) {
                            if (o)
                                throw new Error(`${t} v${n} is not supported. v${e} or newer is required.`);
                            return !1
                        }
                    }
                }("chart.js", "3.7", o.b.version)
            },
            afterRegister() {
                o.b.register(Nt)
            },
            afterUnregister() {
                o.b.unregister(Nt)
            },
            beforeInit(t) {
                te.set(t, {
                    annotations: [],
                    elements: [],
                    visibleElements: [],
                    listeners: {},
                    listened: !1,
                    moveListened: !1,
                    hooks: {},
                    hooked: !1,
                    hovered: []
                })
            },
            beforeUpdate(t, e, n) {
                const o = te.get(t).annotations = [];
                let c = n.annotations;
                Object(r.Mb)(c) ? Object.keys(c).forEach((t=>{
                    const e = c[t];
                    Object(r.Mb)(e) && (e.id = t,
                    o.push(e))
                }
                )) : Object(r.Cb)(c) && o.push(...c),
                function(t, e) {
                    for (const n of t)
                        ut(n, e)
                }(o, t.scales)
            },
            afterDataLimits(t, e) {
                const n = te.get(t);
                lt(t, e.scale, n.annotations.filter((a=>a.display && a.adjustScaleRange)))
            },
            afterUpdate(t, e, n) {
                const o = te.get(t);
                !function(t, e, n) {
                    e.listened = C(n, it, e.listeners),
                    e.moveListened = !1,
                    e._getElements = l,
                    et.forEach((t=>{
                        Object(r.L)(n[t]) && (e.moveListened = !0)
                    }
                    )),
                    e.listened && e.moveListened || e.annotations.forEach((t=>{
                        !e.listened && Object(r.L)(t.click) && (e.listened = !0),
                        e.moveListened || et.forEach((n=>{
                            Object(r.L)(t[n]) && (e.listened = !0,
                            e.moveListened = !0)
                        }
                        ))
                    }
                    ))
                }(0, o, n),
                Ut(t, o, n, e.mode),
                o.visibleElements = o.elements.filter((t=>!t.skip && t.options.display)),
                function(t, e, n) {
                    const o = e.visibleElements;
                    e.hooked = C(n, at, e.hooks),
                    e.hooked || o.forEach((t=>{
                        e.hooked || at.forEach((n=>{
                            Object(r.L)(t.options[n]) && (e.hooked = !0)
                        }
                        ))
                    }
                    ))
                }(0, o, n)
            },
            beforeDatasetsDraw(t, e, n) {
                ne(t, "beforeDatasetsDraw", n.clip)
            },
            afterDatasetsDraw(t, e, n) {
                ne(t, "afterDatasetsDraw", n.clip)
            },
            beforeDraw(t, e, n) {
                ne(t, "beforeDraw", n.clip)
            },
            afterDraw(t, e, n) {
                ne(t, "afterDraw", n.clip)
            },
            beforeEvent(t, e, n) {
                nt(te.get(t), e.event, n) && (e.changed = !0)
            },
            afterDestroy(t) {
                te.delete(t)
            },
            _getState: t=>te.get(t),
            defaults: {
                animations: {
                    numbers: {
                        properties: ["x", "y", "x2", "y2", "width", "height", "centerX", "centerY", "pointX", "pointY", "radius"],
                        type: "number"
                    }
                },
                clip: !0,
                interaction: {
                    mode: void 0,
                    axis: void 0,
                    intersect: void 0
                },
                common: {
                    drawTime: "afterDatasetsDraw",
                    init: !1,
                    label: {}
                }
            },
            descriptors: {
                _indexable: !1,
                _scriptable: t=>!ee.includes(t) && "init" !== t,
                annotations: {
                    _allKeys: !1,
                    _fallback: (t,e)=>`elements.${Nt[$t(e.type)].id}`
                },
                interaction: {
                    _fallback: !0
                },
                common: {
                    label: {
                        _indexable: Xt,
                        _fallback: !0
                    },
                    _indexable: Xt
                }
            },
            additionalOptionScopes: [""]
        };
        function ne(t, e, n) {
            const {ctx: o, chartArea: c} = t
              , l = te.get(t);
            n && Object(r.m)(o, c);
            const h = function(t, e) {
                const n = [];
                for (const o of t)
                    if (o.options.drawTime === e && n.push({
                        element: o,
                        main: !0
                    }),
                    o.elements && o.elements.length)
                        for (const sub of o.elements)
                            sub.options.display && sub.options.drawTime === e && n.push({
                                element: sub
                            });
                return n
            }(l.visibleElements, e).sort(((a,b)=>a.element.options.z - b.element.options.z));
            for (const t of h)
                se(o, c, l, t);
            n && Object(r.o)(o)
        }
        function se(t, e, n, o) {
            const r = o.element;
            o.main ? (ct(n, r, "beforeDraw"),
            r.draw(t, e),
            ct(n, r, "afterDraw")) : r.draw(t, e)
        }
    }
}]);
